using System;
using System.Security;
using System.Runtime.CompilerServices;
using System.Diagnostics;


namespace TAlex.MathCore.LinearAlgebra
{
    //[NativeCppClass]
    internal struct complex16
    {
        public double r;
        public double i;

        public complex16(double r, double i)
        {
            this.r = r;
            this.i = i;
        }

        public override string ToString()
        {
            return String.Format("({0}, {1})", r, i);
        }
    }

    internal class SuppressUnmanagedCodeSecurityAttribute : Attribute
    {
    }

    /// <summary>
    /// Represents the routines from the Linear Algebra PACKage 3.2.1.
    /// </summary>
    internal static class lapack
    {
        #region libf2c

        private static double d_imag(complex16* z)
        {
            return z.i;
        }

        private static void d_cnjg(complex16* r, complex16* z)
        {
            double zi = z.i;
            r.r = z.r;
            r.i = -zi;
        }

        private static double d_sign(double* a, double* b)
        {
            double x;
            x = (*a >= 0 ? *a : -*a);
            return (*b >= 0 ? x : -x);
        }

        private static double f__cabs(double real, double imag)
        {
            double temp;

            if (real < 0)
                real = -real;
            if (imag < 0)
                imag = -imag;
            if (imag > real)
            {
                temp = real;
                real = imag;
                imag = temp;
            }
            if ((real + imag) == real)
                return real;

            temp = imag / real;
            temp = real * Math.Sqrt(1.0 + temp * temp); //overflow!!
            return temp;
        }

        private static int i_nint(float* x)
        {
            return (int)(*x >= 0 ? Math.Floor(*x + 0.5) : -Math.Floor(0.5 - *x));
        }

        private static double pow_dd(double* ap, double* bp)
        {
            return Math.Pow(*ap, *bp);
        }

        private static double pow_di(double* ap, int* bp)
        {
            double pow, x;
            int n;
            uint u;

            pow = 1;
            x = *ap;
            n = *bp;

            if (n != 0)
            {
                if (n < 0)
                {
                    n = -n;
                    x = 1 / x;
                }

                for (u = (uint)n; ; )
                {
                    if ((u & 01) != 0)
                        pow *= x;
                    if ((u >>= 1) != 0)
                        x *= x;
                    else
                        break;
                }
            }

            return pow;
        }

        private static int pow_ii(int* ap, int* bp)
        {
            int pow, x, n;
            uint u;

            x = *ap;
            n = *bp;

            if (n <= 0)
            {
                if (n == 0 || x == 1)
                    return 1;
                if (x != -1)
                    return x == 0 ? 1 / x : 0;
                n = -n;
            }
            u = (uint)n;

            for (pow = 1; ; )
            {
                if ((u & 01) != 0)
                    pow *= x;
                if ((u >>= 1) != 0)
                    x *= x;
                else
                    break;
            }

            return pow;
        }

        private static void pow_zi(complex16* p, complex16* a, int* b)
        {
            // p = a**b  

            int n;
            uint u;
            double t;
            complex16 q, x;

            complex16 one;
            one.r = 1.0;
            one.i = 0.0;

            n = *b;
            q.r = 1;
            q.i = 0;

            if (n == 0)
                goto done;

            if (n < 0)
            {
                n = -n;
                z_div(&x, &one, a);
            }
            else
            {
                x.r = a.r;
                x.i = a.i;
            }

            for (u = (uint)n; ; )
            {
                if ((u & 01) != 0)
                {
                    t = q.r * x.r - q.i * x.i;
                    q.i = q.r * x.i + q.i * x.r;
                    q.r = t;
                }
                if ((u >>= 1) != 0)
                {
                    t = x.r * x.r - x.i * x.i;
                    x.i = 2 * x.r * x.i;
                    x.r = t;
                }
                else
                    break;
            }

        done:
            p.i = q.i;
            p.r = q.r;
        }

        private static double z_abs(complex16* z)
        {
            return f__cabs(z.r, z.i);
        }

        private static void z_div(complex16* c, complex16* a, complex16* b)
        {
            double ratio, den;
            double abr, abi, cr;

            if ((abr = b.r) < 0.0)
                abr = -abr;
            if ((abi = b.i) < 0.0)
                abi = -abi;
            if (abr <= abi)
            {
                if (abi == 0)
                {
                    if (a.i != 0 || a.r != 0)
                        abi = 1.0;
                    c.i = c.r = abi / abr;
                    return;
                }
                ratio = b.r / b.i;
                den = b.i * (1 + ratio * ratio);
                cr = (a.r * ratio + a.i) / den;
                c.i = (a.i * ratio - a.r) / den;
            }

            else
            {
                ratio = b.i / b.r;
                den = b.r * (1 + ratio * ratio);
                cr = (a.r + a.i * ratio) / den;
                c.i = (a.i - a.r * ratio) / den;
            }

            c.r = cr;
        }

        private static void z_sqrt(complex16* r, complex16* z)
        {
            double mag, zi = z.i, zr = z.r;

            mag = f__cabs(zr, zi);

            if (mag == 0.0)
                r.r = r.i = 0.0;
            else if (zr > 0)
            {
                r.r = Math.Sqrt(0.5 * (mag + zr));
                r.i = zi / r.r / 2;
            }
            else
            {
                r.i = Math.Sqrt(0.5 * (mag - zr));

                if (zi < 0)
                    r.i = -r.i;

                r.r = zi / r.i / 2;
            }
        }

        #endregion

        #region blas

        [SuppressUnmanagedCodeSecurity]
        public static double dcabs1(complex16* z)
        {
            //  Purpose
            //  =======

            //  DCABS1 computes absolute value of a double complex number

            return Math.Abs(z.r) + Math.Abs(d_imag(z));
        }

        [SuppressUnmanagedCodeSecurity]
        public static int dcopy(int* n, double* dx, int* incx, double* dy, int* incy)
        {
            //  Purpose
            //  =======

            //     copies a vector, x, to a vector, y.
            //     uses unrolled loops for increments equal to one.
            //     jack dongarra, linpack, 3/11/78.
            //     modified 12/3/93, array(1) declarations changed to array(*)

            // System generated locals
            int i__1;

            // Local variables
            int i, m, ix, iy, mp1;

            // Parameter adjustments
            --dy;
            --dx;

            // Function Body
            if (*n <= 0)
            {
                return 0;
            }

            if (*incx == 1 && *incy == 1)
            {
                goto L20;
            }

            // code for unequal increments or equal increments
            // not equal to 1

            ix = 1;
            iy = 1;
            if (*incx < 0)
            {
                ix = (-(*n) + 1) * *incx + 1;
            }

            if (*incy < 0)
            {
                iy = (-(*n) + 1) * *incy + 1;
            }

            i__1 = *n;
            for (i = 1; i <= i__1; ++i)
            {
                dy[iy] = dx[ix];
                ix += *incx;
                iy += *incy;
            }
            return 0;

            // code for both increments equal to 1

            // clean-up loop

        L20:
            m = *n % 7;
            if (m == 0)
            {
                goto L40;
            }

            i__1 = m;
            for (i = 1; i <= i__1; ++i)
            {
                dy[i] = dx[i];
            }

            if (*n < 7)
            {
                return 0;
            }

        L40:
            mp1 = m + 1;
            i__1 = *n;
            for (i = mp1; i <= i__1; i += 7)
            {
                dy[i] = dx[i];
                dy[i + 1] = dx[i + 1];
                dy[i + 2] = dx[i + 2];
                dy[i + 3] = dx[i + 3];
                dy[i + 4] = dx[i + 4];
                dy[i + 5] = dx[i + 5];
                dy[i + 6] = dx[i + 6];
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static double ddot(int* n, double* dx, int* incx, double* dy, int* incy)
        {
            //  Purpose
            //  =======

            //     forms the dot product of two vectors.
            //     uses unrolled loops for increments equal to one.
            //     jack dongarra, linpack, 3/11/78.0
            //     modified 12/3/93, array(1) declarations changed to array(*)

            // System generated locals
            int i__1;
            double ret_val;

            // Local variables
            int i, m, ix, iy, mp1;
            double dtemp;

            // Parameter adjustments
            --dy;
            --dx;

            // Function Body
            ret_val = 0.0;
            dtemp = 0.0;
            if (*n <= 0)
            {
                return ret_val;
            }
            if (*incx == 1 && *incy == 1)
            {
                goto L20;
            }

            // code for unequal increments or equal increments
            // not equal to 1

            ix = 1;
            iy = 1;
            if (*incx < 0)
            {
                ix = (-(*n) + 1) * *incx + 1;
            }
            if (*incy < 0)
            {
                iy = (-(*n) + 1) * *incy + 1;
            }
            i__1 = *n;
            for (i = 1; i <= i__1; ++i)
            {
                dtemp += dx[ix] * dy[iy];
                ix += *incx;
                iy += *incy;
            }
            ret_val = dtemp;
            return ret_val;

            // code for both increments equal to 1

            // clean-up loop

        L20:
            m = *n % 5;
            if (m == 0)
            {
                goto L40;
            }
            i__1 = m;
            for (i = 1; i <= i__1; ++i)
            {
                dtemp += dx[i] * dy[i];
            }
            if (*n < 5)
            {
                goto L60;
            }

        L40:
            mp1 = m + 1;
            i__1 = *n;
            for (i = mp1; i <= i__1; i += 5)
            {
                dtemp = dtemp + dx[i] * dy[i] + dx[i + 1] * dy[i + 1] +
                    dx[i + 2] * dy[i + 2] + dx[i + 3] * dy[i + 3] + dx[i + 4] * dy[i + 4];
            }

        L60:
            ret_val = dtemp;
            return ret_val;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int dgemm(string transa, string transb, int* m, int* n, int* k,
            double* alpha, double* a, int* lda, double* b, int* ldb, double* beta, double* c, int* ldc)
        {
            //  Purpose
            //  =======

            //  DGEMM  performs one of the matrix-matrix operations

            //     C := alpha*op( A )*op( B ) + beta*C,

            //  where  op( X ) is one of

            //     op( X ) = X   or   op( X ) = X',

            //  alpha and beta are scalars, and A, B and C are matrices, with op( A )
            //  an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.

            //  Arguments
            //  ==========

            //  TRANSA - CHARACTER*1.
            //           On entry, TRANSA specifies the form of op( A ) to be used in
            //           the matrix multiplication as follows:

            //              TRANSA = 'N' or 'n',  op( A ) = A.

            //              TRANSA = 'T' or 't',  op( A ) = A'.

            //              TRANSA = 'C' or 'c',  op( A ) = A'.

            //           Unchanged on exit.

            //  TRANSB - CHARACTER*1.
            //           On entry, TRANSB specifies the form of op( B ) to be used in
            //           the matrix multiplication as follows:

            //              TRANSB = 'N' or 'n',  op( B ) = B.

            //              TRANSB = 'T' or 't',  op( B ) = B'.

            //              TRANSB = 'C' or 'c',  op( B ) = B'.

            //           Unchanged on exit.

            //  M      - int.
            //           On entry,  M  specifies  the number  of rows  of the  matrix
            //           op( A )  and of the  matrix  C.  M  must  be at least  zero.
            //           Unchanged on exit.

            //  N      - int.
            //           On entry,  N  specifies the number  of columns of the matrix
            //           op( B ) and the number of columns of the matrix C. N must be
            //           at least zero.
            //           Unchanged on exit.

            //  K      - int.
            //           On entry,  K  specifies  the number of columns of the matrix
            //           op( A ) and the number of rows of the matrix op( B ). K must
            //           be at least  zero.
            //           Unchanged on exit.

            //  ALPHA  - DOUBLE PRECISION.
            //           On entry, ALPHA specifies the scalar alpha.
            //           Unchanged on exit.

            //  A      - DOUBLE PRECISION array of DIMENSION ( LDA, ka ), where ka is
            //           k  when  TRANSA = 'N' or 'n',  and is  m  otherwise.
            //           Before entry with  TRANSA = 'N' or 'n',  the leading  m by k
            //           part of the array  A  must contain the matrix  A,  otherwise
            //           the leading  k by m  part of the array  A  must contain  the
            //           matrix A.
            //           Unchanged on exit.

            //  LDA    - int.
            //           On entry, LDA specifies the first dimension of A as declared
            //           in the calling (sub) program. When  TRANSA = 'N' or 'n' then
            //           LDA must be at least  max( 1, m ), otherwise  LDA must be at
            //           least  max( 1, k ).
            //           Unchanged on exit.

            //  B      - DOUBLE PRECISION array of DIMENSION ( LDB, kb ), where kb is
            //           n  when  TRANSB = 'N' or 'n',  and is  k  otherwise.
            //           Before entry with  TRANSB = 'N' or 'n',  the leading  k by n
            //           part of the array  B  must contain the matrix  B,  otherwise
            //           the leading  n by k  part of the array  B  must contain  the
            //           matrix B.
            //           Unchanged on exit.

            //  LDB    - int.
            //           On entry, LDB specifies the first dimension of B as declared
            //           in the calling (sub) program. When  TRANSB = 'N' or 'n' then
            //           LDB must be at least  max( 1, k ), otherwise  LDB must be at
            //           least  max( 1, n ).
            //           Unchanged on exit.

            //  BETA   - DOUBLE PRECISION.
            //           On entry,  BETA  specifies the scalar  beta.  When  BETA  is
            //           supplied as zero then C need not be set on input.
            //           Unchanged on exit.

            //  C      - DOUBLE PRECISION array of DIMENSION ( LDC, n ).
            //           Before entry, the leading  m by n  part of the array  C must
            //           contain the matrix  C,  except when  beta  is zero, in which
            //           case C need not be set on entry.
            //           On exit, the array  C  is overwritten by the  m by n  matrix
            //           ( alpha*op( A )*op( B ) + beta*C ).

            //  LDC    - int.
            //           On entry, LDC specifies the first dimension of C as declared
            //           in  the  calling  (sub)  program.   LDC  must  be  at  least
            //           max( 1, m ).
            //           Unchanged on exit.


            //  Level 3 Blas routine.

            //  -- Written on 8-February-1989.
            //     Jack Dongarra, Argonne National Laboratory.
            //     Iain Duff, AERE Harwell.
            //     Jeremy Du Croz, Numerical Algorithms Group Ltd.
            //     Sven Hammarling, Numerical Algorithms Group Ltd.


            //     Set  NOTA  and  NOTB  as  true if  A  and  B  respectively are not
            //     transposed and set  NROWA, NCOLA and  NROWB  as the number of rows
            //     and  columns of  A  and the  number of  rows  of  B  respectively.

            // System generated locals
            int a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, i__1, i__2, i__3;

            // Local variables
            int i, j, l, info;
            bool nota, notb;
            double temp;
            int ncola;
            int nrowa, nrowb;

            // Parameter adjustments
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;
            b_dim1 = *ldb;
            b_offset = 1 + b_dim1;
            b -= b_offset;
            c_dim1 = *ldc;
            c_offset = 1 + c_dim1;
            c -= c_offset;

            // Function Body
            nota = lsame(transa, "N");
            notb = lsame(transb, "N");

            if (nota)
            {
                nrowa = *m;
                ncola = *k;
            }
            else
            {
                nrowa = *k;
                ncola = *m;
            }
            if (notb)
            {
                nrowb = *k;
            }
            else
            {
                nrowb = *n;
            }

            // Test the input parameters.

            info = 0;
            if (!nota && !lsame(transa, "C") && !lsame(transa, "T"))
            {
                info = 1;
            }
            else if (!notb && !lsame(transb, "C") && !lsame(transb, "T"))
            {
                info = 2;
            }
            else if (*m < 0)
            {
                info = 3;
            }
            else if (*n < 0)
            {
                info = 4;
            }
            else if (*k < 0)
            {
                info = 5;
            }
            else if (*lda < Math.Max(1, nrowa))
            {
                info = 8;
            }
            else if (*ldb < Math.Max(1, nrowb))
            {
                info = 10;
            }
            else if (*ldc < Math.Max(1, *m))
            {
                info = 13;
            }

            if (info != 0)
            {
                xerbla("DGEMM ", &info);
                return 0;
            }

            // Quick return if possible.

            if (*m == 0 || *n == 0 || (*alpha == 0.0 || *k == 0) && *beta == 1.0)
            {
                return 0;
            }

            // And if  alpha.eq.zero.

            if (*alpha == 0.0)
            {
                if (*beta == 0.0)
                {
                    i__1 = *n;
                    for (j = 1; j <= i__1; ++j)
                    {
                        i__2 = *m;
                        for (i = 1; i <= i__2; ++i)
                        {
                            c[i + j * c_dim1] = 0.0;
                        }
                    }
                }
                else
                {
                    i__1 = *n;
                    for (j = 1; j <= i__1; ++j)
                    {
                        i__2 = *m;
                        for (i = 1; i <= i__2; ++i)
                        {
                            c[i + j * c_dim1] = *beta * c[i + j * c_dim1];
                        }
                    }
                }
                return 0;
            }

            // Start the operations.

            if (notb)
            {
                if (nota)
                {
                    // Form  C := alpha*A*B + beta*C.

                    i__1 = *n;
                    for (j = 1; j <= i__1; ++j)
                    {
                        if (*beta == 0.0)
                        {
                            i__2 = *m;
                            for (i = 1; i <= i__2; ++i)
                            {
                                c[i + j * c_dim1] = 0.0;
                            }
                        }
                        else if (*beta != 1.0)
                        {
                            i__2 = *m;
                            for (i = 1; i <= i__2; ++i)
                            {
                                c[i + j * c_dim1] = *beta * c[i + j * c_dim1];
                            }
                        }
                        i__2 = *k;
                        for (l = 1; l <= i__2; ++l)
                        {
                            if (b[l + j * b_dim1] != 0.0)
                            {
                                temp = *alpha * b[l + j * b_dim1];
                                i__3 = *m;
                                for (i = 1; i <= i__3; ++i)
                                {
                                    c[i + j * c_dim1] += temp * a[i + l * a_dim1];
                                }
                            }
                        }
                    }
                }
                else
                {
                    // Form  C := alpha*A'*B + beta*C

                    i__1 = *n;
                    for (j = 1; j <= i__1; ++j)
                    {
                        i__2 = *m;
                        for (i = 1; i <= i__2; ++i)
                        {
                            temp = 0.0;
                            i__3 = *k;
                            for (l = 1; l <= i__3; ++l)
                            {
                                temp += a[l + i * a_dim1] * b[l + j * b_dim1];
                            }
                            if (*beta == 0.0)
                            {
                                c[i + j * c_dim1] = *alpha * temp;
                            }
                            else
                            {
                                c[i + j * c_dim1] = *alpha * temp + *beta * c[i + j * c_dim1];
                            }
                        }
                    }
                }
            }
            else
            {
                if (nota)
                {
                    // Form  C := alpha*A*B' + beta*C

                    i__1 = *n;
                    for (j = 1; j <= i__1; ++j)
                    {
                        if (*beta == 0.0)
                        {
                            i__2 = *m;
                            for (i = 1; i <= i__2; ++i)
                            {
                                c[i + j * c_dim1] = 0.0;
                            }
                        }
                        else if (*beta != 1.0)
                        {
                            i__2 = *m;
                            for (i = 1; i <= i__2; ++i)
                            {
                                c[i + j * c_dim1] = *beta * c[i + j * c_dim1];
                            }
                        }
                        i__2 = *k;
                        for (l = 1; l <= i__2; ++l)
                        {
                            if (b[j + l * b_dim1] != 0.0)
                            {
                                temp = *alpha * b[j + l * b_dim1];
                                i__3 = *m;
                                for (i = 1; i <= i__3; ++i)
                                {
                                    c[i + j * c_dim1] += temp * a[i + l * a_dim1];
                                }
                            }
                        }
                    }
                }
                else
                {
                    // Form  C := alpha*A'*B' + beta*C

                    i__1 = *n;
                    for (j = 1; j <= i__1; ++j)
                    {
                        i__2 = *m;
                        for (i = 1; i <= i__2; ++i)
                        {
                            temp = 0.0;
                            i__3 = *k;
                            for (l = 1; l <= i__3; ++l)
                            {
                                temp += a[l + i * a_dim1] * b[j + l * b_dim1];
                            }
                            if (*beta == 0.0)
                            {
                                c[i + j * c_dim1] = *alpha * temp;
                            }
                            else
                            {
                                c[i + j * c_dim1] = *alpha * temp + *beta * c[i + j * c_dim1];
                            }
                        }
                    }
                }
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static double dnrm2(int* n, double* x, int* incx)
        {
            //  Purpose
            //  =======

            //  DNRM2 returns the euclidean norm of a vector via the function
            //  name, so that

            //     DNRM2 := sqrt( x'*x )

            //  -- This version written on 25-October-1982.0
            //     Modified on 14-October-1993 to inline the call to DLASSQ.
            //     Sven Hammarling, Nag Ltd.

            // System generated locals
            int i__1, i__2;
            double ret_val, d__1;

            // Local variables
            int ix;
            double ssq, norm, scale, absxi;

            // Parameter adjustments
            --x;

            // Function Body
            if (*n < 1 || *incx < 1)
            {
                norm = 0.0;
            }
            else if (*n == 1)
            {
                norm = Math.Abs(x[1]);
            }
            else
            {
                scale = 0.0;
                ssq = 1.0;
                // The following loop is equivalent to this call to the LAPACK
                // auxiliary routine:
                // CALL DLASSQ( N, X, INCX, SCALE, SSQ )

                i__1 = (*n - 1) * *incx + 1;
                i__2 = *incx;
                for (ix = 1; i__2 < 0 ? ix >= i__1 : ix <= i__1; ix += i__2)
                {
                    if (x[ix] != 0.0)
                    {
                        absxi = Math.Abs(x[ix]);
                        if (scale < absxi)
                        {
                            // Computing 2nd power
                            d__1 = scale / absxi;
                            ssq = ssq * (d__1 * d__1) + 1.0;
                            scale = absxi;
                        }
                        else
                        {
                            // Computing 2nd power
                            d__1 = absxi / scale;
                            ssq += d__1 * d__1;
                        }
                    }
                }
                norm = scale * Math.Sqrt(ssq);
            }

            ret_val = norm;
            return ret_val;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int drot(int* n, double* dx, int* incx, double* dy, int* incy, double* c, double* s)
        {
            //  Purpose
            //  =======

            //     applies a plane rotation.
            //     jack dongarra, linpack, 3/11/78.0
            //     modified 12/3/93, array(1) declarations changed to array(*)

            // System generated locals
            int i__1;

            // Local variables
            int i, ix, iy;
            double dtemp;

            // Parameter adjustments
            --dy;
            --dx;

            // Function Body
            if (*n <= 0)
            {
                return 0;
            }
            if (*incx == 1 && *incy == 1)
            {
                goto L20;
            }

            // code for unequal increments or equal increments not equal
            // to 1

            ix = 1;
            iy = 1;
            if (*incx < 0)
            {
                ix = (-(*n) + 1) * *incx + 1;
            }

            if (*incy < 0)
            {
                iy = (-(*n) + 1) * *incy + 1;
            }

            i__1 = *n;
            for (i = 1; i <= i__1; ++i)
            {
                dtemp = *c * dx[ix] + *s * dy[iy];
                dy[iy] = *c * dy[iy] - *s * dx[ix];
                dx[ix] = dtemp;
                ix += *incx;
                iy += *incy;
            }
            return 0;

            // code for both increments equal to 1

        L20:
            i__1 = *n;
            for (i = 1; i <= i__1; ++i)
            {
                dtemp = *c * dx[i] + *s * dy[i];
                dy[i] = *c * dy[i] - *s * dx[i];
                dx[i] = dtemp;
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int dscal(int* n, double* da, double* dx, int* incx)
        {
            //  Purpose 
            //  ======= 
            // * 
            //     scales a vector by a constant. 
            //     uses unrolled loops for increment equal to one. 
            //     jack dongarra, linpack, 3/11/78. 
            //     modified 3/93 to return if incx .le. 0. 
            //     modified 12/3/93, array(1) declarations changed to array(*) 

            // System generated locals 
            int i__1, i__2;

            // Local variables 
            int i, m, mp1, nincx;

            // Parameter adjustments 
            --dx;

            // Function Body 
            if (*n <= 0 || *incx <= 0)
            {
                return 0;
            }
            if (*incx == 1)
            {
                goto L20;
            }

            // code for increment not equal to 1 

            nincx = *n * *incx;
            i__1 = nincx;
            i__2 = *incx;

            for (i = 1; i__2 < 0 ? i >= i__1 : i <= i__1; i += i__2)
            {
                dx[i] = *da * dx[i];
            }
            return 0;

            // code for increment equal to 1 


            // clean-up loop 

        L20:
            m = *n % 5;
            if (m == 0)
            {
                goto L40;
            }
            i__2 = m;
            for (i = 1; i <= i__2; ++i)
            {
                dx[i] = *da * dx[i];
            }
            if (*n < 5)
            {
                return 0;
            }
        L40:
            mp1 = m + 1;
            i__2 = *n;

            for (i = mp1; i <= i__2; i += 5)
            {
                dx[i] = *da * dx[i];
                dx[i + 1] = *da * dx[i + 1];
                dx[i + 2] = *da * dx[i + 2];
                dx[i + 3] = *da * dx[i + 3];
                dx[i + 4] = *da * dx[i + 4];
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int dswap(int* n, double* dx, int* incx, double* dy, int* incy)
        {
            //  Purpose
            //  =======

            //     interchanges two vectors.
            //     uses unrolled loops for increments equal one.
            //     jack dongarra, linpack, 3/11/78.
            //     modified 12/3/93, array(1) declarations changed to array(*)

            // System generated locals
            int i__1;

            // Local variables
            int i, m, ix, iy, mp1;
            double dtemp;

            // Parameter adjustments
            --dy;
            --dx;

            // Function Body
            if (*n <= 0)
            {
                return 0;
            }
            if (*incx == 1 && *incy == 1)
            {
                goto L20;
            }

            // code for unequal increments or equal increments not equal
            // to 1

            ix = 1;
            iy = 1;
            if (*incx < 0)
            {
                ix = (-(*n) + 1) * *incx + 1;
            }

            if (*incy < 0)
            {
                iy = (-(*n) + 1) * *incy + 1;
            }

            i__1 = *n;
            for (i = 1; i <= i__1; ++i)
            {
                dtemp = dx[ix];
                dx[ix] = dy[iy];
                dy[iy] = dtemp;
                ix += *incx;
                iy += *incy;
            }

            return 0;

            // code for both increments equal to 1

            // clean-up loop

        L20:
            m = *n % 3;
            if (m == 0)
            {
                goto L40;
            }

            i__1 = m;
            for (i = 1; i <= i__1; ++i)
            {
                dtemp = dx[i];
                dx[i] = dy[i];
                dy[i] = dtemp;
            }

            if (*n < 3)
            {
                return 0;
            }

        L40:
            mp1 = m + 1;
            i__1 = *n;
            for (i = mp1; i <= i__1; i += 3)
            {
                dtemp = dx[i];
                dx[i] = dy[i];
                dy[i] = dtemp;
                dtemp = dx[i + 1];
                dx[i + 1] = dy[i + 1];
                dy[i + 1] = dtemp;
                dtemp = dx[i + 2];
                dx[i + 2] = dy[i + 2];
                dy[i + 2] = dtemp;
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static double dzasum(int* n, complex16* zx, int* incx)
        {
            //  Purpose 
            //  ======= 

            //     takes the sum of the absolute values. 
            //     jack dongarra, 3/11/78. 
            //     modified 3/93 to return if incx .le. 0. 
            //     modified 12/3/93, array(1) declarations changed to array(*) 

            // System generated locals 
            int i__1;
            double ret_val;

            // Local variables 
            int i, ix;
            double stemp;

            // Parameter adjustments 
            --zx;

            // Function Body 
            ret_val = 0.0;
            stemp = 0.0;

            if (*n <= 0 || *incx <= 0)
            {
                return ret_val;
            }
            if (*incx == 1)
            {
                goto L20;
            }

            // code for increment not equal to 1 

            ix = 1;
            i__1 = *n;
            for (i = 1; i <= i__1; ++i)
            {
                stemp += dcabs1(&zx[ix]);
                ix += *incx;
            }

            ret_val = stemp;
            return ret_val;

            // code for increment equal to 1 

            L20:
            i__1 = *n;

            for (i = 1; i <= i__1; ++i)
            {
                stemp += dcabs1(&zx[i]);
            }

            ret_val = stemp;
            return ret_val;
        }

        [SuppressUnmanagedCodeSecurity]
        public static double dznrm2(int* n, complex16* x, int* incx)
        {
            //  Purpose 
            //  ======= 

            //  DZNRM2 returns the euclidean norm of a vector via the function 
            //  name, so that 

            //     DZNRM2 := sqrt( conjg( x' )*x ) 


            //  -- This version written on 25-October-1982. 
            //     Modified on 14-October-1993 to inline the call to ZLASSQ. 
            //     Sven Hammarling, Nag Ltd. 

            // System generated locals 
            int i__1, i__2, i__3;
            double ret_val, d__1;

            // Local variables 
            int ix;
            double ssq, temp, norm, scale;

            // Parameter adjustments 
            --x;

            // Function Body 
            if (*n < 1 || *incx < 1)
            {
                norm = 0.0;
            }
            else
            {
                scale = 0.0;
                ssq = 1.0;

                // The following loop is equivalent to this call to the LAPACK 
                // auxiliary routine: 
                // CALL ZLASSQ( N, X, INCX, SCALE, SSQ ) 

                i__1 = (*n - 1) * *incx + 1;
                i__2 = *incx;

                for (ix = 1; i__2 < 0 ? ix >= i__1 : ix <= i__1; ix += i__2)
                {
                    i__3 = ix;

                    if (x[i__3].r != 0.0)
                    {
                        i__3 = ix;
                        temp = Math.Abs(x[i__3].r);

                        if (scale < temp)
                        {
                            // Computing 2nd power 
                            d__1 = scale / temp;
                            ssq = ssq * (d__1 * d__1) + 1.0;
                            scale = temp;
                        }
                        else
                        {
                            // Computing 2nd power 
                            d__1 = temp / scale;
                            ssq += d__1 * d__1;
                        }
                    }
                    if (d_imag(&x[ix]) != 0.0)
                    {
                        temp = Math.Abs(d_imag(&x[ix]));

                        if (scale < temp)
                        {
                            // Computing 2nd power 
                            d__1 = scale / temp;
                            ssq = ssq * (d__1 * d__1) + 1.0;
                            scale = temp;
                        }
                        else
                        {
                            // Computing 2nd power 
                            d__1 = temp / scale;
                            ssq += d__1 * d__1;
                        }
                    }
                }

                norm = scale * Math.Sqrt(ssq);
            }

            ret_val = norm;
            return ret_val;
        }

        [SuppressUnmanagedCodeSecurity]
        public static double dzsum1(int* n, complex16* cx, int* incx)
        {
            //  -- LAPACK auxiliary routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. 
            //     November 2006 

            //  Purpose 
            //  ======= 

            //  DZSUM1 takes the sum of the absolute values of a complex 
            //  vector and returns a double precision result. 

            //  Based on DZASUM from the Level 1 BLAS. 
            //  The change is to use the 'genuine' absolute value. 

            //  Contributed by Nick Higham for use with ZLACON. 

            //  Arguments 
            //  ========= 

            //  N       (input) int 
            //          The number of elements in the vector CX. 

            //  CX      (input) COMPLEX*16 array, dimension (N) 
            //          The vector whose elements will be summed. 

            //  INCX    (input) int 
            //          The spacing between successive values of CX.  INCX > 0. 

            //  ===================================================================== 

            // System generated locals 
            int i__1, i__2;
            double ret_val;

            // Local variables 
            int i, nincx;
            double stemp;

            // Parameter adjustments 
            --cx;

            // Function Body 
            ret_val = 0.0;
            stemp = 0.0;

            if (*n <= 0)
            {
                return ret_val;
            }

            if (*incx == 1)
            {
                goto L20;
            }

            // CODE FOR INCREMENT NOT EQUAL TO 1 

            nincx = *n * *incx;
            i__1 = nincx;
            i__2 = *incx;

            for (i = 1; i__2 < 0 ? i >= i__1 : i <= i__1; i += i__2)
            {
                // NEXT LINE MODIFIED. 
                stemp += z_abs(&cx[i]);
            }

            ret_val = stemp;
            return ret_val;

            // CODE FOR INCREMENT EQUAL TO 1 

        L20:
            i__2 = *n;
            for (i = 1; i <= i__2; ++i)
            {
                // NEXT LINE MODIFIED. 
                stemp += z_abs(&cx[i]);
            }

            ret_val = stemp;

            return ret_val;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int idamax(int* n, double* dx, int* incx)
        {
            //  Purpose 
            //  ======= 

            //     finds the index of element having max. absolute value. 
            //     jack dongarra, linpack, 3/11/78. 
            //     modified 3/93 to return if incx .le. 0. 
            //     modified 12/3/93, array(1) declarations changed to array(*) 

            // System generated locals 
            int ret_val, i__1;

            // Local variables 
            int i, ix;
            double dmax;

            // Parameter adjustments 
            --dx;

            // Function Body 
            ret_val = 0;

            if (*n < 1 || *incx <= 0)
                return ret_val;

            ret_val = 1;

            if (*n == 1)
                return ret_val;

            if (*incx == 1)
                goto L20;

            // code for increment not equal to 1 

            ix = 1;
            dmax = Math.Abs(dx[1]);
            ix += *incx;
            i__1 = *n;

            for (i = 2; i <= i__1; ++i)
            {
                if (Math.Abs(dx[ix]) <= dmax)
                    goto L5;

                ret_val = i;
                dmax = Math.Abs(dx[ix]);

            L5:
                ix += *incx;
            }
            return ret_val;

            // code for increment equal to 1 

            L20:
            dmax = Math.Abs(dx[1]);
            i__1 = *n;

            for (i = 2; i <= i__1; ++i)
            {
                if (Math.Abs(dx[i]) <= dmax)
                    goto L30;

                ret_val = i;
                dmax = Math.Abs(dx[i]);

            L30:
                ;
            }

            return ret_val;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int izamax(int* n, complex16* zx, int* incx)
        {
            //  Purpose 
            //  ======= 

            //     finds the index of element having max. absolute value. 
            //     jack dongarra, 1/15/85. 
            //     modified 3/93 to return if incx .le. 0. 
            //     modified 12/3/93, array(1) declarations changed to array(*) 

            // System generated locals 
            int ret_val, i__1;

            // Local variables 
            int i, ix;
            double smax;

            // Parameter adjustments 
            --zx;

            // Function Body 
            ret_val = 0;
            if (*n < 1 || *incx <= 0)
            {
                return ret_val;
            }
            ret_val = 1;

            if (*n == 1)
            {
                return ret_val;
            }
            if (*incx == 1)
            {
                goto L20;
            }

            // code for increment not equal to 1 

            ix = 1;
            smax = dcabs1(&zx[1]);
            ix += *incx;
            i__1 = *n;
            for (i = 2; i <= i__1; ++i)
            {
                if (dcabs1(&zx[ix]) <= smax)
                {
                    goto L5;
                }

                ret_val = i;
                smax = dcabs1(&zx[ix]);

            L5:
                ix += *incx;
            }

            return ret_val;

            // code for increment equal to 1 

            L20:
            smax = dcabs1(&zx[1]);
            i__1 = *n;

            for (i = 2; i <= i__1; ++i)
            {
                if (dcabs1(&zx[i]) <= smax)
                {
                    goto L30;
                }

                ret_val = i;
                smax = dcabs1(&zx[i]);

            L30:
                ;
            }

            return ret_val;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int izmax1(int* n, complex16* cx, int* incx)
        {
            //  -- LAPACK auxiliary routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. 
            //     November 2006 

            //  Purpose 
            //  ======= 

            //  IZMAX1 finds the index of the element whose real part has maximum 
            //  absolute value. 

            //  Based on IZAMAX from Level 1 BLAS. 
            //  The change is to use the 'genuine' absolute value. 

            //  Contributed by Nick Higham for use with ZLACON. 

            //  Arguments 
            //  ========= 

            //  N       (input) int 
            //          The number of elements in the vector CX. 

            //  CX      (input) COMPLEX*16 array, dimension (N) 
            //          The vector whose elements will be summed. 

            //  INCX    (input) int 
            //          The spacing between successive values of CX.  INCX >= 1. 

            // ===================================================================== 

            // System generated locals 
            int ret_val, i__1;

            // Local variables 
            int i, ix;
            double smax;

            // Parameter adjustments 
            --cx;

            // Function Body 
            ret_val = 0;
            if (*n < 1)
            {
                return ret_val;
            }

            ret_val = 1;
            if (*n == 1)
            {
                return ret_val;
            }

            if (*incx == 1)
            {
                goto L30;
            }

            // CODE FOR INCREMENT NOT EQUAL TO 1 

            ix = 1;
            smax = z_abs(&cx[1]);
            ix += *incx;
            i__1 = *n;
            for (i = 2; i <= i__1; ++i)
            {
                if (z_abs(&cx[ix]) <= smax)
                {
                    goto L10;
                }

                ret_val = i;
                smax = z_abs(&cx[ix]);

            L10:
                ix += *incx;
            }

            return ret_val;

            // CODE FOR INCREMENT EQUAL TO 1 

        L30:
            smax = z_abs(&cx[1]);
            i__1 = *n;

            for (i = 2; i <= i__1; ++i)
            {
                if (z_abs(&cx[i]) <= smax)
                {
                    goto L40;
                }
                ret_val = i;
                smax = z_abs(&cx[i]);

            L40:
                ;
            }

            return ret_val;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zaxpy(int* n, complex16* za, complex16* zx, int* incx, complex16* zy, int* incy)
        {
            //  Purpose 
            //  ======= 

            //     constant times a vector plus a vector. 
            //     jack dongarra, 3/11/78. 
            //     modified 12/3/93, array(1) declarations changed to array(*) 

            // System generated locals 
            int i__1, i__2, i__3, i__4;
            complex16 z__1, z__2;

            // Local variables 
            int i, ix, iy;

            // Parameter adjustments 
            --zy;
            --zx;

            // Function Body 
            if (*n <= 0)
            {
                return 0;
            }
            if (dcabs1(za) == 0.0)
            {
                return 0;
            }
            if (*incx == 1 && *incy == 1)
            {
                goto L20;
            }

            // code for unequal increments or equal increments 
            // not equal to 1 

            ix = 1;
            iy = 1;
            if (*incx < 0)
            {
                ix = (-(*n) + 1) * *incx + 1;
            }
            if (*incy < 0)
            {
                iy = (-(*n) + 1) * *incy + 1;
            }
            i__1 = *n;
            for (i = 1; i <= i__1; ++i)
            {
                i__2 = iy;
                i__3 = iy;
                i__4 = ix;
                z__2.r = za.r * zx[i__4].r - za.i * zx[i__4].i;
                z__2.i = za.r * zx[i__4].i + za.i * zx[i__4].r;

                z__1.r = zy[i__3].r + z__2.r;
                z__1.i = zy[i__3].i + z__2.i;

                zy[i__2].r = z__1.r;
                zy[i__2].i = z__1.i;
                ix += *incx;
                iy += *incy;
            }
            return 0;

            // code for both increments equal to 1 

            L20:
            i__1 = *n;
            for (i = 1; i <= i__1; ++i)
            {
                i__2 = i;
                i__3 = i;
                i__4 = i;
                z__2.r = za.r * zx[i__4].r - za.i * zx[i__4].i;
                z__2.i = za.r * zx[i__4].i + za.i * zx[i__4].r;

                z__1.r = zy[i__3].r + z__2.r;
                z__1.i = zy[i__3].i + z__2.i;

                zy[i__2].r = z__1.r;
                zy[i__2].i = z__1.i;
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zcopy(int* n, complex16* zx, int* incx, complex16* zy, int* incy)
        {
            //  Purpose 
            //  ======= 

            //     copies a vector, x, to a vector, y. 
            //     jack dongarra, linpack, 4/11/78. 
            //     modified 12/3/93, array(1) declarations changed to array(*) 

            // System generated locals 
            int i__1, i__2, i__3;

            // Local variables 
            int i, ix, iy;

            // Parameter adjustments 
            --zy;
            --zx;

            // Function Body 
            if (*n <= 0)
            {
                return 0;
            }

            if (*incx == 1 && *incy == 1)
            {
                goto L20;
            }

            // code for unequal increments or equal increments 
            // not equal to 1 

            ix = 1;
            iy = 1;

            if (*incx < 0)
            {
                ix = (-(*n) + 1) * *incx + 1;
            }

            if (*incy < 0)
            {
                iy = (-(*n) + 1) * *incy + 1;
            }

            i__1 = *n;

            for (i = 1; i <= i__1; ++i)
            {
                i__2 = iy;
                i__3 = ix;

                zy[i__2].r = zx[i__3].r;
                zy[i__2].i = zx[i__3].i;

                ix += *incx;
                iy += *incy;
            }

            return 0;

            // code for both increments equal to 1 

            L20:
            i__1 = *n;

            for (i = 1; i <= i__1; ++i)
            {
                i__2 = i;
                i__3 = i;

                zy[i__2].r = zx[i__3].r;
                zy[i__2].i = zx[i__3].i;
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static void zdotc(complex16* ret_val, int* n, complex16* zx, int* incx, complex16* zy, int* incy)
        {
            //  Purpose 
            //  ======= 

            //  ZDOTC forms the dot product of a vector. 

            //  Further Details 
            //  =============== 

            //     jack dongarra, 3/11/78. 
            //     modified 12/3/93, array(1) declarations changed to array(*) 

            // System generated locals 
            int i__1, i__2;
            complex16 z__1, z__2, z__3;

            // Local variables 
            int i, ix, iy;
            complex16 ztemp;

            // Parameter adjustments 
            --zy;
            --zx;

            // Function Body 
            ztemp.r = 0.0;
            ztemp.i = 0.0;
            ret_val.r = 0.0;
            ret_val.i = 0.0;

            if (*n <= 0)
            {
                return;
            }
            if (*incx == 1 && *incy == 1)
            {
                goto L20;
            }

            // code for unequal increments or equal increments 
            // not equal to 1 

            ix = 1;
            iy = 1;
            if (*incx < 0)
            {
                ix = (-(*n) + 1) * *incx + 1;
            }
            if (*incy < 0)
            {
                iy = (-(*n) + 1) * *incy + 1;
            }
            i__1 = *n;

            for (i = 1; i <= i__1; ++i)
            {
                d_cnjg(&z__3, &zx[ix]);
                i__2 = iy;

                z__2.r = z__3.r * zy[i__2].r - z__3.i * zy[i__2].i;
                z__2.i = z__3.r * zy[i__2].i + z__3.i * zy[i__2].r;

                z__1.r = ztemp.r + z__2.r;
                z__1.i = ztemp.i + z__2.i;

                ztemp.r = z__1.r;
                ztemp.i = z__1.i;

                ix += *incx;
                iy += *incy;
            }

            ret_val.r = ztemp.r;
            ret_val.i = ztemp.i;
            return;

            // code for both increments equal to 1 

        L20:
            i__1 = *n;
            for (i = 1; i <= i__1; ++i)
            {
                d_cnjg(&z__3, &zx[i]);
                i__2 = i;

                z__2.r = z__3.r * zy[i__2].r - z__3.i * zy[i__2].i;
                z__2.i = z__3.r * zy[i__2].i + z__3.i * zy[i__2].r;

                z__1.r = ztemp.r + z__2.r;
                z__1.i = ztemp.i + z__2.i;

                ztemp.r = z__1.r;
                ztemp.i = z__1.i;
            }

            ret_val.r = ztemp.r;
            ret_val.i = ztemp.i;

            return;
        }

        [SuppressUnmanagedCodeSecurity]
        public static void zdotu(complex16* ret_val, int* n, complex16* zx, int* incx, complex16* zy, int* incy)
        {
            //  Purpose 
            //  ======= 

            //     ZDOTU forms the dot product of two vectors. 

            //  Further Details 
            //  =============== 

            //     jack dongarra, 3/11/78. 
            //     modified 12/3/93, array(1) declarations changed to array(*) 

            // System generated locals 
            int i__1, i__2, i__3;
            complex16 z__1, z__2;

            // Local variables 
            int i, ix, iy;
            complex16 ztemp;

            // Parameter adjustments 
            --zy;
            --zx;

            // Function Body 
            ztemp.r = 0.0;
            ztemp.i = 0.0;
            ret_val.r = 0.0;
            ret_val.i = 0.0;

            if (*n <= 0)
            {
                return;
            }
            if (*incx == 1 && *incy == 1)
            {
                goto L20;
            }

            // code for unequal increments or equal increments 
            // not equal to 1 

            ix = 1;
            iy = 1;
            if (*incx < 0)
            {
                ix = (-(*n) + 1) * *incx + 1;
            }
            if (*incy < 0)
            {
                iy = (-(*n) + 1) * *incy + 1;
            }
            i__1 = *n;

            for (i = 1; i <= i__1; ++i)
            {
                i__2 = ix;
                i__3 = iy;

                z__2.r = zx[i__2].r * zy[i__3].r - zx[i__2].i * zy[i__3].i;
                z__2.i = zx[i__2].r * zy[i__3].i + zx[i__2].i * zy[i__3].r;

                z__1.r = ztemp.r + z__2.r;
                z__1.i = ztemp.i + z__2.i;

                ztemp.r = z__1.r;
                ztemp.i = z__1.i;

                ix += *incx;
                iy += *incy;
            }

            ret_val.r = ztemp.r;
            ret_val.i = ztemp.i;
            return;

            // code for both increments equal to 1 

        L20:
            i__1 = *n;
            for (i = 1; i <= i__1; ++i)
            {
                i__2 = i;
                i__3 = i;

                z__2.r = zx[i__2].r * zy[i__3].r - zx[i__2].i * zy[i__3].i;
                z__2.i = zx[i__2].r * zy[i__3].i + zx[i__2].i * zy[i__3].r;

                z__1.r = ztemp.r + z__2.r;
                z__1.i = ztemp.i + z__2.i;

                ztemp.r = z__1.r;
                ztemp.i = z__1.i;
            }

            ret_val.r = ztemp.r;
            ret_val.i = ztemp.i;

            return;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zdscal(int* n, double* da, complex16* zx, int* incx)
        {
            //  Purpose 
            //  ======= 

            //     scales a vector by a constant. 
            //     jack dongarra, 3/11/78. 
            //     modified 3/93 to return if incx .le. 0. 
            //     modified 12/3/93, array(1) declarations changed to array(*) 

            // System generated locals 
            int i__1, i__2, i__3;
            complex16 z__1, z__2;

            // Local variables 
            int i, ix;

            // Parameter adjustments 
            --zx;

            // Function Body 
            if (*n <= 0 || *incx <= 0)
            {
                return 0;
            }

            if (*incx == 1)
            {
                goto L20;
            }

            // code for increment not equal to 1 

            ix = 1;
            i__1 = *n;
            for (i = 1; i <= i__1; ++i)
            {
                i__2 = ix;
                z__2.r = *da;
                z__2.i = 0.0;

                i__3 = ix;
                z__1.r = z__2.r * zx[i__3].r - z__2.i * zx[i__3].i;
                z__1.i = z__2.r * zx[i__3].i + z__2.i * zx[i__3].r;

                zx[i__2].r = z__1.r;
                zx[i__2].i = z__1.i;
                ix += *incx;
            }
            return 0;

            // code for increment equal to 1 

            L20:
            i__1 = *n;
            for (i = 1; i <= i__1; ++i)
            {
                i__2 = i;
                z__2.r = *da;
                z__2.i = 0.0;

                i__3 = i;
                z__1.r = z__2.r * zx[i__3].r - z__2.i * zx[i__3].i;
                z__1.i = z__2.r * zx[i__3].i + z__2.i * zx[i__3].r;

                zx[i__2].r = z__1.r;
                zx[i__2].i = z__1.i;
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zgemm(string transa, string transb, int* m, int* n, int* k,
            complex16* alpha, complex16* a, int* lda, complex16* b,
            int* ldb, complex16* beta, complex16* c, int* ldc)
        {
            //  Purpose 
            //  ======= 

            //  ZGEMM  performs one of the matrix-matrix operations 

            //     C := alpha*op( A )*op( B ) + beta*C, 

            //  where  op( X ) is one of 

            //     op( X ) = X   or   op( X ) = X'   or   op( X ) = conjg( X' ), 

            //  alpha and beta are scalars, and A, B and C are matrices, with op( A ) 
            //  an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix. 

            //  Arguments 
            //  ========== 

            //  TRANSA - CHARACTER*1. 
            //           On entry, TRANSA specifies the form of op( A ) to be used in 
            //           the matrix multiplication as follows: 

            //              TRANSA = 'N' or 'n',  op( A ) = A. 

            //              TRANSA = 'T' or 't',  op( A ) = A'. 

            //              TRANSA = 'C' or 'c',  op( A ) = conjg( A' ). 

            //           Unchanged on exit. 

            //  TRANSB - CHARACTER*1. 
            //           On entry, TRANSB specifies the form of op( B ) to be used in 
            //           the matrix multiplication as follows: 

            //              TRANSB = 'N' or 'n',  op( B ) = B. 

            //              TRANSB = 'T' or 't',  op( B ) = B'. 

            //              TRANSB = 'C' or 'c',  op( B ) = conjg( B' ). 

            //           Unchanged on exit. 

            //  M      - int. 
            //           On entry,  M  specifies  the number  of rows  of the  matrix 
            //           op( A )  and of the  matrix  C.  M  must  be at least  zero. 
            //           Unchanged on exit. 

            //  N      - int. 
            //           On entry,  N  specifies the number  of columns of the matrix 
            //           op( B ) and the number of columns of the matrix C. N must be 
            //           at least zero. 
            //           Unchanged on exit. 

            //  K      - int. 
            //           On entry,  K  specifies  the number of columns of the matrix 
            //           op( A ) and the number of rows of the matrix op( B ). K must 
            //           be at least  zero. 
            //           Unchanged on exit. 

            //  ALPHA  - COMPLEX*16      . 
            //           On entry, ALPHA specifies the scalar alpha. 
            //           Unchanged on exit. 

            //  A      - COMPLEX*16       array of DIMENSION ( LDA, ka ), where ka is 
            //           k  when  TRANSA = 'N' or 'n',  and is  m  otherwise. 
            //           Before entry with  TRANSA = 'N' or 'n',  the leading  m by k 
            //           part of the array  A  must contain the matrix  A,  otherwise 
            //           the leading  k by m  part of the array  A  must contain  the 
            //           matrix A. 
            //           Unchanged on exit. 

            //  LDA    - int. 
            //           On entry, LDA specifies the first dimension of A as declared 
            //           in the calling (sub) program. When  TRANSA = 'N' or 'n' then 
            //           LDA must be at least  max( 1, m ), otherwise  LDA must be at 
            //           least  max( 1, k ). 
            //           Unchanged on exit. 

            //  B      - COMPLEX*16       array of DIMENSION ( LDB, kb ), where kb is 
            //           n  when  TRANSB = 'N' or 'n',  and is  k  otherwise. 
            //           Before entry with  TRANSB = 'N' or 'n',  the leading  k by n 
            //           part of the array  B  must contain the matrix  B,  otherwise 
            //           the leading  n by k  part of the array  B  must contain  the 
            //           matrix B. 
            //           Unchanged on exit. 

            //  LDB    - int. 
            //           On entry, LDB specifies the first dimension of B as declared 
            //           in the calling (sub) program. When  TRANSB = 'N' or 'n' then 
            //           LDB must be at least  max( 1, k ), otherwise  LDB must be at 
            //           least  max( 1, n ). 
            //           Unchanged on exit. 

            //  BETA   - COMPLEX*16      . 
            //           On entry,  BETA  specifies the scalar  beta.  When  BETA  is 
            //           supplied as zero then C need not be set on input. 
            //           Unchanged on exit. 

            //  C      - COMPLEX*16       array of DIMENSION ( LDC, n ). 
            //           Before entry, the leading  m by n  part of the array  C must 
            //           contain the matrix  C,  except when  beta  is zero, in which 
            //           case C need not be set on entry. 
            //           On exit, the array  C  is overwritten by the  m by n  matrix 
            //           ( alpha*op( A )*op( B ) + beta*C ). 

            //  LDC    - int. 
            //           On entry, LDC specifies the first dimension of C as declared 
            //           in  the  calling  (sub)  program.   LDC  must  be  at  least 
            //           max( 1, m ). 
            //           Unchanged on exit. 


            //  Level 3 Blas routine. 

            //  -- Written on 8-February-1989. 
            //     Jack Dongarra, Argonne National Laboratory. 
            //     Iain Duff, AERE Harwell. 
            //     Jeremy Du Croz, Numerical Algorithms Group Ltd. 
            //     Sven Hammarling, Numerical Algorithms Group Ltd. 

            //     Set  NOTA  and  NOTB  as  true if  A  and  B  respectively are not 
            //     conjugated or transposed, set  CONJA and CONJB  as true if  A  and 
            //     B  respectively are to be  transposed but  not conjugated  and set 
            //     NROWA, NCOLA and  NROWB  as the number of rows and  columns  of  A 
            //     and the number of rows of  B  respectively. 

            // System generated locals 
            int a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, i__1, i__2, i__3, i__4, i__5, i__6;
            complex16 z__1, z__2, z__3, z__4;

            // Local variables 
            int i, j, l, info;
            bool nota, notb;
            complex16 temp;
            bool conja, conjb;
            int ncola;
            int nrowa, nrowb;

            // Parameter adjustments 
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;
            b_dim1 = *ldb;
            b_offset = 1 + b_dim1;
            b -= b_offset;
            c_dim1 = *ldc;
            c_offset = 1 + c_dim1;
            c -= c_offset;

            // Function Body 
            nota = lsame(transa, "N");
            notb = lsame(transb, "N");
            conja = lsame(transa, "C");
            conjb = lsame(transb, "C");

            if (nota)
            {
                nrowa = *m;
                ncola = *k;
            }
            else
            {
                nrowa = *k;
                ncola = *m;
            }

            if (notb)
            {
                nrowb = *k;
            }
            else
            {
                nrowb = *n;
            }

            // Test the input parameters. 

            info = 0;
            if (!nota && !conja && !lsame(transa, "T"))
            {
                info = 1;
            }
            else if (!notb && !conjb && !lsame(transb, "T"))
            {
                info = 2;
            }
            else if (*m < 0)
            {
                info = 3;
            }
            else if (*n < 0)
            {
                info = 4;
            }
            else if (*k < 0)
            {
                info = 5;
            }
            else if (*lda < Math.Max(1, nrowa))
            {
                info = 8;
            }
            else if (*ldb < Math.Max(1, nrowb))
            {
                info = 10;
            }
            else if (*ldc < Math.Max(1, *m))
            {
                info = 13;
            }

            if (info != 0)
            {
                xerbla("ZGEMM ", &info);
                return 0;
            }

            // Quick return if possible. 

            if (*m == 0 || *n == 0 || (alpha.r == 0.0 && alpha.i == 0.0 || *k == 0) && (beta.r == 1.0 && beta.i == 0.0))
            {
                return 0;
            }

            // And when  alpha.eq.zero. 

            if (alpha.r == 0.0 && alpha.i == 0.0)
            {
                if (beta.r == 0.0 && beta.i == 0.0)
                {
                    i__1 = *n;
                    for (j = 1; j <= i__1; ++j)
                    {
                        i__2 = *m;
                        for (i = 1; i <= i__2; ++i)
                        {
                            i__3 = i + j * c_dim1;

                            c[i__3].r = 0.0;
                            c[i__3].i = 0.0;
                        }
                    }
                }
                else
                {
                    i__1 = *n;
                    for (j = 1; j <= i__1; ++j)
                    {
                        i__2 = *m;
                        for (i = 1; i <= i__2; ++i)
                        {
                            i__3 = i + j * c_dim1;
                            i__4 = i + j * c_dim1;

                            z__1.r = beta.r * c[i__4].r - beta.i * c[i__4].i;
                            z__1.i = beta.r * c[i__4].i + beta.i * c[i__4].r;

                            c[i__3].r = z__1.r;
                            c[i__3].i = z__1.i;
                        }
                    }
                }
                return 0;
            }

            // Start the operations. 

            if (notb)
            {
                if (nota)
                {
                    // Form  C := alpha*A*B + beta*C. 
                    i__1 = *n;

                    for (j = 1; j <= i__1; ++j)
                    {
                        if (beta.r == 0.0 && beta.i == 0.0)
                        {
                            i__2 = *m;
                            for (i = 1; i <= i__2; ++i)
                            {
                                i__3 = i + j * c_dim1;

                                c[i__3].r = 0.0;
                                c[i__3].i = 0.0;
                            }
                        }
                        else if (beta.r != 1.0 || beta.i != 0.0)
                        {
                            i__2 = *m;
                            for (i = 1; i <= i__2; ++i)
                            {
                                i__3 = i + j * c_dim1;
                                i__4 = i + j * c_dim1;

                                z__1.r = beta.r * c[i__4].r - beta.i * c[i__4].i;
                                z__1.i = beta.r * c[i__4].i + beta.i * c[i__4].r;

                                c[i__3].r = z__1.r;
                                c[i__3].i = z__1.i;
                            }
                        }
                        i__2 = *k;
                        for (l = 1; l <= i__2; ++l)
                        {
                            i__3 = l + j * b_dim1;

                            if (b[i__3].r != 0.0 || b[i__3].i != 0.0)
                            {
                                i__3 = l + j * b_dim1;

                                z__1.r = alpha.r * b[i__3].r - alpha.i * b[i__3].i;
                                z__1.i = alpha.r * b[i__3].i + alpha.i * b[i__3].r;

                                temp.r = z__1.r;
                                temp.i = z__1.i;

                                i__3 = *m;

                                for (i = 1; i <= i__3; ++i)
                                {
                                    i__4 = i + j * c_dim1;
                                    i__5 = i + j * c_dim1;
                                    i__6 = i + l * a_dim1;

                                    z__2.r = temp.r * a[i__6].r - temp.i * a[i__6].i;
                                    z__2.i = temp.r * a[i__6].i + temp.i * a[i__6].r;

                                    z__1.r = c[i__5].r + z__2.r;
                                    z__1.i = c[i__5].i + z__2.i;

                                    c[i__4].r = z__1.r;
                                    c[i__4].i = z__1.i;
                                }
                            }
                        }
                    }
                }
                else if (conja)
                {
                    // Form  C := alpha*conjg( A' )*B + beta*C. 

                    i__1 = *n;
                    for (j = 1; j <= i__1; ++j)
                    {
                        i__2 = *m;
                        for (i = 1; i <= i__2; ++i)
                        {
                            temp.r = 0.0;
                            temp.i = 0.0;
                            i__3 = *k;

                            for (l = 1; l <= i__3; ++l)
                            {
                                d_cnjg(&z__3, &a[l + i * a_dim1]);
                                i__4 = l + j * b_dim1;

                                z__2.r = z__3.r * b[i__4].r - z__3.i * b[i__4].i;
                                z__2.i = z__3.r * b[i__4].i + z__3.i * b[i__4].r;

                                z__1.r = temp.r + z__2.r;
                                z__1.i = temp.i + z__2.i;

                                temp.r = z__1.r;
                                temp.i = z__1.i;
                            }

                            if (beta.r == 0.0 && beta.i == 0.0)
                            {
                                i__3 = i + j * c_dim1;

                                z__1.r = alpha.r * temp.r - alpha.i * temp.i;
                                z__1.i = alpha.r * temp.i + alpha.i * temp.r;

                                c[i__3].r = z__1.r;
                                c[i__3].i = z__1.i;
                            }
                            else
                            {
                                i__3 = i + j * c_dim1;

                                z__2.r = alpha.r * temp.r - alpha.i * temp.i;
                                z__2.i = alpha.r * temp.i + alpha.i * temp.r;

                                i__4 = i + j * c_dim1;

                                z__3.r = beta.r * c[i__4].r - beta.i * c[i__4].i;
                                z__3.i = beta.r * c[i__4].i + beta.i * c[i__4].r;

                                z__1.r = z__2.r + z__3.r;
                                z__1.i = z__2.i + z__3.i;

                                c[i__3].r = z__1.r;
                                c[i__3].i = z__1.i;
                            }
                        }
                    }
                }
                else
                {
                    // Form  C := alpha*A'*B + beta*C 
                    i__1 = *n;
                    for (j = 1; j <= i__1; ++j)
                    {
                        i__2 = *m;
                        for (i = 1; i <= i__2; ++i)
                        {
                            temp.r = 0.0;
                            temp.i = 0.0;
                            i__3 = *k;

                            for (l = 1; l <= i__3; ++l)
                            {
                                i__4 = l + i * a_dim1;
                                i__5 = l + j * b_dim1;

                                z__2.r = a[i__4].r * b[i__5].r - a[i__4].i * b[i__5].i;
                                z__2.i = a[i__4].r * b[i__5].i + a[i__4].i * b[i__5].r;

                                z__1.r = temp.r + z__2.r;
                                z__1.i = temp.i + z__2.i;

                                temp.r = z__1.r;
                                temp.i = z__1.i;
                            }
                            if (beta.r == 0.0 && beta.i == 0.0)
                            {
                                i__3 = i + j * c_dim1;

                                z__1.r = alpha.r * temp.r - alpha.i * temp.i;
                                z__1.i = alpha.r * temp.i + alpha.i * temp.r;

                                c[i__3].r = z__1.r;
                                c[i__3].i = z__1.i;
                            }
                            else
                            {
                                i__3 = i + j * c_dim1;
                                z__2.r = alpha.r * temp.r - alpha.i * temp.i;
                                z__2.i = alpha.r * temp.i + alpha.i * temp.r;

                                i__4 = i + j * c_dim1;
                                z__3.r = beta.r * c[i__4].r - beta.i * c[i__4].i;
                                z__3.i = beta.r * c[i__4].i + beta.i * c[i__4].r;

                                z__1.r = z__2.r + z__3.r;
                                z__1.i = z__2.i + z__3.i;

                                c[i__3].r = z__1.r;
                                c[i__3].i = z__1.i;
                            }
                        }
                    }
                }
            }
            else if (nota)
            {
                if (conjb)
                {
                    // Form  C := alpha*A*conjg( B' ) + beta*C. 
                    i__1 = *n;
                    for (j = 1; j <= i__1; ++j)
                    {
                        if (beta.r == 0.0 && beta.i == 0.0)
                        {
                            i__2 = *m;
                            for (i = 1; i <= i__2; ++i)
                            {
                                i__3 = i + j * c_dim1;
                                c[i__3].r = 0.0;
                                c[i__3].i = 0.0;
                            }
                        }
                        else if (beta.r != 1.0 || beta.i != 0.0)
                        {
                            i__2 = *m;
                            for (i = 1; i <= i__2; ++i)
                            {
                                i__3 = i + j * c_dim1;
                                i__4 = i + j * c_dim1;

                                z__1.r = beta.r * c[i__4].r - beta.i * c[i__4].i;
                                z__1.i = beta.r * c[i__4].i + beta.i * c[i__4].r;

                                c[i__3].r = z__1.r;
                                c[i__3].i = z__1.i;
                            }
                        }
                        i__2 = *k;
                        for (l = 1; l <= i__2; ++l)
                        {
                            i__3 = j + l * b_dim1;
                            if (b[i__3].r != 0.0 || b[i__3].i != 0.0)
                            {
                                d_cnjg(&z__2, &b[j + l * b_dim1]);

                                z__1.r = alpha.r * z__2.r - alpha.i * z__2.i;
                                z__1.i = alpha.r * z__2.i + alpha.i * z__2.r;

                                temp.r = z__1.r;
                                temp.i = z__1.i;

                                i__3 = *m;
                                for (i = 1; i <= i__3; ++i)
                                {
                                    i__4 = i + j * c_dim1;
                                    i__5 = i + j * c_dim1;
                                    i__6 = i + l * a_dim1;

                                    z__2.r = temp.r * a[i__6].r - temp.i * a[i__6].i;
                                    z__2.i = temp.r * a[i__6].i + temp.i * a[i__6].r;

                                    z__1.r = c[i__5].r + z__2.r;
                                    z__1.i = c[i__5].i + z__2.i;

                                    c[i__4].r = z__1.r;
                                    c[i__4].i = z__1.i;
                                }
                            }
                        }
                    }
                }
                else
                {
                    // Form  C := alpha*A*B'          + beta*C 
                    i__1 = *n;
                    for (j = 1; j <= i__1; ++j)
                    {
                        if (beta.r == 0.0 && beta.i == 0.0)
                        {
                            i__2 = *m;
                            for (i = 1; i <= i__2; ++i)
                            {
                                i__3 = i + j * c_dim1;
                                c[i__3].r = 0.0;
                                c[i__3].i = 0.0;
                            }
                        }
                        else if (beta.r != 1.0 || beta.i != 0.0)
                        {
                            i__2 = *m;
                            for (i = 1; i <= i__2; ++i)
                            {
                                i__3 = i + j * c_dim1;
                                i__4 = i + j * c_dim1;

                                z__1.r = beta.r * c[i__4].r - beta.i * c[i__4].i;
                                z__1.i = beta.r * c[i__4].i + beta.i * c[i__4].r;

                                c[i__3].r = z__1.r;
                                c[i__3].i = z__1.i;
                            }
                        }

                        i__2 = *k;
                        for (l = 1; l <= i__2; ++l)
                        {
                            i__3 = j + l * b_dim1;
                            if (b[i__3].r != 0.0 || b[i__3].i != 0.0)
                            {
                                i__3 = j + l * b_dim1;

                                z__1.r = alpha.r * b[i__3].r - alpha.i * b[i__3].i;
                                z__1.i = alpha.r * b[i__3].i + alpha.i * b[i__3].r;

                                temp.r = z__1.r;
                                temp.i = z__1.i;

                                i__3 = *m;
                                for (i = 1; i <= i__3; ++i)
                                {
                                    i__4 = i + j * c_dim1;
                                    i__5 = i + j * c_dim1;
                                    i__6 = i + l * a_dim1;

                                    z__2.r = temp.r * a[i__6].r - temp.i * a[i__6].i;
                                    z__2.i = temp.r * a[i__6].i + temp.i * a[i__6].r;

                                    z__1.r = c[i__5].r + z__2.r;
                                    z__1.i = c[i__5].i + z__2.i;

                                    c[i__4].r = z__1.r;
                                    c[i__4].i = z__1.i;
                                }
                            }
                        }
                    }
                }
            }
            else if (conja)
            {
                if (conjb)
                {
                    // Form  C := alpha*conjg( A' )*conjg( B' ) + beta*C. 
                    i__1 = *n;
                    for (j = 1; j <= i__1; ++j)
                    {
                        i__2 = *m;
                        for (i = 1; i <= i__2; ++i)
                        {
                            temp.r = 0.0;
                            temp.i = 0.0;
                            i__3 = *k;

                            for (l = 1; l <= i__3; ++l)
                            {
                                d_cnjg(&z__3, &a[l + i * a_dim1]);
                                d_cnjg(&z__4, &b[j + l * b_dim1]);

                                z__2.r = z__3.r * z__4.r - z__3.i * z__4.i;
                                z__2.i = z__3.r * z__4.i + z__3.i * z__4.r;

                                z__1.r = temp.r + z__2.r;
                                z__1.i = temp.i + z__2.i;

                                temp.r = z__1.r;
                                temp.i = z__1.i;
                            }
                            if (beta.r == 0.0 && beta.i == 0.0)
                            {
                                i__3 = i + j * c_dim1;

                                z__1.r = alpha.r * temp.r - alpha.i * temp.i;
                                z__1.i = alpha.r * temp.i + alpha.i * temp.r;

                                c[i__3].r = z__1.r;
                                c[i__3].i = z__1.i;
                            }
                            else
                            {
                                i__3 = i + j * c_dim1;
                                z__2.r = alpha.r * temp.r - alpha.i * temp.i;
                                z__2.i = alpha.r * temp.i + alpha.i * temp.r;

                                i__4 = i + j * c_dim1;
                                z__3.r = beta.r * c[i__4].r - beta.i * c[i__4].i;
                                z__3.i = beta.r * c[i__4].i + beta.i * c[i__4].r;

                                z__1.r = z__2.r + z__3.r;
                                z__1.i = z__2.i + z__3.i;

                                c[i__3].r = z__1.r;
                                c[i__3].i = z__1.i;
                            }
                        }
                    }
                }
                else
                {
                    // Form  C := alpha*conjg( A' )*B' + beta*C 
                    i__1 = *n;
                    for (j = 1; j <= i__1; ++j)
                    {
                        i__2 = *m;
                        for (i = 1; i <= i__2; ++i)
                        {
                            temp.r = 0.0;
                            temp.i = 0.0;
                            i__3 = *k;

                            for (l = 1; l <= i__3; ++l)
                            {
                                d_cnjg(&z__3, &a[l + i * a_dim1]);
                                i__4 = j + l * b_dim1;

                                z__2.r = z__3.r * b[i__4].r - z__3.i * b[i__4].i;
                                z__2.i = z__3.r * b[i__4].i + z__3.i * b[i__4].r;

                                z__1.r = temp.r + z__2.r;
                                z__1.i = temp.i + z__2.i;

                                temp.r = z__1.r;
                                temp.i = z__1.i;
                            }
                            if (beta.r == 0.0 && beta.i == 0.0)
                            {
                                i__3 = i + j * c_dim1;

                                z__1.r = alpha.r * temp.r - alpha.i * temp.i;
                                z__1.i = alpha.r * temp.i + alpha.i * temp.r;

                                c[i__3].r = z__1.r;
                                c[i__3].i = z__1.i;
                            }
                            else
                            {
                                i__3 = i + j * c_dim1;
                                z__2.r = alpha.r * temp.r - alpha.i * temp.i;
                                z__2.i = alpha.r * temp.i + alpha.i * temp.r;
                                i__4 = i + j * c_dim1;

                                z__3.r = beta.r * c[i__4].r - beta.i * c[i__4].i;
                                z__3.i = beta.r * c[i__4].i + beta.i * c[i__4].r;

                                z__1.r = z__2.r + z__3.r;
                                z__1.i = z__2.i + z__3.i;

                                c[i__3].r = z__1.r;
                                c[i__3].i = z__1.i;
                            }
                        }
                    }
                }
            }
            else
            {
                if (conjb)
                {
                    // Form  C := alpha*A'*conjg( B' ) + beta*C 
                    i__1 = *n;
                    for (j = 1; j <= i__1; ++j)
                    {
                        i__2 = *m;
                        for (i = 1; i <= i__2; ++i)
                        {
                            temp.r = 0.0;
                            temp.i = 0.0;
                            i__3 = *k;

                            for (l = 1; l <= i__3; ++l)
                            {
                                i__4 = l + i * a_dim1;
                                d_cnjg(&z__3, &b[j + l * b_dim1]);

                                z__2.r = a[i__4].r * z__3.r - a[i__4].i * z__3.i;
                                z__2.i = a[i__4].r * z__3.i + a[i__4].i * z__3.r;

                                z__1.r = temp.r + z__2.r;
                                z__1.i = temp.i + z__2.i;

                                temp.r = z__1.r;
                                temp.i = z__1.i;
                            }
                            if (beta.r == 0.0 && beta.i == 0.0)
                            {
                                i__3 = i + j * c_dim1;

                                z__1.r = alpha.r * temp.r - alpha.i * temp.i;
                                z__1.i = alpha.r * temp.i + alpha.i * temp.r;

                                c[i__3].r = z__1.r;
                                c[i__3].i = z__1.i;
                            }
                            else
                            {
                                i__3 = i + j * c_dim1;

                                z__2.r = alpha.r * temp.r - alpha.i * temp.i;
                                z__2.i = alpha.r * temp.i + alpha.i * temp.r;

                                i__4 = i + j * c_dim1;
                                z__3.r = beta.r * c[i__4].r - beta.i * c[i__4].i;
                                z__3.i = beta.r * c[i__4].i + beta.i * c[i__4].r;

                                z__1.r = z__2.r + z__3.r;
                                z__1.i = z__2.i + z__3.i;

                                c[i__3].r = z__1.r;
                                c[i__3].i = z__1.i;
                            }
                        }
                    }
                }
                else
                {
                    // Form  C := alpha*A'*B' + beta*C 
                    i__1 = *n;
                    for (j = 1; j <= i__1; ++j)
                    {
                        i__2 = *m;
                        for (i = 1; i <= i__2; ++i)
                        {
                            temp.r = 0.0;
                            temp.i = 0.0;
                            i__3 = *k;

                            for (l = 1; l <= i__3; ++l)
                            {
                                i__4 = l + i * a_dim1;
                                i__5 = j + l * b_dim1;

                                z__2.r = a[i__4].r * b[i__5].r - a[i__4].i * b[i__5].i;
                                z__2.i = a[i__4].r * b[i__5].i + a[i__4].i * b[i__5].r;

                                z__1.r = temp.r + z__2.r;
                                z__1.i = temp.i + z__2.i;

                                temp.r = z__1.r;
                                temp.i = z__1.i;
                            }

                            if (beta.r == 0.0 && beta.i == 0.0)
                            {
                                i__3 = i + j * c_dim1;

                                z__1.r = alpha.r * temp.r - alpha.i * temp.i;
                                z__1.i = alpha.r * temp.i + alpha.i * temp.r;

                                c[i__3].r = z__1.r;
                                c[i__3].i = z__1.i;
                            }
                            else
                            {
                                i__3 = i + j * c_dim1;

                                z__2.r = alpha.r * temp.r - alpha.i * temp.i;
                                z__2.i = alpha.r * temp.i + alpha.i * temp.r;
                                i__4 = i + j * c_dim1;

                                z__3.r = beta.r * c[i__4].r - beta.i * c[i__4].i;
                                z__3.i = beta.r * c[i__4].i + beta.i * c[i__4].r;

                                z__1.r = z__2.r + z__3.r;
                                z__1.i = z__2.i + z__3.i;

                                c[i__3].r = z__1.r;
                                c[i__3].i = z__1.i;
                            }
                        }
                    }
                }
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zgemv(string trans, int* m, int* n, complex16* alpha,
            complex16* a, int* lda, complex16* x, int* incx,
            complex16* beta, complex16* y, int* incy)
        {
            //  Purpose 
            //  ======= 

            //  ZGEMV  performs one of the matrix-vector operations 

            //     y := alpha*A*x + beta*y,   or   y := alpha*A'*x + beta*y,   or 

            //     y := alpha*conjg( A' )*x + beta*y, 

            //  where alpha and beta are scalars, x and y are vectors and A is an 
            //  m by n matrix. 

            //  Arguments 
            //  ========== 

            //  TRANS  - CHARACTER*1. 
            //           On entry, TRANS specifies the operation to be performed as 
            //           follows: 

            //              TRANS = 'N' or 'n'   y := alpha*A*x + beta*y. 

            //              TRANS = 'T' or 't'   y := alpha*A'*x + beta*y. 

            //              TRANS = 'C' or 'c'   y := alpha*conjg( A' )*x + beta*y. 

            //           Unchanged on exit. 

            //  M      - int. 
            //           On entry, M specifies the number of rows of the matrix A. 
            //           M must be at least zero. 
            //           Unchanged on exit. 

            //  N      - int. 
            //           On entry, N specifies the number of columns of the matrix A. 
            //           N must be at least zero. 
            //           Unchanged on exit. 

            //  ALPHA  - COMPLEX*16      . 
            //           On entry, ALPHA specifies the scalar alpha. 
            //           Unchanged on exit. 

            //  A      - COMPLEX*16       array of DIMENSION ( LDA, n ). 
            //           Before entry, the leading m by n part of the array A must 
            //           contain the matrix of coefficients. 
            //           Unchanged on exit. 

            //  LDA    - int. 
            //           On entry, LDA specifies the first dimension of A as declared 
            //           in the calling (sub) program. LDA must be at least 
            //           max( 1, m ). 
            //           Unchanged on exit. 

            //  X      - COMPLEX*16       array of DIMENSION at least 
            //           ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n' 
            //           and at least 
            //           ( 1 + ( m - 1 )*abs( INCX ) ) otherwise. 
            //           Before entry, the incremented array X must contain the 
            //           vector x. 
            //           Unchanged on exit. 

            //  INCX   - int. 
            //           On entry, INCX specifies the increment for the elements of 
            //           X. INCX must not be zero. 
            //           Unchanged on exit. 

            //  BETA   - COMPLEX*16      . 
            //           On entry, BETA specifies the scalar beta. When BETA is 
            //           supplied as zero then Y need not be set on input. 
            //           Unchanged on exit. 

            //  Y      - COMPLEX*16       array of DIMENSION at least 
            //           ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n' 
            //           and at least 
            //           ( 1 + ( n - 1 )*abs( INCY ) ) otherwise. 
            //           Before entry with BETA non-zero, the incremented array Y 
            //           must contain the vector y. On exit, Y is overwritten by the 
            //           updated vector y. 

            //  INCY   - int. 
            //           On entry, INCY specifies the increment for the elements of 
            //           Y. INCY must not be zero. 
            //           Unchanged on exit. 


            //  Level 2 Blas routine. 

            //  -- Written on 22-October-1986. 
            //     Jack Dongarra, Argonne National Lab. 
            //     Jeremy Du Croz, Nag Central Office. 
            //     Sven Hammarling, Nag Central Office. 
            //     Richard Hanson, Sandia National Labs. 

            // System generated locals 
            int a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5;
            complex16 z__1, z__2, z__3;

            // Local variables 
            int i, j, ix, iy, jx, jy, kx, ky, info;
            complex16 temp;
            int lenx, leny;
            bool noconj;

            // Parameter adjustments 
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;
            --x;
            --y;

            // Function Body 
            info = 0;
            if (!lsame(trans, "N") && !lsame(trans, "T") && !lsame(trans, "C"))
            {
                info = 1;
            }
            else if (*m < 0)
            {
                info = 2;
            }
            else if (*n < 0)
            {
                info = 3;
            }
            else if (*lda < Math.Max(1, *m))
            {
                info = 6;
            }
            else if (*incx == 0)
            {
                info = 8;
            }
            else if (*incy == 0)
            {
                info = 11;
            }

            if (info != 0)
            {
                xerbla("ZGEMV ", &info);
                return 0;
            }

            // Quick return if possible. 

            if (*m == 0 || *n == 0 || alpha.r == 0.0 && alpha.i == 0.0 && (beta.r == 1.0 && beta.i == 0.0))
            {
                return 0;
            }

            noconj = lsame(trans, "T");

            // Set  LENX  and  LENY, the lengths of the vectors x and y, and set 
            // up the start points in  X  and  Y. 

            if (lsame(trans, "N"))
            {
                lenx = *n;
                leny = *m;
            }
            else
            {
                lenx = *m;
                leny = *n;
            }

            if (*incx > 0)
                kx = 1;
            else
                kx = 1 - (lenx - 1) * *incx;

            if (*incy > 0)
                ky = 1;
            else
                ky = 1 - (leny - 1) * *incy;

            // Start the operations. In this version the elements of A are 
            // accessed sequentially with one pass through A. 

            // First form  y := beta*y. 

            if (beta.r != 1.0 || beta.i != 0.0)
            {
                if (*incy == 1)
                {
                    if (beta.r == 0.0 && beta.i == 0.0)
                    {
                        i__1 = leny;
                        for (i = 1; i <= i__1; ++i)
                        {
                            i__2 = i;
                            y[i__2].r = 0.0;
                            y[i__2].i = 0.0;
                        }
                    }
                    else
                    {
                        i__1 = leny;
                        for (i = 1; i <= i__1; ++i)
                        {
                            i__2 = i;
                            i__3 = i;
                            z__1.r = beta.r * y[i__3].r - beta.i * y[i__3].i;
                            z__1.i = beta.r * y[i__3].i + beta.i * y[i__3].r;

                            y[i__2].r = z__1.r;
                            y[i__2].i = z__1.i;
                        }
                    }
                }
                else
                {
                    iy = ky;
                    if (beta.r == 0.0 && beta.i == 0.0)
                    {
                        i__1 = leny;
                        for (i = 1; i <= i__1; ++i)
                        {
                            i__2 = iy;
                            y[i__2].r = 0.0;
                            y[i__2].i = 0.0;
                            iy += *incy;
                        }
                    }
                    else
                    {
                        i__1 = leny;
                        for (i = 1; i <= i__1; ++i)
                        {
                            i__2 = iy;
                            i__3 = iy;
                            z__1.r = beta.r * y[i__3].r - beta.i * y[i__3].i;
                            z__1.i = beta.r * y[i__3].i + beta.i * y[i__3].r;

                            y[i__2].r = z__1.r;
                            y[i__2].i = z__1.i;
                            iy += *incy;
                        }
                    }
                }
            }

            if (alpha.r == 0.0 && alpha.i == 0.0)
            {
                return 0;
            }

            if (lsame(trans, "N"))
            {
                // Form  y := alpha*A*x + y. 

                jx = kx;
                if (*incy == 1)
                {
                    i__1 = *n;
                    for (j = 1; j <= i__1; ++j)
                    {
                        i__2 = jx;
                        if (x[i__2].r != 0.0 || x[i__2].i != 0.0)
                        {
                            i__2 = jx;
                            z__1.r = alpha.r * x[i__2].r - alpha.i * x[i__2].i;
                            z__1.i = alpha.r * x[i__2].i + alpha.i * x[i__2].r;

                            temp.r = z__1.r;
                            temp.i = z__1.i;

                            i__2 = *m;

                            for (i = 1; i <= i__2; ++i)
                            {
                                i__3 = i;
                                i__4 = i;
                                i__5 = i + j * a_dim1;
                                z__2.r = temp.r * a[i__5].r - temp.i * a[i__5].i;
                                z__2.i = temp.r * a[i__5].i + temp.i * a[i__5].r;

                                z__1.r = y[i__4].r + z__2.r;
                                z__1.i = y[i__4].i + z__2.i;

                                y[i__3].r = z__1.r;
                                y[i__3].i = z__1.i;
                            }
                        }
                        jx += *incx;
                    }
                }
                else
                {
                    i__1 = *n;
                    for (j = 1; j <= i__1; ++j)
                    {
                        i__2 = jx;
                        if (x[i__2].r != 0.0 || x[i__2].i != 0.0)
                        {
                            i__2 = jx;
                            z__1.r = alpha.r * x[i__2].r - alpha.i * x[i__2].i;
                            z__1.i = alpha.r * x[i__2].i + alpha.i * x[i__2].r;

                            temp.r = z__1.r;
                            temp.i = z__1.i;

                            iy = ky;
                            i__2 = *m;

                            for (i = 1; i <= i__2; ++i)
                            {
                                i__3 = iy;
                                i__4 = iy;
                                i__5 = i + j * a_dim1;
                                z__2.r = temp.r * a[i__5].r - temp.i * a[i__5].i;
                                z__2.i = temp.r * a[i__5].i + temp.i * a[i__5].r;

                                z__1.r = y[i__4].r + z__2.r;
                                z__1.i = y[i__4].i + z__2.i;

                                y[i__3].r = z__1.r;
                                y[i__3].i = z__1.i;
                                iy += *incy;
                            }
                        }
                        jx += *incx;
                    }
                }
            }
            else
            {
                // Form  y := alpha*A'*x + y  or  y := alpha*conjg( A' )*x + y. 

                jy = ky;
                if (*incx == 1)
                {
                    i__1 = *n;
                    for (j = 1; j <= i__1; ++j)
                    {
                        temp.r = 0.0;
                        temp.i = 0.0;

                        if (noconj)
                        {
                            i__2 = *m;
                            for (i = 1; i <= i__2; ++i)
                            {
                                i__3 = i + j * a_dim1;
                                i__4 = i;
                                z__2.r = a[i__3].r * x[i__4].r - a[i__3].i * x[i__4].i;
                                z__2.i = a[i__3].r * x[i__4].i + a[i__3].i * x[i__4].r;

                                z__1.r = temp.r + z__2.r;
                                z__1.i = temp.i + z__2.i;

                                temp.r = z__1.r;
                                temp.i = z__1.i;
                            }
                        }
                        else
                        {
                            i__2 = *m;
                            for (i = 1; i <= i__2; ++i)
                            {
                                d_cnjg(&z__3, &a[i + j * a_dim1]);
                                i__3 = i;
                                z__2.r = z__3.r * x[i__3].r - z__3.i * x[i__3].i;
                                z__2.i = z__3.r * x[i__3].i + z__3.i * x[i__3].r;

                                z__1.r = temp.r + z__2.r;
                                z__1.i = temp.i + z__2.i;

                                temp.r = z__1.r;
                                temp.i = z__1.i;
                            }
                        }

                        i__2 = jy;
                        i__3 = jy;
                        z__2.r = alpha.r * temp.r - alpha.i * temp.i;
                        z__2.i = alpha.r * temp.i + alpha.i * temp.r;
                        z__1.r = y[i__3].r + z__2.r;
                        z__1.i = y[i__3].i + z__2.i;

                        y[i__2].r = z__1.r;
                        y[i__2].i = z__1.i;

                        jy += *incy;
                    }
                }
                else
                {
                    i__1 = *n;
                    for (j = 1; j <= i__1; ++j)
                    {
                        temp.r = 0.0;
                        temp.i = 0.0;
                        ix = kx;

                        if (noconj)
                        {
                            i__2 = *m;
                            for (i = 1; i <= i__2; ++i)
                            {
                                i__3 = i + j * a_dim1;
                                i__4 = ix;
                                z__2.r = a[i__3].r * x[i__4].r - a[i__3].i * x[i__4].i;
                                z__2.i = a[i__3].r * x[i__4].i + a[i__3].i * x[i__4].r;

                                z__1.r = temp.r + z__2.r;
                                z__1.i = temp.i + z__2.i;

                                temp.r = z__1.r;
                                temp.i = z__1.i;
                                ix += *incx;
                            }
                        }
                        else
                        {
                            i__2 = *m;
                            for (i = 1; i <= i__2; ++i)
                            {
                                d_cnjg(&z__3, &a[i + j * a_dim1]);
                                i__3 = ix;
                                z__2.r = z__3.r * x[i__3].r - z__3.i * x[i__3].i;
                                z__2.i = z__3.r * x[i__3].i + z__3.i * x[i__3].r;

                                z__1.r = temp.r + z__2.r;
                                z__1.i = temp.i + z__2.i;

                                temp.r = z__1.r;
                                temp.i = z__1.i;
                                ix += *incx;
                            }
                        }
                        i__2 = jy;
                        i__3 = jy;

                        z__2.r = alpha.r * temp.r - alpha.i * temp.i;
                        z__2.i = alpha.r * temp.i + alpha.i * temp.r;

                        z__1.r = y[i__3].r + z__2.r;
                        z__1.i = y[i__3].i + z__2.i;

                        y[i__2].r = z__1.r;
                        y[i__2].i = z__1.i;
                        jy += *incy;
                    }
                }
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zgerc(int* m, int* n, complex16* alpha,
            complex16* x, int* incx, complex16* y, int* incy,
            complex16* a, int* lda)
        {
            //  Purpose 
            //  ======= 

            //  ZGERC  performs the rank 1 operation 

            //     A := alpha*x*conjg( y' ) + A, 

            //  where alpha is a scalar, x is an m element vector, y is an n element 
            //  vector and A is an m by n matrix. 

            //  Arguments 
            //  ========== 

            //  M      - int. 
            //           On entry, M specifies the number of rows of the matrix A. 
            //           M must be at least zero. 
            //           Unchanged on exit. 

            //  N      - int. 
            //           On entry, N specifies the number of columns of the matrix A. 
            //           N must be at least zero. 
            //           Unchanged on exit. 

            //  ALPHA  - COMPLEX*16      . 
            //           On entry, ALPHA specifies the scalar alpha. 
            //           Unchanged on exit. 

            //  X      - COMPLEX*16       array of dimension at least 
            //           ( 1 + ( m - 1 )*abs( INCX ) ). 
            //           Before entry, the incremented array X must contain the m 
            //           element vector x. 
            //           Unchanged on exit. 

            //  INCX   - int. 
            //           On entry, INCX specifies the increment for the elements of 
            //           X. INCX must not be zero. 
            //           Unchanged on exit. 

            //  Y      - COMPLEX*16       array of dimension at least 
            //           ( 1 + ( n - 1 )*abs( INCY ) ). 
            //           Before entry, the incremented array Y must contain the n 
            //           element vector y. 
            //           Unchanged on exit. 

            //  INCY   - int. 
            //           On entry, INCY specifies the increment for the elements of 
            //           Y. INCY must not be zero. 
            //           Unchanged on exit. 

            //  A      - COMPLEX*16       array of DIMENSION ( LDA, n ). 
            //           Before entry, the leading m by n part of the array A must 
            //           contain the matrix of coefficients. On exit, A is 
            //           overwritten by the updated matrix. 

            //  LDA    - int. 
            //           On entry, LDA specifies the first dimension of A as declared 
            //           in the calling (sub) program. LDA must be at least 
            //           max( 1, m ). 
            //           Unchanged on exit. 


            //  Level 2 Blas routine. 

            //  -- Written on 22-October-1986. 
            //     Jack Dongarra, Argonne National Lab. 
            //     Jeremy Du Croz, Nag Central Office. 
            //     Sven Hammarling, Nag Central Office. 
            //     Richard Hanson, Sandia National Labs. 

            // System generated locals 
            int a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5;
            complex16 z__1, z__2;

            // Local variables 
            int i, j, ix, jy, kx, info;
            complex16 temp;

            // Parameter adjustments 
            --x;
            --y;
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;

            // Function Body 
            info = 0;
            if (*m < 0)
            {
                info = 1;
            }
            else if (*n < 0)
            {
                info = 2;
            }
            else if (*incx == 0)
            {
                info = 5;
            }
            else if (*incy == 0)
            {
                info = 7;
            }
            else if (*lda < Math.Max(1, *m))
            {
                info = 9;
            }

            if (info != 0)
            {
                xerbla("ZGERC ", &info);
                return 0;
            }

            // Quick return if possible. 

            if (*m == 0 || *n == 0 || alpha.r == 0.0 && alpha.i == 0.0)
            {
                return 0;
            }

            // Start the operations. In this version the elements of A are 
            // accessed sequentially with one pass through A. 

            if (*incy > 0)
            {
                jy = 1;
            }
            else
            {
                jy = 1 - (*n - 1) * *incy;
            }
            if (*incx == 1)
            {
                i__1 = *n;
                for (j = 1; j <= i__1; ++j)
                {
                    i__2 = jy;
                    if (y[i__2].r != 0.0 || y[i__2].i != 0.0)
                    {
                        d_cnjg(&z__2, &y[jy]);

                        z__1.r = alpha.r * z__2.r - alpha.i * z__2.i;
                        z__1.i = alpha.r * z__2.i + alpha.i * z__2.r;

                        temp.r = z__1.r;
                        temp.i = z__1.i;

                        i__2 = *m;
                        for (i = 1; i <= i__2; ++i)
                        {
                            i__3 = i + j * a_dim1;
                            i__4 = i + j * a_dim1;
                            i__5 = i;

                            z__2.r = x[i__5].r * temp.r - x[i__5].i * temp.i;
                            z__2.i = x[i__5].r * temp.i + x[i__5].i * temp.r;

                            z__1.r = a[i__4].r + z__2.r;
                            z__1.i = a[i__4].i + z__2.i;

                            a[i__3].r = z__1.r;
                            a[i__3].i = z__1.i;
                        }
                    }
                    jy += *incy;
                }
            }
            else
            {
                if (*incx > 0)
                {
                    kx = 1;
                }
                else
                {
                    kx = 1 - (*m - 1) * *incx;
                }

                i__1 = *n;

                for (j = 1; j <= i__1; ++j)
                {
                    i__2 = jy;
                    if (y[i__2].r != 0.0 || y[i__2].i != 0.0)
                    {
                        d_cnjg(&z__2, &y[jy]);

                        z__1.r = alpha.r * z__2.r - alpha.i * z__2.i;
                        z__1.i = alpha.r * z__2.i + alpha.i * z__2.r;

                        temp.r = z__1.r;
                        temp.i = z__1.i;

                        ix = kx;
                        i__2 = *m;

                        for (i = 1; i <= i__2; ++i)
                        {
                            i__3 = i + j * a_dim1;
                            i__4 = i + j * a_dim1;
                            i__5 = ix;
                            z__2.r = x[i__5].r * temp.r - x[i__5].i * temp.i;
                            z__2.i = x[i__5].r * temp.i + x[i__5].i * temp.r;

                            z__1.r = a[i__4].r + z__2.r;
                            z__1.i = a[i__4].i + z__2.i;

                            a[i__3].r = z__1.r;
                            a[i__3].i = z__1.i;
                            ix += *incx;
                        }
                    }

                    jy += *incy;
                }
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zscal(int* n, complex16* za, complex16* zx, int* incx)
        {
            //  Purpose 
            //  ======= 

            //     scales a vector by a constant. 
            //     jack dongarra, 3/11/78. 
            //     modified 3/93 to return if incx .le. 0. 
            //     modified 12/3/93, array(1) declarations changed to array(*) 

            // System generated locals 
            int i__1, i__2, i__3;
            complex16 z__1;

            // Local variables 
            int i, ix;

            // Parameter adjustments 
            --zx;

            // Function Body 
            if (*n <= 0 || *incx <= 0)
            {
                return 0;
            }
            if (*incx == 1)
            {
                goto L20;
            }

            // code for increment not equal to 1 

            ix = 1;
            i__1 = *n;
            for (i = 1; i <= i__1; ++i)
            {
                i__2 = ix;
                i__3 = ix;
                z__1.r = za.r * zx[i__3].r - za.i * zx[i__3].i;
                z__1.i = za.r * zx[i__3].i + za.i * zx[i__3].r;

                zx[i__2].r = z__1.r;
                zx[i__2].i = z__1.i;
                ix += *incx;
            }
            return 0;

            // code for increment equal to 1 

            L20:
            i__1 = *n;
            for (i = 1; i <= i__1; ++i)
            {
                i__2 = i;
                i__3 = i;
                z__1.r = za.r * zx[i__3].r - za.i * zx[i__3].i;
                z__1.i = za.r * zx[i__3].i + za.i * zx[i__3].r;

                zx[i__2].r = z__1.r;
                zx[i__2].i = z__1.i;
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zswap(int* n, complex16* zx, int* incx, complex16* zy, int* incy)
        {
            //  Purpose 
            //  ======= 

            // interchanges two vectors. 
            // jack dongarra, 3/11/78. 
            // modified 12/3/93, array(1) declarations changed to array(*) 

            // System generated locals 
            int i__1, i__2, i__3;

            // Local variables 
            int i, ix, iy;
            complex16 ztemp;

            // Parameter adjustments 
            --zy;
            --zx;

            // Function Body 
            if (*n <= 0)
            {
                return 0;
            }
            if (*incx == 1 && *incy == 1)
            {
                goto L20;
            }

            // code for unequal increments or equal increments not equal 
            // to 1 

            ix = 1;
            iy = 1;
            if (*incx < 0)
            {
                ix = (-(*n) + 1) * *incx + 1;
            }
            if (*incy < 0)
            {
                iy = (-(*n) + 1) * *incy + 1;
            }
            i__1 = *n;
            for (i = 1; i <= i__1; ++i)
            {
                i__2 = ix;
                ztemp.r = zx[i__2].r;
                ztemp.i = zx[i__2].i;
                i__2 = ix;
                i__3 = iy;
                zx[i__2].r = zy[i__3].r;
                zx[i__2].i = zy[i__3].i;
                i__2 = iy;
                zy[i__2].r = ztemp.r;
                zy[i__2].i = ztemp.i;
                ix += *incx;
                iy += *incy;
            }
            return 0;

            // code for both increments equal to 1 

        L20:
            i__1 = *n;
            for (i = 1; i <= i__1; ++i)
            {
                i__2 = i;
                ztemp.r = zx[i__2].r;
                ztemp.i = zx[i__2].i;

                i__2 = i;
                i__3 = i;

                zx[i__2].r = zy[i__3].r;
                zx[i__2].i = zy[i__3].i;
                i__2 = i;

                zy[i__2].r = ztemp.r;
                zy[i__2].i = ztemp.i;
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int ztrmm(string side, string uplo, string transa, string diag,
            int* m, int* n, complex16* alpha, complex16* a, int* lda, complex16* b, int* ldb)
        {
            //  Purpose 
            //  ======= 

            //  ZTRMM  performs one of the matrix-matrix operations 

            //     B := alpha*op( A )*B,   or   B := alpha*B*op( A ) 

            //  where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or 
            //  non-unit,  upper or lower triangular matrix  and  op( A )  is one  of 

            //     op( A ) = A   or   op( A ) = A'   or   op( A ) = conjg( A' ). 

            //  Arguments 
            //  ========== 

            //  SIDE   - CHARACTER*1. 
            //           On entry,  SIDE specifies whether  op( A ) multiplies B from 
            //           the left or right as follows: 

            //              SIDE = 'L' or 'l'   B := alpha*op( A )*B. 

            //              SIDE = 'R' or 'r'   B := alpha*B*op( A ). 

            //           Unchanged on exit. 

            //  UPLO   - CHARACTER*1. 
            //           On entry, UPLO specifies whether the matrix A is an upper or 
            //           lower triangular matrix as follows: 

            //              UPLO = 'U' or 'u'   A is an upper triangular matrix. 

            //              UPLO = 'L' or 'l'   A is a lower triangular matrix. 

            //           Unchanged on exit. 

            //  TRANSA - CHARACTER*1. 
            //           On entry, TRANSA specifies the form of op( A ) to be used in 
            //           the matrix multiplication as follows: 

            //              TRANSA = 'N' or 'n'   op( A ) = A. 

            //              TRANSA = 'T' or 't'   op( A ) = A'. 

            //              TRANSA = 'C' or 'c'   op( A ) = conjg( A' ). 

            //           Unchanged on exit. 

            //  DIAG   - CHARACTER*1. 
            //           On entry, DIAG specifies whether or not A is unit triangular 
            //           as follows: 

            //              DIAG = 'U' or 'u'   A is assumed to be unit triangular. 

            //              DIAG = 'N' or 'n'   A is not assumed to be unit 
            //                                  triangular. 

            //           Unchanged on exit. 

            //  M      - int. 
            //           On entry, M specifies the number of rows of B. M must be at 
            //           least zero. 
            //           Unchanged on exit. 

            //  N      - int. 
            //           On entry, N specifies the number of columns of B.  N must be 
            //           at least zero. 
            //           Unchanged on exit. 

            //  ALPHA  - COMPLEX*16      . 
            //           On entry,  ALPHA specifies the scalar  alpha. When  alpha is 
            //           zero then  A is not referenced and  B need not be set before 
            //           entry. 
            //           Unchanged on exit. 

            //  A      - COMPLEX*16       array of DIMENSION ( LDA, k ), where k is m 
            //           when  SIDE = 'L' or 'l'  and is  n  when  SIDE = 'R' or 'r'. 
            //           Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k 
            //           upper triangular part of the array  A must contain the upper 
            //           triangular matrix  and the strictly lower triangular part of 
            //           A is not referenced. 
            //           Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k 
            //           lower triangular part of the array  A must contain the lower 
            //           triangular matrix  and the strictly upper triangular part of 
            //           A is not referenced. 
            //           Note that when  DIAG = 'U' or 'u',  the diagonal elements of 
            //           A  are not referenced either,  but are assumed to be  unity. 
            //           Unchanged on exit. 

            //  LDA    - int. 
            //           On entry, LDA specifies the first dimension of A as declared 
            //           in the calling (sub) program.  When  SIDE = 'L' or 'l'  then 
            //           LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r' 
            //           then LDA must be at least max( 1, n ). 
            //           Unchanged on exit. 

            //  B      - COMPLEX*16       array of DIMENSION ( LDB, n ). 
            //           Before entry,  the leading  m by n part of the array  B must 
            //           contain the matrix  B,  and  on exit  is overwritten  by the 
            //           transformed matrix. 

            //  LDB    - int. 
            //           On entry, LDB specifies the first dimension of B as declared 
            //           in  the  calling  (sub)  program.   LDB  must  be  at  least 
            //           max( 1, m ). 
            //           Unchanged on exit. 


            //  Level 3 Blas routine. 

            //  -- Written on 8-February-1989. 
            //     Jack Dongarra, Argonne National Laboratory. 
            //     Iain Duff, AERE Harwell. 
            //     Jeremy Du Croz, Numerical Algorithms Group Ltd. 
            //     Sven Hammarling, Numerical Algorithms Group Ltd. 

            // System generated locals 
            int a_dim1, a_offset, b_dim1, b_offset, i__1, i__2, i__3, i__4, i__5, i__6;
            complex16 z__1, z__2, z__3;

            // Local variables 
            int i, j, k, info;
            complex16 temp;
            bool lside;
            int nrowa;
            bool upper;
            bool noconj, nounit;

            // Parameter adjustments 
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;
            b_dim1 = *ldb;
            b_offset = 1 + b_dim1;
            b -= b_offset;

            // Function Body 
            lside = lsame(side, "L");

            if (lside)
            {
                nrowa = *m;
            }
            else
            {
                nrowa = *n;
            }

            noconj = lsame(transa, "T");
            nounit = lsame(diag, "N");
            upper = lsame(uplo, "U");

            info = 0;
            if (!lside && !lsame(side, "R"))
            {
                info = 1;
            }
            else if (!upper && !lsame(uplo, "L"))
            {
                info = 2;
            }
            else if (!lsame(transa, "N") && !lsame(transa, "T") && !lsame(transa, "C"))
            {
                info = 3;
            }
            else if (!lsame(diag, "U") && !lsame(diag, "N"))
            {
                info = 4;
            }
            else if (*m < 0)
            {
                info = 5;
            }
            else if (*n < 0)
            {
                info = 6;
            }
            else if (*lda < Math.Max(1, nrowa))
            {
                info = 9;
            }
            else if (*ldb < Math.Max(1, *m))
            {
                info = 11;
            }

            if (info != 0)
            {
                xerbla("ZTRMM ", &info);
                return 0;
            }

            // Quick return if possible. 

            if (*m == 0 || *n == 0)
            {
                return 0;
            }

            // And when  alpha.eq.zero. 

            if (alpha.r == 0.0 && alpha.i == 0.0)
            {
                i__1 = *n;
                for (j = 1; j <= i__1; ++j)
                {
                    i__2 = *m;
                    for (i = 1; i <= i__2; ++i)
                    {
                        i__3 = i + j * b_dim1;
                        b[i__3].r = 0.0;
                        b[i__3].i = 0.0;
                    }
                }
                return 0;
            }

            // Start the operations. 

            if (lside)
            {
                if (lsame(transa, "N"))
                {
                    // Form  B := alpha*A*B. 
                    if (upper)
                    {
                        i__1 = *n;
                        for (j = 1; j <= i__1; ++j)
                        {
                            i__2 = *m;
                            for (k = 1; k <= i__2; ++k)
                            {
                                i__3 = k + j * b_dim1;

                                if (b[i__3].r != 0.0 || b[i__3].i != 0.0)
                                {
                                    i__3 = k + j * b_dim1;
                                    z__1.r = alpha.r * b[i__3].r - alpha.i * b[i__3].i;
                                    z__1.i = alpha.r * b[i__3].i + alpha.i * b[i__3].r;

                                    temp.r = z__1.r;
                                    temp.i = z__1.i;

                                    i__3 = k - 1;
                                    for (i = 1; i <= i__3; ++i)
                                    {
                                        i__4 = i + j * b_dim1;
                                        i__5 = i + j * b_dim1;
                                        i__6 = i + k * a_dim1;

                                        z__2.r = temp.r * a[i__6].r - temp.i * a[i__6].i;
                                        z__2.i = temp.r * a[i__6].i + temp.i * a[i__6].r;

                                        z__1.r = b[i__5].r + z__2.r;
                                        z__1.i = b[i__5].i + z__2.i;

                                        b[i__4].r = z__1.r;
                                        b[i__4].i = z__1.i;
                                    }
                                    if (nounit)
                                    {
                                        i__3 = k + k * a_dim1;
                                        z__1.r = temp.r * a[i__3].r - temp.i * a[i__3].i;
                                        z__1.i = temp.r * a[i__3].i + temp.i * a[i__3].r;

                                        temp.r = z__1.r;
                                        temp.i = z__1.i;
                                    }
                                    i__3 = k + j * b_dim1;
                                    b[i__3].r = temp.r;
                                    b[i__3].i = temp.i;
                                }
                            }
                        }
                    }
                    else
                    {
                        i__1 = *n;
                        for (j = 1; j <= i__1; ++j)
                        {
                            for (k = *m; k >= 1; --k)
                            {
                                i__2 = k + j * b_dim1;

                                if (b[i__2].r != 0.0 || b[i__2].i != 0.0)
                                {
                                    i__2 = k + j * b_dim1;
                                    z__1.r = alpha.r * b[i__2].r - alpha.i * b[i__2].i;
                                    z__1.i = alpha.r * b[i__2].i + alpha.i * b[i__2].r;

                                    temp.r = z__1.r;
                                    temp.i = z__1.i;

                                    i__2 = k + j * b_dim1;
                                    b[i__2].r = temp.r;
                                    b[i__2].i = temp.i;

                                    if (nounit)
                                    {
                                        i__2 = k + j * b_dim1;
                                        i__3 = k + j * b_dim1;
                                        i__4 = k + k * a_dim1;

                                        z__1.r = b[i__3].r * a[i__4].r - b[i__3].i * a[i__4].i;
                                        z__1.i = b[i__3].r * a[i__4].i + b[i__3].i * a[i__4].r;

                                        b[i__2].r = z__1.r;
                                        b[i__2].i = z__1.i;
                                    }
                                    i__2 = *m;
                                    for (i = k + 1; i <= i__2; ++i)
                                    {
                                        i__3 = i + j * b_dim1;
                                        i__4 = i + j * b_dim1;
                                        i__5 = i + k * a_dim1;

                                        z__2.r = temp.r * a[i__5].r - temp.i * a[i__5].i;
                                        z__2.i = temp.r * a[i__5].i + temp.i * a[i__5].r;

                                        z__1.r = b[i__4].r + z__2.r;
                                        z__1.i = b[i__4].i + z__2.i;

                                        b[i__3].r = z__1.r;
                                        b[i__3].i = z__1.i;
                                    }
                                }
                            }
                        }
                    }
                }
                else
                {
                    // Form  B := alpha*A'*B   or   B := alpha*conjg( A' )*B. 
                    if (upper)
                    {
                        i__1 = *n;
                        for (j = 1; j <= i__1; ++j)
                        {
                            for (i = *m; i >= 1; --i)
                            {
                                i__2 = i + j * b_dim1;
                                temp.r = b[i__2].r;
                                temp.i = b[i__2].i;

                                if (noconj)
                                {
                                    if (nounit)
                                    {
                                        i__2 = i + i * a_dim1;

                                        z__1.r = temp.r * a[i__2].r - temp.i * a[i__2].i;
                                        z__1.i = temp.r * a[i__2].i + temp.i * a[i__2].r;

                                        temp.r = z__1.r;
                                        temp.i = z__1.i;
                                    }
                                    i__2 = i - 1;

                                    for (k = 1; k <= i__2; ++k)
                                    {
                                        i__3 = k + i * a_dim1;
                                        i__4 = k + j * b_dim1;

                                        z__2.r = a[i__3].r * b[i__4].r - a[i__3].i * b[i__4].i;
                                        z__2.i = a[i__3].r * b[i__4].i + a[i__3].i * b[i__4].r;

                                        z__1.r = temp.r + z__2.r;
                                        z__1.i = temp.i + z__2.i;

                                        temp.r = z__1.r;
                                        temp.i = z__1.i;
                                    }
                                }
                                else
                                {
                                    if (nounit)
                                    {
                                        d_cnjg(&z__2, &a[i + i * a_dim1]);

                                        z__1.r = temp.r * z__2.r - temp.i * z__2.i;
                                        z__1.i = temp.r * z__2.i + temp.i * z__2.r;

                                        temp.r = z__1.r;
                                        temp.i = z__1.i;
                                    }

                                    i__2 = i - 1;

                                    for (k = 1; k <= i__2; ++k)
                                    {
                                        d_cnjg(&z__3, &a[k + i * a_dim1]);
                                        i__3 = k + j * b_dim1;

                                        z__2.r = z__3.r * b[i__3].r - z__3.i * b[i__3].i;
                                        z__2.i = z__3.r * b[i__3].i + z__3.i * b[i__3].r;

                                        z__1.r = temp.r + z__2.r;
                                        z__1.i = temp.i + z__2.i;

                                        temp.r = z__1.r;
                                        temp.i = z__1.i;
                                    }
                                }
                                i__2 = i + j * b_dim1;

                                z__1.r = alpha.r * temp.r - alpha.i * temp.i;
                                z__1.i = alpha.r * temp.i + alpha.i * temp.r;

                                b[i__2].r = z__1.r;
                                b[i__2].i = z__1.i;
                            }
                        }
                    }
                    else
                    {
                        i__1 = *n;
                        for (j = 1; j <= i__1; ++j)
                        {
                            i__2 = *m;
                            for (i = 1; i <= i__2; ++i)
                            {
                                i__3 = i + j * b_dim1;
                                temp.r = b[i__3].r;
                                temp.i = b[i__3].i;

                                if (noconj)
                                {
                                    if (nounit)
                                    {
                                        i__3 = i + i * a_dim1;
                                        z__1.r = temp.r * a[i__3].r - temp.i * a[i__3].i;
                                        z__1.i = temp.r * a[i__3].i + temp.i * a[i__3].r;

                                        temp.r = z__1.r;
                                        temp.i = z__1.i;
                                    }
                                    i__3 = *m;
                                    for (k = i + 1; k <= i__3; ++k)
                                    {
                                        i__4 = k + i * a_dim1;
                                        i__5 = k + j * b_dim1;

                                        z__2.r = a[i__4].r * b[i__5].r - a[i__4].i * b[i__5].i;
                                        z__2.i = a[i__4].r * b[i__5].i + a[i__4].i * b[i__5].r;

                                        z__1.r = temp.r + z__2.r;
                                        z__1.i = temp.i + z__2.i;

                                        temp.r = z__1.r;
                                        temp.i = z__1.i;
                                    }
                                }
                                else
                                {
                                    if (nounit)
                                    {
                                        d_cnjg(&z__2, &a[i + i * a_dim1]);

                                        z__1.r = temp.r * z__2.r - temp.i * z__2.i;
                                        z__1.i = temp.r * z__2.i + temp.i * z__2.r;

                                        temp.r = z__1.r;
                                        temp.i = z__1.i;
                                    }

                                    i__3 = *m;

                                    for (k = i + 1; k <= i__3; ++k)
                                    {
                                        d_cnjg(&z__3, &a[k + i * a_dim1]);
                                        i__4 = k + j * b_dim1;

                                        z__2.r = z__3.r * b[i__4].r - z__3.i * b[i__4].i;
                                        z__2.i = z__3.r * b[i__4].i + z__3.i * b[i__4].r;

                                        z__1.r = temp.r + z__2.r;
                                        z__1.i = temp.i + z__2.i;

                                        temp.r = z__1.r;
                                        temp.i = z__1.i;
                                    }
                                }

                                i__3 = i + j * b_dim1;

                                z__1.r = alpha.r * temp.r - alpha.i * temp.i;
                                z__1.i = alpha.r * temp.i + alpha.i * temp.r;

                                b[i__3].r = z__1.r;
                                b[i__3].i = z__1.i;
                            }
                        }
                    }
                }
            }
            else
            {
                if (lsame(transa, "N"))
                {
                    // Form  B := alpha*B*A. 
                    if (upper)
                    {
                        for (j = *n; j >= 1; --j)
                        {
                            temp.r = alpha.r;
                            temp.i = alpha.i;

                            if (nounit)
                            {
                                i__1 = j + j * a_dim1;

                                z__1.r = temp.r * a[i__1].r - temp.i * a[i__1].i;
                                z__1.i = temp.r * a[i__1].i + temp.i * a[i__1].r;

                                temp.r = z__1.r;
                                temp.i = z__1.i;
                            }
                            i__1 = *m;

                            for (i = 1; i <= i__1; ++i)
                            {
                                i__2 = i + j * b_dim1;
                                i__3 = i + j * b_dim1;

                                z__1.r = temp.r * b[i__3].r - temp.i * b[i__3].i;
                                z__1.i = temp.r * b[i__3].i + temp.i * b[i__3].r;

                                b[i__2].r = z__1.r;
                                b[i__2].i = z__1.i;
                            }

                            i__1 = j - 1;

                            for (k = 1; k <= i__1; ++k)
                            {
                                i__2 = k + j * a_dim1;
                                if (a[i__2].r != 0.0 || a[i__2].i != 0.0)
                                {
                                    i__2 = k + j * a_dim1;

                                    z__1.r = alpha.r * a[i__2].r - alpha.i * a[i__2].i;
                                    z__1.i = alpha.r * a[i__2].i + alpha.i * a[i__2].r;

                                    temp.r = z__1.r;
                                    temp.i = z__1.i;
                                    i__2 = *m;
                                    for (i = 1; i <= i__2; ++i)
                                    {
                                        i__3 = i + j * b_dim1;
                                        i__4 = i + j * b_dim1;
                                        i__5 = i + k * b_dim1;

                                        z__2.r = temp.r * b[i__5].r - temp.i * b[i__5].i;
                                        z__2.i = temp.r * b[i__5].i + temp.i * b[i__5].r;

                                        z__1.r = b[i__4].r + z__2.r;
                                        z__1.i = b[i__4].i + z__2.i;

                                        b[i__3].r = z__1.r;
                                        b[i__3].i = z__1.i;
                                    }
                                }
                            }
                        }
                    }
                    else
                    {
                        i__1 = *n;
                        for (j = 1; j <= i__1; ++j)
                        {
                            temp.r = alpha.r;
                            temp.i = alpha.i;

                            if (nounit)
                            {
                                i__2 = j + j * a_dim1;
                                z__1.r = temp.r * a[i__2].r - temp.i * a[i__2].i;
                                z__1.i = temp.r * a[i__2].i + temp.i * a[i__2].r;

                                temp.r = z__1.r;
                                temp.i = z__1.i;
                            }
                            i__2 = *m;
                            for (i = 1; i <= i__2; ++i)
                            {
                                i__3 = i + j * b_dim1;
                                i__4 = i + j * b_dim1;

                                z__1.r = temp.r * b[i__4].r - temp.i * b[i__4].i;
                                z__1.i = temp.r * b[i__4].i + temp.i * b[i__4].r;

                                b[i__3].r = z__1.r;
                                b[i__3].i = z__1.i;
                            }
                            i__2 = *n;

                            for (k = j + 1; k <= i__2; ++k)
                            {
                                i__3 = k + j * a_dim1;
                                if (a[i__3].r != 0.0 || a[i__3].i != 0.0)
                                {
                                    i__3 = k + j * a_dim1;
                                    z__1.r = alpha.r * a[i__3].r - alpha.i * a[i__3].i;
                                    z__1.i = alpha.r * a[i__3].i + alpha.i * a[i__3].r;

                                    temp.r = z__1.r;
                                    temp.i = z__1.i;
                                    i__3 = *m;

                                    for (i = 1; i <= i__3; ++i)
                                    {
                                        i__4 = i + j * b_dim1;
                                        i__5 = i + j * b_dim1;
                                        i__6 = i + k * b_dim1;

                                        z__2.r = temp.r * b[i__6].r - temp.i * b[i__6].i;
                                        z__2.i = temp.r * b[i__6].i + temp.i * b[i__6].r;

                                        z__1.r = b[i__5].r + z__2.r;
                                        z__1.i = b[i__5].i + z__2.i;

                                        b[i__4].r = z__1.r;
                                        b[i__4].i = z__1.i;
                                    }
                                }
                            }
                        }
                    }
                }
                else
                {
                    // Form  B := alpha*B*A'   or   B := alpha*B*conjg( A' ). 
                    if (upper)
                    {
                        i__1 = *n;
                        for (k = 1; k <= i__1; ++k)
                        {
                            i__2 = k - 1;
                            for (j = 1; j <= i__2; ++j)
                            {
                                i__3 = j + k * a_dim1;
                                if (a[i__3].r != 0.0 || a[i__3].i != 0.0)
                                {
                                    if (noconj)
                                    {
                                        i__3 = j + k * a_dim1;
                                        z__1.r = alpha.r * a[i__3].r - alpha.i * a[i__3].i;
                                        z__1.i = alpha.r * a[i__3].i + alpha.i * a[i__3].r;

                                        temp.r = z__1.r;
                                        temp.i = z__1.i;
                                    }
                                    else
                                    {
                                        d_cnjg(&z__2, &a[j + k * a_dim1]);

                                        z__1.r = alpha.r * z__2.r - alpha.i * z__2.i;
                                        z__1.i = alpha.r * z__2.i + alpha.i * z__2.r;

                                        temp.r = z__1.r;
                                        temp.i = z__1.i;
                                    }

                                    i__3 = *m;
                                    for (i = 1; i <= i__3; ++i)
                                    {
                                        i__4 = i + j * b_dim1;
                                        i__5 = i + j * b_dim1;
                                        i__6 = i + k * b_dim1;

                                        z__2.r = temp.r * b[i__6].r - temp.i * b[i__6].i;
                                        z__2.i = temp.r * b[i__6].i + temp.i * b[i__6].r;

                                        z__1.r = b[i__5].r + z__2.r;
                                        z__1.i = b[i__5].i + z__2.i;

                                        b[i__4].r = z__1.r;
                                        b[i__4].i = z__1.i;
                                    }
                                }
                            }

                            temp.r = alpha.r;
                            temp.i = alpha.i;

                            if (nounit)
                            {
                                if (noconj)
                                {
                                    i__2 = k + k * a_dim1;
                                    z__1.r = temp.r * a[i__2].r - temp.i * a[i__2].i;
                                    z__1.i = temp.r * a[i__2].i + temp.i * a[i__2].r;

                                    temp.r = z__1.r;
                                    temp.i = z__1.i;
                                }
                                else
                                {
                                    d_cnjg(&z__2, &a[k + k * a_dim1]);

                                    z__1.r = temp.r * z__2.r - temp.i * z__2.i;
                                    z__1.i = temp.r * z__2.i + temp.i * z__2.r;

                                    temp.r = z__1.r;
                                    temp.i = z__1.i;
                                }
                            }
                            if (temp.r != 1.0 || temp.i != 0.0)
                            {
                                i__2 = *m;
                                for (i = 1; i <= i__2; ++i)
                                {
                                    i__3 = i + k * b_dim1;
                                    i__4 = i + k * b_dim1;

                                    z__1.r = temp.r * b[i__4].r - temp.i * b[i__4].i;
                                    z__1.i = temp.r * b[i__4].i + temp.i * b[i__4].r;

                                    b[i__3].r = z__1.r;
                                    b[i__3].i = z__1.i;
                                }
                            }
                        }
                    }
                    else
                    {
                        for (k = *n; k >= 1; --k)
                        {
                            i__1 = *n;
                            for (j = k + 1; j <= i__1; ++j)
                            {
                                i__2 = j + k * a_dim1;
                                if (a[i__2].r != 0.0 || a[i__2].i != 0.0)
                                {
                                    if (noconj)
                                    {
                                        i__2 = j + k * a_dim1;

                                        z__1.r = alpha.r * a[i__2].r - alpha.i * a[i__2].i;
                                        z__1.i = alpha.r * a[i__2].i + alpha.i * a[i__2].r;

                                        temp.r = z__1.r;
                                        temp.i = z__1.i;
                                    }
                                    else
                                    {
                                        d_cnjg(&z__2, &a[j + k * a_dim1]);

                                        z__1.r = alpha.r * z__2.r - alpha.i * z__2.i;
                                        z__1.i = alpha.r * z__2.i + alpha.i * z__2.r;

                                        temp.r = z__1.r;
                                        temp.i = z__1.i;
                                    }
                                    i__2 = *m;
                                    for (i = 1; i <= i__2; ++i)
                                    {
                                        i__3 = i + j * b_dim1;
                                        i__4 = i + j * b_dim1;
                                        i__5 = i + k * b_dim1;

                                        z__2.r = temp.r * b[i__5].r - temp.i * b[i__5].i;
                                        z__2.i = temp.r * b[i__5].i + temp.i * b[i__5].r;

                                        z__1.r = b[i__4].r + z__2.r;
                                        z__1.i = b[i__4].i + z__2.i;

                                        b[i__3].r = z__1.r;
                                        b[i__3].i = z__1.i;
                                    }
                                }
                            }

                            temp.r = alpha.r;
                            temp.i = alpha.i;

                            if (nounit)
                            {
                                if (noconj)
                                {
                                    i__1 = k + k * a_dim1;

                                    z__1.r = temp.r * a[i__1].r - temp.i * a[i__1].i;
                                    z__1.i = temp.r * a[i__1].i + temp.i * a[i__1].r;

                                    temp.r = z__1.r;
                                    temp.i = z__1.i;
                                }
                                else
                                {
                                    d_cnjg(&z__2, &a[k + k * a_dim1]);

                                    z__1.r = temp.r * z__2.r - temp.i * z__2.i;
                                    z__1.i = temp.r * z__2.i + temp.i * z__2.r;

                                    temp.r = z__1.r;
                                    temp.i = z__1.i;
                                }
                            }
                            if (temp.r != 1.0 || temp.i != 0.0)
                            {
                                i__1 = *m;
                                for (i = 1; i <= i__1; ++i)
                                {
                                    i__2 = i + k * b_dim1;
                                    i__3 = i + k * b_dim1;

                                    z__1.r = temp.r * b[i__3].r - temp.i * b[i__3].i;
                                    z__1.i = temp.r * b[i__3].i + temp.i * b[i__3].r;

                                    b[i__2].r = z__1.r;
                                    b[i__2].i = z__1.i;
                                }
                            }
                        }
                    }
                }
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int ztrmv(string uplo, string trans, string diag, int* n,
            complex16* a, int* lda, complex16* x, int* incx)
        {
            //  Purpose 
            //  ======= 

            //  ZTRMV  performs one of the matrix-vector operations 

            //     x := A*x,   or   x := A'*x,   or   x := conjg( A' )*x, 

            //  where x is an n element vector and  A is an n by n unit, or non-unit, 
            //  upper or lower triangular matrix. 

            //  Arguments 
            //  ========== 

            //  UPLO   - CHARACTER*1. 
            //           On entry, UPLO specifies whether the matrix is an upper or 
            //           lower triangular matrix as follows: 

            //              UPLO = 'U' or 'u'   A is an upper triangular matrix. 

            //              UPLO = 'L' or 'l'   A is a lower triangular matrix. 

            //           Unchanged on exit. 

            //  TRANS  - CHARACTER*1. 
            //           On entry, TRANS specifies the operation to be performed as 
            //           follows: 

            //              TRANS = 'N' or 'n'   x := A*x. 

            //              TRANS = 'T' or 't'   x := A'*x. 

            //              TRANS = 'C' or 'c'   x := conjg( A' )*x. 

            //           Unchanged on exit. 

            //  DIAG   - CHARACTER*1. 
            //           On entry, DIAG specifies whether or not A is unit 
            //           triangular as follows: 

            //              DIAG = 'U' or 'u'   A is assumed to be unit triangular. 

            //              DIAG = 'N' or 'n'   A is not assumed to be unit 
            //                                  triangular. 

            //           Unchanged on exit. 

            //  N      - int. 
            //           On entry, N specifies the order of the matrix A. 
            //           N must be at least zero. 
            //           Unchanged on exit. 

            //  A      - COMPLEX*16       array of DIMENSION ( LDA, n ). 
            //           Before entry with  UPLO = 'U' or 'u', the leading n by n 
            //           upper triangular part of the array A must contain the upper 
            //           triangular matrix and the strictly lower triangular part of 
            //           A is not referenced. 
            //           Before entry with UPLO = 'L' or 'l', the leading n by n 
            //           lower triangular part of the array A must contain the lower 
            //           triangular matrix and the strictly upper triangular part of 
            //           A is not referenced. 
            //           Note that when  DIAG = 'U' or 'u', the diagonal elements of 
            //           A are not referenced either, but are assumed to be unity. 
            //           Unchanged on exit. 

            //  LDA    - int. 
            //           On entry, LDA specifies the first dimension of A as declared 
            //           in the calling (sub) program. LDA must be at least 
            //           max( 1, n ). 
            //           Unchanged on exit. 

            //  X      - COMPLEX*16       array of dimension at least 
            //           ( 1 + ( n - 1 )*abs( INCX ) ). 
            //           Before entry, the incremented array X must contain the n 
            //           element vector x. On exit, X is overwritten with the 
            //           tranformed vector x. 

            //  INCX   - int. 
            //           On entry, INCX specifies the increment for the elements of 
            //           X. INCX must not be zero. 
            //           Unchanged on exit. 


            //  Level 2 Blas routine. 

            //  -- Written on 22-October-1986. 
            //     Jack Dongarra, Argonne National Lab. 
            //     Jeremy Du Croz, Nag Central Office. 
            //     Sven Hammarling, Nag Central Office. 
            //     Richard Hanson, Sandia National Labs. 

            // System generated locals 
            int a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5;
            complex16 z__1, z__2, z__3;

            // Local variables 
            int i, j, ix, jx, kx = 0, info;
            complex16 temp;
            bool noconj, nounit;

            // Parameter adjustments 
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;
            --x;

            // Function Body 
            info = 0;
            if (!lsame(uplo, "U") && !lsame(uplo, "L"))
            {
                info = 1;
            }
            else if (!lsame(trans, "N") && !lsame(trans, "T") && !lsame(trans, "C"))
            {
                info = 2;
            }
            else if (!lsame(diag, "U") && !lsame(diag, "N"))
            {
                info = 3;
            }
            else if (*n < 0)
            {
                info = 4;
            }
            else if (*lda < Math.Max(1, *n))
            {
                info = 6;
            }
            else if (*incx == 0)
            {
                info = 8;
            }

            if (info != 0)
            {
                xerbla("ZTRMV ", &info);
                return 0;
            }

            // Quick return if possible. 

            if (*n == 0)
            {
                return 0;
            }

            noconj = lsame(trans, "T");
            nounit = lsame(diag, "N");

            // Set up the start point in X if the increment is not unity. This 
            // will be  ( N - 1 )*INCX  too small for descending loops. 

            if (*incx <= 0)
            {
                kx = 1 - (*n - 1) * *incx;
            }
            else if (*incx != 1)
            {
                kx = 1;
            }

            // Start the operations. In this version the elements of A are 
            // accessed sequentially with one pass through A. 

            if (lsame(trans, "N"))
            {
                // Form  x := A*x. 
                if (lsame(uplo, "U"))
                {
                    if (*incx == 1)
                    {
                        i__1 = *n;
                        for (j = 1; j <= i__1; ++j)
                        {
                            i__2 = j;

                            if (x[i__2].r != 0.0 || x[i__2].i != 0.0)
                            {
                                i__2 = j;
                                temp.r = x[i__2].r;
                                temp.i = x[i__2].i;
                                i__2 = j - 1;

                                for (i = 1; i <= i__2; ++i)
                                {
                                    i__3 = i;
                                    i__4 = i;
                                    i__5 = i + j * a_dim1;

                                    z__2.r = temp.r * a[i__5].r - temp.i * a[i__5].i;
                                    z__2.i = temp.r * a[i__5].i + temp.i * a[i__5].r;

                                    z__1.r = x[i__4].r + z__2.r;
                                    z__1.i = x[i__4].i + z__2.i;

                                    x[i__3].r = z__1.r;
                                    x[i__3].i = z__1.i;
                                }

                                if (nounit)
                                {
                                    i__2 = j;
                                    i__3 = j;
                                    i__4 = j + j * a_dim1;

                                    z__1.r = x[i__3].r * a[i__4].r - x[i__3].i * a[i__4].i;
                                    z__1.i = x[i__3].r * a[i__4].i + x[i__3].i * a[i__4].r;

                                    x[i__2].r = z__1.r;
                                    x[i__2].i = z__1.i;
                                }
                            }
                        }
                    }
                    else
                    {
                        jx = kx;
                        i__1 = *n;

                        for (j = 1; j <= i__1; ++j)
                        {
                            i__2 = jx;

                            if (x[i__2].r != 0.0 || x[i__2].i != 0.0)
                            {
                                i__2 = jx;

                                temp.r = x[i__2].r;
                                temp.i = x[i__2].i;

                                ix = kx;
                                i__2 = j - 1;

                                for (i = 1; i <= i__2; ++i)
                                {
                                    i__3 = ix;
                                    i__4 = ix;
                                    i__5 = i + j * a_dim1;

                                    z__2.r = temp.r * a[i__5].r - temp.i * a[i__5].i;
                                    z__2.i = temp.r * a[i__5].i + temp.i * a[i__5].r;

                                    z__1.r = x[i__4].r + z__2.r;
                                    z__1.i = x[i__4].i + z__2.i;

                                    x[i__3].r = z__1.r;
                                    x[i__3].i = z__1.i;

                                    ix += *incx;
                                }

                                if (nounit)
                                {
                                    i__2 = jx;
                                    i__3 = jx;
                                    i__4 = j + j * a_dim1;

                                    z__1.r = x[i__3].r * a[i__4].r - x[i__3].i * a[i__4].i;
                                    z__1.i = x[i__3].r * a[i__4].i + x[i__3].i * a[i__4].r;

                                    x[i__2].r = z__1.r;
                                    x[i__2].i = z__1.i;
                                }
                            }
                            jx += *incx;
                        }
                    }
                }
                else
                {
                    if (*incx == 1)
                    {
                        for (j = *n; j >= 1; --j)
                        {
                            i__1 = j;
                            if (x[i__1].r != 0.0 || x[i__1].i != 0.0)
                            {
                                i__1 = j;

                                temp.r = x[i__1].r;
                                temp.i = x[i__1].i;

                                i__1 = j + 1;
                                for (i = *n; i >= i__1; --i)
                                {
                                    i__2 = i;
                                    i__3 = i;
                                    i__4 = i + j * a_dim1;

                                    z__2.r = temp.r * a[i__4].r - temp.i * a[i__4].i;
                                    z__2.i = temp.r * a[i__4].i + temp.i * a[i__4].r;

                                    z__1.r = x[i__3].r + z__2.r;
                                    z__1.i = x[i__3].i + z__2.i;

                                    x[i__2].r = z__1.r;
                                    x[i__2].i = z__1.i;
                                }

                                if (nounit)
                                {
                                    i__1 = j;
                                    i__2 = j;
                                    i__3 = j + j * a_dim1;

                                    z__1.r = x[i__2].r * a[i__3].r - x[i__2].i * a[i__3].i;
                                    z__1.i = x[i__2].r * a[i__3].i + x[i__2].i * a[i__3].r;

                                    x[i__1].r = z__1.r;
                                    x[i__1].i = z__1.i;
                                }
                            }
                        }
                    }
                    else
                    {
                        kx += (*n - 1) * *incx;
                        jx = kx;

                        for (j = *n; j >= 1; --j)
                        {
                            i__1 = jx;
                            if (x[i__1].r != 0.0 || x[i__1].i != 0.0)
                            {
                                i__1 = jx;

                                temp.r = x[i__1].r;
                                temp.i = x[i__1].i;

                                ix = kx;
                                i__1 = j + 1;

                                for (i = *n; i >= i__1; --i)
                                {
                                    i__2 = ix;
                                    i__3 = ix;
                                    i__4 = i + j * a_dim1;

                                    z__2.r = temp.r * a[i__4].r - temp.i * a[i__4].i;
                                    z__2.i = temp.r * a[i__4].i + temp.i * a[i__4].r;

                                    z__1.r = x[i__3].r + z__2.r;
                                    z__1.i = x[i__3].i + z__2.i;

                                    x[i__2].r = z__1.r;
                                    x[i__2].i = z__1.i;
                                    ix -= *incx;
                                }

                                if (nounit)
                                {
                                    i__1 = jx;
                                    i__2 = jx;
                                    i__3 = j + j * a_dim1;

                                    z__1.r = x[i__2].r * a[i__3].r - x[i__2].i * a[i__3].i;
                                    z__1.i = x[i__2].r * a[i__3].i + x[i__2].i * a[i__3].r;

                                    x[i__1].r = z__1.r;
                                    x[i__1].i = z__1.i;
                                }
                            }
                            jx -= *incx;
                        }
                    }
                }
            }
            else
            {
                // Form  x := A'*x  or  x := conjg( A' )*x. 
                if (lsame(uplo, "U"))
                {
                    if (*incx == 1)
                    {
                        for (j = *n; j >= 1; --j)
                        {
                            i__1 = j;

                            temp.r = x[i__1].r;
                            temp.i = x[i__1].i;

                            if (noconj)
                            {
                                if (nounit)
                                {
                                    i__1 = j + j * a_dim1;

                                    z__1.r = temp.r * a[i__1].r - temp.i * a[i__1].i;
                                    z__1.i = temp.r * a[i__1].i + temp.i * a[i__1].r;

                                    temp.r = z__1.r;
                                    temp.i = z__1.i;
                                }

                                for (i = j - 1; i >= 1; --i)
                                {
                                    i__1 = i + j * a_dim1;
                                    i__2 = i;
                                    z__2.r = a[i__1].r * x[i__2].r - a[i__1].i * x[i__2].i;
                                    z__2.i = a[i__1].r * x[i__2].i + a[i__1].i * x[i__2].r;

                                    z__1.r = temp.r + z__2.r;
                                    z__1.i = temp.i + z__2.i;

                                    temp.r = z__1.r;
                                    temp.i = z__1.i;
                                }
                            }
                            else
                            {
                                if (nounit)
                                {
                                    d_cnjg(&z__2, &a[j + j * a_dim1]);

                                    z__1.r = temp.r * z__2.r - temp.i * z__2.i;
                                    z__1.i = temp.r * z__2.i + temp.i * z__2.r;

                                    temp.r = z__1.r;
                                    temp.i = z__1.i;
                                }

                                for (i = j - 1; i >= 1; --i)
                                {
                                    d_cnjg(&z__3, &a[i + j * a_dim1]);
                                    i__1 = i;

                                    z__2.r = z__3.r * x[i__1].r - z__3.i * x[i__1].i;
                                    z__2.i = z__3.r * x[i__1].i + z__3.i * x[i__1].r;

                                    z__1.r = temp.r + z__2.r;
                                    z__1.i = temp.i + z__2.i;

                                    temp.r = z__1.r;
                                    temp.i = z__1.i;
                                }
                            }

                            i__1 = j;
                            x[i__1].r = temp.r;
                            x[i__1].i = temp.i;
                        }
                    }
                    else
                    {
                        jx = kx + (*n - 1) * *incx;

                        for (j = *n; j >= 1; --j)
                        {
                            i__1 = jx;

                            temp.r = x[i__1].r;
                            temp.i = x[i__1].i;

                            ix = jx;
                            if (noconj)
                            {
                                if (nounit)
                                {
                                    i__1 = j + j * a_dim1;

                                    z__1.r = temp.r * a[i__1].r - temp.i * a[i__1].i;
                                    z__1.i = temp.r * a[i__1].i + temp.i * a[i__1].r;

                                    temp.r = z__1.r;
                                    temp.i = z__1.i;
                                }

                                for (i = j - 1; i >= 1; --i)
                                {
                                    ix -= *incx;
                                    i__1 = i + j * a_dim1;
                                    i__2 = ix;

                                    z__2.r = a[i__1].r * x[i__2].r - a[i__1].i * x[i__2].i;
                                    z__2.i = a[i__1].r * x[i__2].i + a[i__1].i * x[i__2].r;

                                    z__1.r = temp.r + z__2.r;
                                    z__1.i = temp.i + z__2.i;

                                    temp.r = z__1.r;
                                    temp.i = z__1.i;
                                }
                            }
                            else
                            {
                                if (nounit)
                                {
                                    d_cnjg(&z__2, &a[j + j * a_dim1]);

                                    z__1.r = temp.r * z__2.r - temp.i * z__2.i;
                                    z__1.i = temp.r * z__2.i + temp.i * z__2.r;

                                    temp.r = z__1.r;
                                    temp.i = z__1.i;
                                }

                                for (i = j - 1; i >= 1; --i)
                                {
                                    ix -= *incx;
                                    d_cnjg(&z__3, &a[i + j * a_dim1]);
                                    i__1 = ix;

                                    z__2.r = z__3.r * x[i__1].r - z__3.i * x[i__1].i;
                                    z__2.i = z__3.r * x[i__1].i + z__3.i * x[i__1].r;

                                    z__1.r = temp.r + z__2.r;
                                    z__1.i = temp.i + z__2.i;

                                    temp.r = z__1.r;
                                    temp.i = z__1.i;
                                }
                            }
                            i__1 = jx;

                            x[i__1].r = temp.r;
                            x[i__1].i = temp.i;

                            jx -= *incx;
                        }
                    }
                }
                else
                {
                    if (*incx == 1)
                    {
                        i__1 = *n;

                        for (j = 1; j <= i__1; ++j)
                        {
                            i__2 = j;

                            temp.r = x[i__2].r;
                            temp.i = x[i__2].i;

                            if (noconj)
                            {
                                if (nounit)
                                {
                                    i__2 = j + j * a_dim1;

                                    z__1.r = temp.r * a[i__2].r - temp.i * a[i__2].i;
                                    z__1.i = temp.r * a[i__2].i + temp.i * a[i__2].r;

                                    temp.r = z__1.r;
                                    temp.i = z__1.i;
                                }

                                i__2 = *n;

                                for (i = j + 1; i <= i__2; ++i)
                                {
                                    i__3 = i + j * a_dim1;
                                    i__4 = i;

                                    z__2.r = a[i__3].r * x[i__4].r - a[i__3].i * x[i__4].i;
                                    z__2.i = a[i__3].r * x[i__4].i + a[i__3].i * x[i__4].r;

                                    z__1.r = temp.r + z__2.r;
                                    z__1.i = temp.i + z__2.i;

                                    temp.r = z__1.r;
                                    temp.i = z__1.i;
                                }
                            }
                            else
                            {
                                if (nounit)
                                {
                                    d_cnjg(&z__2, &a[j + j * a_dim1]);

                                    z__1.r = temp.r * z__2.r - temp.i * z__2.i;
                                    z__1.i = temp.r * z__2.i + temp.i * z__2.r;

                                    temp.r = z__1.r;
                                    temp.i = z__1.i;
                                }

                                i__2 = *n;

                                for (i = j + 1; i <= i__2; ++i)
                                {
                                    d_cnjg(&z__3, &a[i + j * a_dim1]);
                                    i__3 = i;

                                    z__2.r = z__3.r * x[i__3].r - z__3.i * x[i__3].i;
                                    z__2.i = z__3.r * x[i__3].i + z__3.i * x[i__3].r;

                                    z__1.r = temp.r + z__2.r;
                                    z__1.i = temp.i + z__2.i;

                                    temp.r = z__1.r;
                                    temp.i = z__1.i;
                                }
                            }

                            i__2 = j;

                            x[i__2].r = temp.r;
                            x[i__2].i = temp.i;
                        }
                    }
                    else
                    {
                        jx = kx;
                        i__1 = *n;

                        for (j = 1; j <= i__1; ++j)
                        {
                            i__2 = jx;

                            temp.r = x[i__2].r;
                            temp.i = x[i__2].i;

                            ix = jx;

                            if (noconj)
                            {
                                if (nounit)
                                {
                                    i__2 = j + j * a_dim1;

                                    z__1.r = temp.r * a[i__2].r - temp.i * a[i__2].i;
                                    z__1.i = temp.r * a[i__2].i + temp.i * a[i__2].r;

                                    temp.r = z__1.r;
                                    temp.i = z__1.i;
                                }

                                i__2 = *n;

                                for (i = j + 1; i <= i__2; ++i)
                                {
                                    ix += *incx;
                                    i__3 = i + j * a_dim1;
                                    i__4 = ix;

                                    z__2.r = a[i__3].r * x[i__4].r - a[i__3].i * x[i__4].i;
                                    z__2.i = a[i__3].r * x[i__4].i + a[i__3].i * x[i__4].r;

                                    z__1.r = temp.r + z__2.r;
                                    z__1.i = temp.i + z__2.i;

                                    temp.r = z__1.r;
                                    temp.i = z__1.i;
                                }
                            }
                            else
                            {
                                if (nounit)
                                {
                                    d_cnjg(&z__2, &a[j + j * a_dim1]);

                                    z__1.r = temp.r * z__2.r - temp.i * z__2.i;
                                    z__1.i = temp.r * z__2.i + temp.i * z__2.r;

                                    temp.r = z__1.r;
                                    temp.i = z__1.i;
                                }

                                i__2 = *n;

                                for (i = j + 1; i <= i__2; ++i)
                                {
                                    ix += *incx;
                                    d_cnjg(&z__3, &a[i + j * a_dim1]);
                                    i__3 = ix;

                                    z__2.r = z__3.r * x[i__3].r - z__3.i * x[i__3].i;
                                    z__2.i = z__3.r * x[i__3].i + z__3.i * x[i__3].r;

                                    z__1.r = temp.r + z__2.r;
                                    z__1.i = temp.i + z__2.i;

                                    temp.r = z__1.r;
                                    temp.i = z__1.i;
                                }
                            }
                            i__2 = jx;

                            x[i__2].r = temp.r;
                            x[i__2].i = temp.i;
                            jx += *incx;

                        }
                    }
                }
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int ztrsv(string uplo, string trans, string diag,
            int* n, complex16* a, int* lda, complex16* x, int* incx)
        {
            //  Purpose 
            //  ======= 

            //  ZTRSV  solves one of the systems of equations 

            //     A*x = b,   or   A'*x = b,   or   conjg( A' )*x = b, 

            //  where b and x are n element vectors and A is an n by n unit, or 
            //  non-unit, upper or lower triangular matrix. 

            //  No test for singularity or near-singularity is included in this 
            //  routine. Such tests must be performed before calling this routine. 

            //  Arguments 
            //  ========== 

            //  UPLO   - CHARACTER*1. 
            //           On entry, UPLO specifies whether the matrix is an upper or 
            //           lower triangular matrix as follows: 

            //              UPLO = 'U' or 'u'   A is an upper triangular matrix. 

            //              UPLO = 'L' or 'l'   A is a lower triangular matrix. 

            //           Unchanged on exit. 

            //  TRANS  - CHARACTER*1. 
            //           On entry, TRANS specifies the equations to be solved as 
            //           follows: 

            //              TRANS = 'N' or 'n'   A*x = b. 

            //              TRANS = 'T' or 't'   A'*x = b. 

            //              TRANS = 'C' or 'c'   conjg( A' )*x = b. 

            //           Unchanged on exit. 

            //  DIAG   - CHARACTER*1. 
            //           On entry, DIAG specifies whether or not A is unit 
            //           triangular as follows: 

            //              DIAG = 'U' or 'u'   A is assumed to be unit triangular. 

            //              DIAG = 'N' or 'n'   A is not assumed to be unit 
            //                                  triangular. 

            //           Unchanged on exit. 

            //  N      - int. 
            //           On entry, N specifies the order of the matrix A. 
            //           N must be at least zero. 
            //           Unchanged on exit. 

            //  A      - COMPLEX*16       array of DIMENSION ( LDA, n ). 
            //           Before entry with  UPLO = 'U' or 'u', the leading n by n 
            //           upper triangular part of the array A must contain the upper 
            //           triangular matrix and the strictly lower triangular part of 
            //           A is not referenced. 
            //           Before entry with UPLO = 'L' or 'l', the leading n by n 
            //           lower triangular part of the array A must contain the lower 
            //           triangular matrix and the strictly upper triangular part of 
            //           A is not referenced. 
            //           Note that when  DIAG = 'U' or 'u', the diagonal elements of 
            //           A are not referenced either, but are assumed to be unity. 
            //           Unchanged on exit. 

            //  LDA    - int. 
            //           On entry, LDA specifies the first dimension of A as declared 
            //           in the calling (sub) program. LDA must be at least 
            //           max( 1, n ). 
            //           Unchanged on exit. 

            //  X      - COMPLEX*16       array of dimension at least 
            //           ( 1 + ( n - 1 )*abs( INCX ) ). 
            //           Before entry, the incremented array X must contain the n 
            //           element right-hand side vector b. On exit, X is overwritten 
            //           with the solution vector x. 

            //  INCX   - int. 
            //           On entry, INCX specifies the increment for the elements of 
            //           X. INCX must not be zero. 
            //           Unchanged on exit. 


            //  Level 2 Blas routine. 

            //  -- Written on 22-October-1986. 
            //     Jack Dongarra, Argonne National Lab. 
            //     Jeremy Du Croz, Nag Central Office. 
            //     Sven Hammarling, Nag Central Office. 
            //     Richard Hanson, Sandia National Labs.  

            // System generated locals 
            int a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5;
            complex16 z__1, z__2, z__3;

            // Local variables 
            int i, j, ix, jx, kx = 0, info;
            complex16 temp;
            bool noconj, nounit;

            // Parameter adjustments 
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;
            --x;

            // Function Body 
            info = 0;
            if (!lsame(uplo, "U") && !lsame(uplo, "L"))
            {
                info = 1;
            }
            else if (!lsame(trans, "N") && !lsame(trans, "T") && !lsame(trans, "C"))
            {
                info = 2;
            }
            else if (!lsame(diag, "U") && !lsame(diag, "N"))
            {
                info = 3;
            }
            else if (*n < 0)
            {
                info = 4;
            }
            else if (*lda < Math.Max(1, *n))
            {
                info = 6;
            }
            else if (*incx == 0)
            {
                info = 8;
            }

            if (info != 0)
            {
                xerbla("ZTRSV ", &info);
                return 0;
            }

            // Quick return if possible. 

            if (*n == 0)
            {
                return 0;
            }

            noconj = lsame(trans, "T");
            nounit = lsame(diag, "N");

            // Set up the start point in X if the increment is not unity. This 
            // will be  ( N - 1 )*INCX  too small for descending loops. 

            if (*incx <= 0)
            {
                kx = 1 - (*n - 1) * *incx;
            }
            else if (*incx != 1)
            {
                kx = 1;
            }

            // Start the operations. In this version the elements of A are 
            // accessed sequentially with one pass through A. 

            if (lsame(trans, "N"))
            {
                // Form  x := inv( A )*x. 

                if (lsame(uplo, "U"))
                {
                    if (*incx == 1)
                    {
                        for (j = *n; j >= 1; --j)
                        {
                            i__1 = j;

                            if (x[i__1].r != 0.0 || x[i__1].i != 0.0)
                            {
                                if (nounit)
                                {
                                    i__1 = j;
                                    z_div(&z__1, &x[j], &a[j + j * a_dim1]);

                                    x[i__1].r = z__1.r;
                                    x[i__1].i = z__1.i;
                                }

                                i__1 = j;

                                temp.r = x[i__1].r;
                                temp.i = x[i__1].i;

                                for (i = j - 1; i >= 1; --i)
                                {
                                    i__1 = i;
                                    i__2 = i;
                                    i__3 = i + j * a_dim1;

                                    z__2.r = temp.r * a[i__3].r - temp.i * a[i__3].i;
                                    z__2.i = temp.r * a[i__3].i + temp.i * a[i__3].r;

                                    z__1.r = x[i__2].r - z__2.r;
                                    z__1.i = x[i__2].i - z__2.i;

                                    x[i__1].r = z__1.r;
                                    x[i__1].i = z__1.i;
                                }
                            }
                        }
                    }
                    else
                    {
                        jx = kx + (*n - 1) * *incx;
                        for (j = *n; j >= 1; --j)
                        {
                            i__1 = jx;
                            if (x[i__1].r != 0.0 || x[i__1].i != 0.0)
                            {
                                if (nounit)
                                {
                                    i__1 = jx;
                                    z_div(&z__1, &x[jx], &a[j + j * a_dim1]);

                                    x[i__1].r = z__1.r;
                                    x[i__1].i = z__1.i;
                                }
                                i__1 = jx;

                                temp.r = x[i__1].r;
                                temp.i = x[i__1].i;

                                ix = jx;
                                for (i = j - 1; i >= 1; --i)
                                {
                                    ix -= *incx;
                                    i__1 = ix;
                                    i__2 = ix;
                                    i__3 = i + j * a_dim1;

                                    z__2.r = temp.r * a[i__3].r - temp.i * a[i__3].i;
                                    z__2.i = temp.r * a[i__3].i + temp.i * a[i__3].r;

                                    z__1.r = x[i__2].r - z__2.r;
                                    z__1.i = x[i__2].i - z__2.i;

                                    x[i__1].r = z__1.r;
                                    x[i__1].i = z__1.i;
                                }
                            }

                            jx -= *incx;
                        }
                    }
                }
                else
                {
                    if (*incx == 1)
                    {
                        i__1 = *n;
                        for (j = 1; j <= i__1; ++j)
                        {
                            i__2 = j;
                            if (x[i__2].r != 0.0 || x[i__2].i != 0.0)
                            {
                                if (nounit)
                                {
                                    i__2 = j;
                                    z_div(&z__1, &x[j], &a[j + j * a_dim1]);

                                    x[i__2].r = z__1.r;
                                    x[i__2].i = z__1.i;
                                }

                                i__2 = j;

                                temp.r = x[i__2].r;
                                temp.i = x[i__2].i;

                                i__2 = *n;
                                for (i = j + 1; i <= i__2; ++i)
                                {
                                    i__3 = i;
                                    i__4 = i;
                                    i__5 = i + j * a_dim1;

                                    z__2.r = temp.r * a[i__5].r - temp.i * a[i__5].i;
                                    z__2.i = temp.r * a[i__5].i + temp.i * a[i__5].r;

                                    z__1.r = x[i__4].r - z__2.r;
                                    z__1.i = x[i__4].i - z__2.i;

                                    x[i__3].r = z__1.r;
                                    x[i__3].i = z__1.i;
                                }
                            }
                        }
                    }
                    else
                    {
                        jx = kx;
                        i__1 = *n;

                        for (j = 1; j <= i__1; ++j)
                        {
                            i__2 = jx;
                            if (x[i__2].r != 0.0 || x[i__2].i != 0.0)
                            {
                                if (nounit)
                                {
                                    i__2 = jx;
                                    z_div(&z__1, &x[jx], &a[j + j * a_dim1]);

                                    x[i__2].r = z__1.r;
                                    x[i__2].i = z__1.i;
                                }

                                i__2 = jx;

                                temp.r = x[i__2].r;
                                temp.i = x[i__2].i;

                                ix = jx;
                                i__2 = *n;

                                for (i = j + 1; i <= i__2; ++i)
                                {
                                    ix += *incx;
                                    i__3 = ix;
                                    i__4 = ix;
                                    i__5 = i + j * a_dim1;

                                    z__2.r = temp.r * a[i__5].r - temp.i * a[i__5].i;
                                    z__2.i = temp.r * a[i__5].i + temp.i * a[i__5].r;

                                    z__1.r = x[i__4].r - z__2.r;
                                    z__1.i = x[i__4].i - z__2.i;

                                    x[i__3].r = z__1.r;
                                    x[i__3].i = z__1.i;
                                }
                            }
                            jx += *incx;
                        }
                    }
                }
            }
            else
            {
                // Form  x := inv( A' )*x  or  x := inv( conjg( A' ) )*x. 

                if (lsame(uplo, "U"))
                {
                    if (*incx == 1)
                    {
                        i__1 = *n;

                        for (j = 1; j <= i__1; ++j)
                        {
                            i__2 = j;

                            temp.r = x[i__2].r;
                            temp.i = x[i__2].i;

                            if (noconj)
                            {
                                i__2 = j - 1;

                                for (i = 1; i <= i__2; ++i)
                                {
                                    i__3 = i + j * a_dim1;
                                    i__4 = i;

                                    z__2.r = a[i__3].r * x[i__4].r - a[i__3].i * x[i__4].i;
                                    z__2.i = a[i__3].r * x[i__4].i + a[i__3].i * x[i__4].r;

                                    z__1.r = temp.r - z__2.r;
                                    z__1.i = temp.i - z__2.i;

                                    temp.r = z__1.r;
                                    temp.i = z__1.i;
                                }

                                if (nounit)
                                {
                                    z_div(&z__1, &temp, &a[j + j * a_dim1]);

                                    temp.r = z__1.r;
                                    temp.i = z__1.i;
                                }
                            }
                            else
                            {
                                i__2 = j - 1;

                                for (i = 1; i <= i__2; ++i)
                                {
                                    d_cnjg(&z__3, &a[i + j * a_dim1]);
                                    i__3 = i;

                                    z__2.r = z__3.r * x[i__3].r - z__3.i * x[i__3].i;
                                    z__2.i = z__3.r * x[i__3].i + z__3.i * x[i__3].r;

                                    z__1.r = temp.r - z__2.r;
                                    z__1.i = temp.i - z__2.i;

                                    temp.r = z__1.r;
                                    temp.i = z__1.i;
                                }

                                if (nounit)
                                {
                                    d_cnjg(&z__2, &a[j + j * a_dim1]);
                                    z_div(&z__1, &temp, &z__2);
                                    temp.r = z__1.r;
                                    temp.i = z__1.i;
                                }
                            }

                            i__2 = j;

                            x[i__2].r = temp.r;
                            x[i__2].i = temp.i;
                        }
                    }
                    else
                    {
                        jx = kx;
                        i__1 = *n;

                        for (j = 1; j <= i__1; ++j)
                        {
                            ix = kx;
                            i__2 = jx;

                            temp.r = x[i__2].r;
                            temp.i = x[i__2].i;

                            if (noconj)
                            {
                                i__2 = j - 1;
                                for (i = 1; i <= i__2; ++i)
                                {
                                    i__3 = i + j * a_dim1;
                                    i__4 = ix;

                                    z__2.r = a[i__3].r * x[i__4].r - a[i__3].i * x[i__4].i;
                                    z__2.i = a[i__3].r * x[i__4].i + a[i__3].i * x[i__4].r;

                                    z__1.r = temp.r - z__2.r;
                                    z__1.i = temp.i - z__2.i;

                                    temp.r = z__1.r;
                                    temp.i = z__1.i;

                                    ix += *incx;
                                }

                                if (nounit)
                                {
                                    z_div(&z__1, &temp, &a[j + j * a_dim1]);

                                    temp.r = z__1.r;
                                    temp.i = z__1.i;
                                }
                            }
                            else
                            {
                                i__2 = j - 1;
                                for (i = 1; i <= i__2; ++i)
                                {
                                    d_cnjg(&z__3, &a[i + j * a_dim1]);
                                    i__3 = ix;

                                    z__2.r = z__3.r * x[i__3].r - z__3.i * x[i__3].i;
                                    z__2.i = z__3.r * x[i__3].i + z__3.i * x[i__3].r;

                                    z__1.r = temp.r - z__2.r;
                                    z__1.i = temp.i - z__2.i;

                                    temp.r = z__1.r;
                                    temp.i = z__1.i;
                                    ix += *incx;
                                }

                                if (nounit)
                                {
                                    d_cnjg(&z__2, &a[j + j * a_dim1]);
                                    z_div(&z__1, &temp, &z__2);

                                    temp.r = z__1.r;
                                    temp.i = z__1.i;
                                }
                            }

                            i__2 = jx;
                            x[i__2].r = temp.r;
                            x[i__2].i = temp.i;
                            jx += *incx;
                        }
                    }
                }
                else
                {
                    if (*incx == 1)
                    {
                        for (j = *n; j >= 1; --j)
                        {
                            i__1 = j;

                            temp.r = x[i__1].r;
                            temp.i = x[i__1].i;

                            if (noconj)
                            {
                                i__1 = j + 1;
                                for (i = *n; i >= i__1; --i)
                                {
                                    i__2 = i + j * a_dim1;
                                    i__3 = i;

                                    z__2.r = a[i__2].r * x[i__3].r - a[i__2].i * x[i__3].i;
                                    z__2.i = a[i__2].r * x[i__3].i + a[i__2].i * x[i__3].r;

                                    z__1.r = temp.r - z__2.r;
                                    z__1.i = temp.i - z__2.i;

                                    temp.r = z__1.r;
                                    temp.i = z__1.i;
                                }

                                if (nounit)
                                {
                                    z_div(&z__1, &temp, &a[j + j * a_dim1]);

                                    temp.r = z__1.r;
                                    temp.i = z__1.i;
                                }
                            }
                            else
                            {
                                i__1 = j + 1;
                                for (i = *n; i >= i__1; --i)
                                {
                                    d_cnjg(&z__3, &a[i + j * a_dim1]);
                                    i__2 = i;
                                    z__2.r = z__3.r * x[i__2].r - z__3.i * x[i__2].i;
                                    z__2.i = z__3.r * x[i__2].i + z__3.i * x[i__2].r;

                                    z__1.r = temp.r - z__2.r;
                                    z__1.i = temp.i - z__2.i;

                                    temp.r = z__1.r;
                                    temp.i = z__1.i;
                                }

                                if (nounit)
                                {
                                    d_cnjg(&z__2, &a[j + j * a_dim1]);
                                    z_div(&z__1, &temp, &z__2);

                                    temp.r = z__1.r;
                                    temp.i = z__1.i;
                                }
                            }

                            i__1 = j;

                            x[i__1].r = temp.r;
                            x[i__1].i = temp.i;
                        }
                    }
                    else
                    {
                        kx += (*n - 1) * *incx;
                        jx = kx;

                        for (j = *n; j >= 1; --j)
                        {
                            ix = kx;
                            i__1 = jx;

                            temp.r = x[i__1].r;
                            temp.i = x[i__1].i;

                            if (noconj)
                            {
                                i__1 = j + 1;

                                for (i = *n; i >= i__1; --i)
                                {
                                    i__2 = i + j * a_dim1;
                                    i__3 = ix;

                                    z__2.r = a[i__2].r * x[i__3].r - a[i__2].i * x[i__3].i;
                                    z__2.i = a[i__2].r * x[i__3].i + a[i__2].i * x[i__3].r;

                                    z__1.r = temp.r - z__2.r;
                                    z__1.i = temp.i - z__2.i;

                                    temp.r = z__1.r;
                                    temp.i = z__1.i;

                                    ix -= *incx;
                                }

                                if (nounit)
                                {
                                    z_div(&z__1, &temp, &a[j + j * a_dim1]);

                                    temp.r = z__1.r;
                                    temp.i = z__1.i;
                                }
                            }
                            else
                            {
                                i__1 = j + 1;
                                for (i = *n; i >= i__1; --i)
                                {
                                    d_cnjg(&z__3, &a[i + j * a_dim1]);
                                    i__2 = ix;
                                    z__2.r = z__3.r * x[i__2].r - z__3.i * x[i__2].i;
                                    z__2.i = z__3.r * x[i__2].i + z__3.i * x[i__2].r;

                                    z__1.r = temp.r - z__2.r;
                                    z__1.i = temp.i - z__2.i;

                                    temp.r = z__1.r;
                                    temp.i = z__1.i;

                                    ix -= *incx;
                                }

                                if (nounit)
                                {
                                    d_cnjg(&z__2, &a[j + j * a_dim1]);
                                    z_div(&z__1, &temp, &z__2);

                                    temp.r = z__1.r;
                                    temp.i = z__1.i;
                                }
                            }

                            i__1 = jx;

                            x[i__1].r = temp.r;
                            x[i__1].i = temp.i;
                            jx -= *incx;
                        }
                    }
                }
            }

            return 0;
        }

        #endregion

        #region lapack

        #region Double precision real routines

        [SuppressUnmanagedCodeSecurity]
        public static int dbdsdc(string uplo, string compq, int* n, double* d, double* e,
            double* u, int* ldu, double* vt, int* ldvt, double* q, int* iq, double* work, int* iwork, int* info)
        {
            //  -- LAPACK routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     November 2006

            //  Purpose
            //  =======

            //  DBDSDC computes the singular value decomposition (SVD) of a real
            //  N-by-N (upper or lower) bidiagonal matrix B:  B = U * S * VT,
            //  using a divide and conquer method, where S is a diagonal matrix
            //  with non-negative diagonal elements (the singular values of B), and
            //  U and VT are orthogonal matrices of left and right singular vectors,
            //  respectively. DBDSDC can be used to compute all singular values,
            //  and optionally, singular vectors or singular vectors in compact form.

            //  This code makes very mild assumptions about floating point
            //  arithmetic. It will work on machines with a guard digit in
            //  add/subtract, or on those binary machines without guard digits
            //  which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
            //  It could conceivably fail on hexadecimal or decimal machines
            //  without guard digits, but we know of none.  See DLASD3 for details.

            //  The code currently calls DLASDQ if singular values only are desired.
            //  However, it can be slightly modified to compute singular values
            //  using the divide and conquer method.

            //  Arguments
            //  =========

            //  UPLO    (input) CHARACTER*1
            //          = 'U':  B is upper bidiagonal.
            //          = 'L':  B is lower bidiagonal.

            //  COMPQ   (input) CHARACTER*1
            //          Specifies whether singular vectors are to be computed
            //          as follows:
            //          = 'N':  Compute singular values only;
            //          = 'P':  Compute singular values and compute singular
            //                  vectors in compact form;
            //          = 'I':  Compute singular values and singular vectors.

            //  N       (input) int
            //          The order of the matrix B.  N >= 0.

            //  D       (input/output) DOUBLE PRECISION array, dimension (N)
            //          On entry, the n diagonal elements of the bidiagonal matrix B.
            //          On exit, if INFO=0, the singular values of B.

            //  E       (input/output) DOUBLE PRECISION array, dimension (N-1)
            //          On entry, the elements of E contain the offdiagonal
            //          elements of the bidiagonal matrix whose SVD is desired.
            //          On exit, E has been destroyed.

            //  U       (output) DOUBLE PRECISION array, dimension (LDU,N)
            //          If  COMPQ = 'I', then:
            //             On exit, if INFO = 0, U contains the left singular vectors
            //             of the bidiagonal matrix.
            //          For other values of COMPQ, U is not referenced.

            //  LDU     (input) int
            //          The leading dimension of the array U.  LDU >= 1.
            //          If singular vectors are desired, then LDU >= max( 1, N ).

            //  VT      (output) DOUBLE PRECISION array, dimension (LDVT,N)
            //          If  COMPQ = 'I', then:
            //             On exit, if INFO = 0, VT' contains the right singular
            //             vectors of the bidiagonal matrix.
            //          For other values of COMPQ, VT is not referenced.

            //  LDVT    (input) int
            //          The leading dimension of the array VT.  LDVT >= 1.
            //          If singular vectors are desired, then LDVT >= max( 1, N ).

            //  Q       (output) DOUBLE PRECISION array, dimension (LDQ)
            //          If  COMPQ = 'P', then:
            //             On exit, if INFO = 0, Q and IQ contain the left
            //             and right singular vectors in a compact form,
            //             requiring O(N log N) space instead of 2*N**2.
            //             In particular, Q contains all the DOUBLE PRECISION data in
            //             LDQ >= N*(11 + 2*SMLSIZ + 8*INT(LOG_2(N/(SMLSIZ+1))))
            //             words of memory, where SMLSIZ is returned by ILAENV and
            //             is equal to the maximum size of the subproblems at the
            //             bottom of the computation tree (usually about 25).
            //          For other values of COMPQ, Q is not referenced.

            //  IQ      (output) int array, dimension (LDIQ)
            //          If  COMPQ = 'P', then:
            //             On exit, if INFO = 0, Q and IQ contain the left
            //             and right singular vectors in a compact form,
            //             requiring O(N log N) space instead of 2*N**2.
            //             In particular, IQ contains all int data in
            //             LDIQ >= N*(3 + 3*INT(LOG_2(N/(SMLSIZ+1))))
            //             words of memory, where SMLSIZ is returned by ILAENV and
            //             is equal to the maximum size of the subproblems at the
            //             bottom of the computation tree (usually about 25).
            //          For other values of COMPQ, IQ is not referenced.

            //  WORK    (workspace) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            //          If COMPQ = 'N' then LWORK >= (4 * N).
            //          If COMPQ = 'P' then LWORK >= (6 * N).
            //          If COMPQ = 'I' then LWORK >= (3 * N**2 + 4 * N).

            //  IWORK   (workspace) int array, dimension (8*N)

            //  INFO    (output) int
            //          = 0:  successful exit.
            //          < 0:  if INFO = -i, the i-th argument had an illegal value.
            //          > 0:  The algorithm failed to compute an singular value.
            //                The update process of divide and conquer failed.

            //  Further Details
            //  ===============

            //  Based on contributions by
            //     Ming Gu and Huan Ren, Computer Science Division, University of
            //     California at Berkeley, USA

            //  =====================================================================
            //  Changed dimension statement in comment describing E from (N) to
            //  (N-1).  Sven, 17 Feb 05.
            //  =====================================================================

            // System generated locals
            int u_dim1, u_offset, vt_dim1, vt_offset, i__1, i__2;

            // Table of constant values
            int c__9 = 9;
            int c__0 = 0;
            double c_b15 = 1.0;
            int c__1 = 1;
            double c_b29 = 0.0;

            // Local variables
            int i, j, k = 0;
            double p, r;
            int z = 0, ic = 0, ii, kk;
            double cs;
            int is_ = 0, iu = 0;
            double sn;
            int nm1;
            double eps;
            int ivt = 0, difl = 0, difr = 0, ierr, perm = 0, mlvl, sqre;
            int poles = 0, iuplo, nsize, start;
            int givcol = 0;
            int icompq;
            double orgnrm;
            int givnum = 0, givptr = 0, qstart, smlsiz, wstart, smlszp;

            // Parameter adjustments
            --d;
            --e;
            u_dim1 = *ldu;
            u_offset = 1 + u_dim1;
            u -= u_offset;
            vt_dim1 = *ldvt;
            vt_offset = 1 + vt_dim1;
            vt -= vt_offset;
            --q;
            --iq;
            --work;
            --iwork;

            // Function Body
            *info = 0;

            iuplo = 0;
            if (lsame(uplo, "U"))
            {
                iuplo = 1;
            }
            if (lsame(uplo, "L"))
            {
                iuplo = 2;
            }
            if (lsame(compq, "N"))
            {
                icompq = 0;
            }
            else if (lsame(compq, "P"))
            {
                icompq = 1;
            }
            else if (lsame(compq, "I"))
            {
                icompq = 2;
            }
            else
            {
                icompq = -1;
            }
            if (iuplo == 0)
            {
                *info = -1;
            }
            else if (icompq < 0)
            {
                *info = -2;
            }
            else if (*n < 0)
            {
                *info = -3;
            }
            else if (*ldu < 1 || icompq == 2 && *ldu < *n)
            {
                *info = -7;
            }
            else if (*ldvt < 1 || icompq == 2 && *ldvt < *n)
            {
                *info = -9;
            }

            if (*info != 0)
            {
                i__1 = -(*info);
                xerbla("DBDSDC", &i__1);
                return 0;
            }

            // Quick return if possible

            if (*n == 0)
            {
                return 0;
            }
            smlsiz = ilaenv(&c__9, "DBDSDC", " ", &c__0, &c__0, &c__0, &c__0);
            if (*n == 1)
            {
                if (icompq == 1)
                {
                    q[1] = d_sign(&c_b15, &d[1]);
                    q[smlsiz * *n + 1] = 1.0;
                }
                else if (icompq == 2)
                {
                    u[u_dim1 + 1] = d_sign(&c_b15, &d[1]);
                    vt[vt_dim1 + 1] = 1.0;
                }
                d[1] = Math.Abs(d[1]);
                return 0;
            }
            nm1 = *n - 1;

            // If matrix lower bidiagonal, rotate to be upper bidiagonal
            // by applying Givens rotations on the left

            wstart = 1;
            qstart = 3;

            if (icompq == 1)
            {
                dcopy(n, &d[1], &c__1, &q[1], &c__1);
                i__1 = *n - 1;
                dcopy(&i__1, &e[1], &c__1, &q[*n + 1], &c__1);
            }

            if (iuplo == 2)
            {
                qstart = 5;
                wstart = (*n << 1) - 1;
                i__1 = *n - 1;
                for (i = 1; i <= i__1; ++i)
                {
                    dlartg(&d[i], &e[i], &cs, &sn, &r);
                    d[i] = r;
                    e[i] = sn * d[i + 1];
                    d[i + 1] = cs * d[i + 1];
                    if (icompq == 1)
                    {
                        q[i + (*n << 1)] = cs;
                        q[i + *n * 3] = sn;
                    }
                    else if (icompq == 2)
                    {
                        work[i] = cs;
                        work[nm1 + i] = -sn;
                    }
                }
            }

            // If ICOMPQ = 0, use DLASDQ to compute the singular values.

            if (icompq == 0)
            {
                dlasdq("U", &c__0, n, &c__0, &c__0, &c__0, &d[1], &e[1], &vt[
                    vt_offset], ldvt, &u[u_offset], ldu, &u[u_offset], ldu, &work[
                    wstart], info);
                goto L40;
            }

            // If N is_ smaller than the minimum divide size SMLSIZ, then solve
            // the problem with another solver.

            if (*n <= smlsiz)
            {
                if (icompq == 2)
                {
                    dlaset("A", n, n, &c_b29, &c_b15, &u[u_offset], ldu);
                    dlaset("A", n, n, &c_b29, &c_b15, &vt[vt_offset], ldvt);
                    dlasdq("U", &c__0, n, n, n, &c__0, &d[1], &e[1], &vt[vt_offset],
                        ldvt, &u[u_offset], ldu, &u[u_offset], ldu, &work[wstart], info);
                }
                else if (icompq == 1)
                {
                    iu = 1;
                    ivt = iu + *n;
                    dlaset("A", n, n, &c_b29, &c_b15, &q[iu + (qstart - 1) * *n], n);
                    dlaset("A", n, n, &c_b29, &c_b15, &q[ivt + (qstart - 1) * *n], n);
                    dlasdq("U", &c__0, n, n, n, &c__0, &d[1], &e[1], &q[ivt + (qstart - 1) * *n],
                        n, &q[iu + (qstart - 1) * *n], n, &q[iu + (qstart - 1) * *n],
                        n, &work[wstart], info);
                }
                goto L40;
            }

            if (icompq == 2)
            {
                dlaset("A", n, n, &c_b29, &c_b15, &u[u_offset], ldu);
                dlaset("A", n, n, &c_b29, &c_b15, &vt[vt_offset], ldvt);
            }

            // Scale.

            orgnrm = dlanst("M", n, &d[1], &e[1]);
            if (orgnrm == 0.0)
            {
                return 0;
            }
            dlascl("G", &c__0, &c__0, &orgnrm, &c_b15, n, &c__1, &d[1], n, &ierr);
            dlascl("G", &c__0, &c__0, &orgnrm, &c_b15, &nm1, &c__1, &e[1], &nm1, &ierr);

            eps = dlamch("Epsilon");

            mlvl = (int)(Math.Log((double)(*n) / (double)(smlsiz + 1)) / Math.Log(2.0)) + 1;
            smlszp = smlsiz + 1;

            if (icompq == 1)
            {
                iu = 1;
                ivt = smlsiz + 1;
                difl = ivt + smlszp;
                difr = difl + mlvl;
                z = difr + (mlvl << 1);
                ic = z + mlvl;
                is_ = ic + 1;
                poles = is_ + 1;
                givnum = poles + (mlvl << 1);

                k = 1;
                givptr = 2;
                perm = 3;
                givcol = perm + mlvl;
            }

            i__1 = *n;
            for (i = 1; i <= i__1; ++i)
            {
                if (Math.Abs(d[i]) < eps)
                {
                    d[i] = d_sign(&eps, &d[i]);
                }
            }

            start = 1;
            sqre = 0;

            i__1 = nm1;
            for (i = 1; i <= i__1; ++i)
            {
                if (Math.Abs(e[i]) < eps || i == nm1)
                {
                    // Subproblem found. First determine its size and then
                    // apply divide and conquer on it.

                    if (i < nm1)
                    {
                        // A subproblem with E(I) small for I < NM1.

                        nsize = i - start + 1;
                    }
                    else if (Math.Abs(e[i]) >= eps)
                    {
                        // A subproblem with E(NM1) not too small but I = NM1.

                        nsize = *n - start + 1;
                    }
                    else
                    {
                        // A subproblem with E(NM1) small. This_ implies an
                        // 1-by-1 subproblem at D(N). Solve this_ 1-by-1 problem
                        // first.

                        nsize = i - start + 1;
                        if (icompq == 2)
                        {
                            u[*n + *n * u_dim1] = d_sign(&c_b15, &d[*n]);
                            vt[*n + *n * vt_dim1] = 1.0;
                        }
                        else if (icompq == 1)
                        {
                            q[*n + (qstart - 1) * *n] = d_sign(&c_b15, &d[*n]);
                            q[*n + (smlsiz + qstart - 1) * *n] = 1.0;
                        }
                        d[*n] = Math.Abs(d[*n]);
                    }
                    if (icompq == 2)
                    {
                        dlasd0(&nsize, &sqre, &d[start], &e[start], &u[start + start * u_dim1], ldu,
                            &vt[start + start * vt_dim1], ldvt, &smlsiz, &iwork[1], &work[wstart], info);
                    }
                    else
                    {
                        dlasda(&icompq, &smlsiz, &nsize, &sqre, &d[start], &e[start], &q[start + (iu + qstart - 2) * *n],
                            n, &q[start + (ivt + qstart - 2) * *n], &iq[start + k * *n], &q[start + (difl + qstart - 2) * *n],
                            &q[start + (difr + qstart - 2) * *n], &q[start + (z + qstart - 2) * *n],
                            &q[start + (poles + qstart - 2) * *n], &iq[start + givptr * *n], &iq[start + givcol * *n], n,
                            &iq[start + perm * *n], &q[start + (givnum + qstart - 2) * *n], &q[start + (ic + qstart - 2) * *n],
                            &q[start + (is_ + qstart - 2) * *n], &work[wstart], &iwork[1], info);

                        if (*info != 0)
                        {
                            return 0;
                        }
                    }
                    start = i + 1;
                }
            }

            // Unscale

            dlascl("G", &c__0, &c__0, &c_b15, &orgnrm, n, &c__1, &d[1], n, &ierr);

        L40:
            // Use Selection Sort to minimize swaps of singular vectors

            i__1 = *n;
            for (ii = 2; ii <= i__1; ++ii)
            {
                i = ii - 1;
                kk = i;
                p = d[i];
                i__2 = *n;
                for (j = ii; j <= i__2; ++j)
                {
                    if (d[j] > p)
                    {
                        kk = j;
                        p = d[j];
                    }
                }
                if (kk != i)
                {
                    d[kk] = d[i];
                    d[i] = p;
                    if (icompq == 1)
                    {
                        iq[i] = kk;
                    }
                    else if (icompq == 2)
                    {
                        dswap(n, &u[i * u_dim1 + 1], &c__1, &u[kk * u_dim1 + 1], &c__1);
                        dswap(n, &vt[i + vt_dim1], ldvt, &vt[kk + vt_dim1], ldvt);
                    }
                }
                else if (icompq == 1)
                {
                    iq[i] = i;
                }
            }

            // If ICOMPQ = 1, use IQ(N,1) as the indicator for UPLO

            if (icompq == 1)
            {
                if (iuplo == 1)
                {
                    iq[*n] = 1;
                }
                else
                {
                    iq[*n] = 0;
                }
            }

            // If B is_ lower bidiagonal, update U by those Givens rotations
            // which rotated B to be upper bidiagonal

            if (iuplo == 2 && icompq == 2)
            {
                dlasr("L", "V", "B", n, n, &work[1], &work[*n], &u[u_offset], ldu);
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int dbdsqr(string uplo, int* n, int* ncvt, int* nru, int* ncc, double* d,
            double* e, double* vt, int* ldvt, double* u, int* ldu, double* c, int* ldc, double* work, int* info)
        {
            //  -- LAPACK routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     January 2007

            //  Purpose
            //  =======

            //  DBDSQR computes the singular values and, optionally, the right and/or
            //  left singular vectors from the singular value decomposition (SVD) of
            //  a float N-by-N (upper or lower) bidiagonal matrix B using the implicit
            //  zero-shift QR algorithm.  The SVD of B has the form

            //     B = Q * S * P**T

            //  where S is the diagonal matrix of singular values, Q is an orthogonal
            //  matrix of left singular vectors, and P is an orthogonal matrix of
            //  right singular vectors.  If left singular vectors are requested, this
            //  subroutine actually returns U*Q instead of Q, and, if right singular
            //  vectors are requested, this subroutine returns P**T*VT instead of
            //  P**T, for given float input matrices U and VT.  When U and VT are the
            //  orthogonal matrices that reduce a general matrix A to bidiagonal
            //  form:  A = U*B*VT, as computed by DGEBRD, then

            //     A = (U*Q) * S * (P**T*VT)

            //  is the SVD of A.  Optionally, the subroutine may also compute Q**T*C
            //  for a given float input matrix C.

            //  See "Computing  Small Singular Values of Bidiagonal Matrices With
            //  Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
            //  LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,
            //  no. 5, pp. 873-912, Sept 1990) and
            //  "Accurate singular values and differential qd algorithms," by
            //  B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics
            //  Department, University of California at Berkeley, July 1992
            //  for a detailed description of the algorithm.

            //  Arguments
            //  =========

            //  UPLO    (input) CHARACTER*1
            //          = 'U':  B is upper bidiagonal;
            //          = 'L':  B is lower bidiagonal.

            //  N       (input) INTEGER
            //          The order of the matrix B.  N >= 0.0

            //  NCVT    (input) INTEGER
            //          The number of columns of the matrix VT. NCVT >= 0.0

            //  NRU     (input) INTEGER
            //          The number of rows of the matrix U. NRU >= 0.0

            //  NCC     (input) INTEGER
            //          The number of columns of the matrix C. NCC >= 0.0

            //  D       (input/output) DOUBLE PRECISION array, dimension (N)
            //          On entry, the n diagonal elements of the bidiagonal matrix B.
            //          On exit, if INFO=0, the singular values of B in decreasing
            //          order.

            //  E       (input/output) DOUBLE PRECISION array, dimension (N-1)
            //          On entry, the N-1 offdiagonal elements of the bidiagonal
            //          matrix B.
            //          On exit, if INFO = 0, E is destroyed; if INFO > 0, D and E
            //          will contain the diagonal and superdiagonal elements of a
            //          bidiagonal matrix orthogonally equivalent to the one given
            //          as input.

            //  VT      (input/output) DOUBLE PRECISION array, dimension (LDVT, NCVT)
            //          On entry, an N-by-NCVT matrix VT.
            //          On exit, VT is overwritten by P**T * VT.
            //          Not referenced if NCVT = 0.0

            //  LDVT    (input) INTEGER
            //          The leading dimension of the array VT.
            //          LDVT >= max(1,N) if NCVT > 0; LDVT >= 1 if NCVT = 0.0

            //  U       (input/output) DOUBLE PRECISION array, dimension (LDU, N)
            //          On entry, an NRU-by-N matrix U.
            //          On exit, U is overwritten by U * Q.
            //          Not referenced if NRU = 0.0

            //  LDU     (input) INTEGER
            //          The leading dimension of the array U.  LDU >= max(1,NRU).

            //  C       (input/output) DOUBLE PRECISION array, dimension (LDC, NCC)
            //          On entry, an N-by-NCC matrix C.
            //          On exit, C is overwritten by Q**T * C.
            //          Not referenced if NCC = 0.0

            //  LDC     (input) INTEGER
            //          The leading dimension of the array C.
            //          LDC >= max(1,N) if NCC > 0; LDC >=1 if NCC = 0.0

            //  WORK    (workspace) DOUBLE PRECISION array, dimension (4*N)

            //  INFO    (output) INTEGER
            //          = 0:  successful exit
            //          < 0:  If INFO = -i, the i-th argument had an illegal value
            //          > 0:
            //             if NCVT = NRU = NCC = 0,
            //                = 1, a split was marked by a positive value in E
            //                = 2, current block of Z not diagonalized after 30*N
            //                     iterations (in inner while loop)
            //                = 3, termination criterion of outer while loop not met
            //                     (program created more than N unreduced blocks)
            //             else NCVT = NRU = NCC = 0,
            //                   the algorithm did not converge; D and E contain the
            //                   elements of a bidiagonal matrix which is orthogonally
            //                   similar to the input matrix B;  if INFO = i, i
            //                   elements of E have not converged to zero.

            //  Internal Parameters
            //  ===================

            //  TOLMUL  DOUBLE PRECISION, default = max(10,min(100,EPS**(-1/8)))
            //          TOLMUL controls the convergence criterion of the QR loop.
            //          If it is positive, TOLMUL*EPS is the desired relative
            //             precision in the computed singular values.
            //          If it is negative, abs(TOLMUL*EPS*sigma_max) is the
            //             desired absolute accuracy in the computed singular
            //             values (corresponds to relative accuracy
            //             abs(TOLMUL*EPS) in the largest singular value.
            //          abs(TOLMUL) should be between 1 and 1/EPS, and preferably
            //             between 10 (for fast convergence) and 0.1/EPS
            //             (for there to be some accuracy in the results).
            //          Default is to lose at either one eighth or 2 of the
            //             available decimal digits in each computed singular value
            //             (whichever is smaller).

            //  MAXITR  INTEGER, default = 6
            //          MAXITR controls the maximum number of passes of the
            //          algorithm through its inner loop. The algorithms stops
            //          (and so fails to converge) if the number of passes
            //          through the inner loop exceeds MAXITR*N**2.0

            //  =====================================================================

            // System generated locals
            int c_dim1, c_offset, u_dim1, u_offset, vt_dim1, vt_offset, i__1, i__2;
            double d__1, d__2, d__3, d__4;

            // Table of constant values
            double c_b15 = -0.125;
            int c__1 = 1;
            double c_b49 = 1.0;
            double c_b72 = -1.0;

            // Local variables
            double f, g, h;
            int i, j, m;
            double r, cs;
            int ll;
            double sn, mu;
            int nm1, nm12, nm13, lll;
            double eps, sll, tol, abse;
            int idir;
            double abss;
            int oldm;
            double cosl;
            int isub, iter;
            double unfl, sinl, cosr, smin, smax, sinr;
            double oldcs;
            int oldll;
            double shift, sigmn, oldsn = 0;
            int maxit;
            double sminl, sigmx;
            bool lower;
            double sminoa, thresh;
            bool rotate;
            double tolmul;

            // Parameter adjustments
            --d;
            --e;
            vt_dim1 = *ldvt;
            vt_offset = 1 + vt_dim1;
            vt -= vt_offset;
            u_dim1 = *ldu;
            u_offset = 1 + u_dim1;
            u -= u_offset;
            c_dim1 = *ldc;
            c_offset = 1 + c_dim1;
            c -= c_offset;
            --work;

            // Function Body
            *info = 0;
            lower = lsame(uplo, "L");
            if (!lsame(uplo, "U") && !lower)
            {
                *info = -1;
            }
            else if (*n < 0)
            {
                *info = -2;
            }
            else if (*ncvt < 0)
            {
                *info = -3;
            }
            else if (*nru < 0)
            {
                *info = -4;
            }
            else if (*ncc < 0)
            {
                *info = -5;
            }
            else if (*ncvt == 0 && *ldvt < 1 || *ncvt > 0 && *ldvt < Math.Max(1, *n))
            {
                *info = -9;
            }
            else if (*ldu < Math.Max(1, *nru))
            {
                *info = -11;
            }
            else if (*ncc == 0 && *ldc < 1 || *ncc > 0 && *ldc < Math.Max(1, *n))
            {
                *info = -13;
            }

            if (*info != 0)
            {
                i__1 = -(*info);
                xerbla("DBDSQR", &i__1);
                return 0;
            }
            if (*n == 0)
            {
                return 0;
            }
            if (*n == 1)
            {
                goto L160;
            }

            // ROTATE is true if any singular vectors desired, false otherwise

            rotate = *ncvt > 0 || *nru > 0 || *ncc > 0;

            // If no singular vectors desired, use qd algorithm

            if (!rotate)
            {
                dlasq1(n, &d[1], &e[1], &work[1], info);
                return 0;
            }

            nm1 = *n - 1;
            nm12 = nm1 + nm1;
            nm13 = nm12 + nm1;
            idir = 0;

            //     Get machine constants

            eps = dlamch("Epsilon");
            unfl = dlamch("Safe minimum");

            // If matrix lower bidiagonal, rotate to be upper bidiagonal
            // by applying Givens rotations on the left

            if (lower)
            {
                i__1 = *n - 1;
                for (i = 1; i <= i__1; ++i)
                {
                    dlartg(&d[i], &e[i], &cs, &sn, &r);
                    d[i] = r;
                    e[i] = sn * d[i + 1];
                    d[i + 1] = cs * d[i + 1];
                    work[i] = cs;
                    work[nm1 + i] = sn;
                }

                // Update singular vectors if desired

                if (*nru > 0)
                {
                    dlasr("R", "V", "F", nru, n, &work[1], &work[*n], &u[u_offset], ldu);
                }
                if (*ncc > 0)
                {
                    dlasr("L", "V", "F", n, ncc, &work[1], &work[*n], &c[c_offset], ldc);
                }
            }

            // Compute singular values to relative accuracy TOL
            // (By setting TOL to be negative, algorithm will compute
            // singular values to absolute accuracy ABS(TOL)*norm(input matrix))

            // Computing MAX
            // Computing MIN
            d__3 = 100.0;
            d__4 = pow_dd(&eps, &c_b15);
            d__1 = 10.0;
            d__2 = Math.Min(d__3, d__4);
            tolmul = Math.Max(d__1, d__2);
            tol = tolmul * eps;

            // Compute approximate maximum, minimum singular values

            smax = 0.0;
            i__1 = *n;
            for (i = 1; i <= i__1; ++i)
            {
                // Computing MAX
                d__2 = smax;
                d__3 = Math.Abs(d[i]);
                smax = Math.Max(d__2, d__3);
            }
            i__1 = *n - 1;
            for (i = 1; i <= i__1; ++i)
            {
                // Computing MAX
                d__2 = smax;
                d__3 = Math.Abs(e[i]);
                smax = Math.Max(d__2, d__3);
            }

            sminl = 0.0;
            if (tol >= 0.0)
            {
                // Relative accuracy desired

                sminoa = Math.Abs(d[1]);
                if (sminoa == 0.0)
                {
                    goto L50;
                }
                mu = sminoa;
                i__1 = *n;
                for (i = 2; i <= i__1; ++i)
                {
                    mu = Math.Abs(d[i]) * (mu / (mu + Math.Abs(e[i - 1])));
                    sminoa = Math.Min(sminoa, mu);
                    if (sminoa == 0.0)
                    {
                        goto L50;
                    }
                }
            L50:
                sminoa /= Math.Sqrt((double)(*n));
                // Computing MAX
                d__1 = tol * sminoa;
                d__2 = *n * 6 * *n * unfl;
                thresh = Math.Max(d__1, d__2);
            }
            else
            {
                // Absolute accuracy desired

                // Computing MAX
                d__1 = Math.Abs(tol) * smax;
                d__2 = *n * 6 * *n * unfl;
                thresh = Math.Max(d__1, d__2);
            }

            // Prepare for main iteration loop for the singular values
            // (MAXIT is the maximum number of passes through the inner
            // loop permitted before nonconvergence signalled.)

            maxit = *n * 6 * *n;
            iter = 0;
            oldll = -1;
            oldm = -1;

            // M points to last element of unconverged part of matrix

            m = *n;

            // Begin main iteration loop

        L60:

            // Check for convergence or exceeding iteration count

            if (m <= 1)
            {
                goto L160;
            }
            if (iter > maxit)
            {
                goto L200;
            }

            // Find diagonal block of matrix to work on

            if (tol < 0.0 && Math.Abs(d[m]) <= thresh)
            {
                d[m] = 0.0;
            }
            smax = Math.Abs(d[m]);
            smin = smax;
            i__1 = m - 1;
            for (lll = 1; lll <= i__1; ++lll)
            {
                ll = m - lll;
                abss = Math.Abs(d[ll]);
                abse = Math.Abs(e[ll]);
                if (tol < 0.0 && abss <= thresh)
                {
                    d[ll] = 0.0;
                }
                if (abse <= thresh)
                {
                    goto L80;
                }
                smin = Math.Min(smin, abss);
                // Computing MAX
                d__1 = Math.Max(smax, abss);
                smax = Math.Max(d__1, abse);
            }
            ll = 0;
            goto L90;
        L80:
            e[ll] = 0.0;

            // Matrix splits since E(LL) = 0

            if (ll == m - 1)
            {
                // Convergence of bottom singular value, return to top of loop

                --m;
                goto L60;
            }
        L90:
            ++ll;

            // E(LL) through E(M-1) are nonzero, E(LL-1) is zero

            if (ll == m - 1)
            {
                // 2 by 2 block, handle separately

                dlasv2(&d[m - 1], &e[m - 1], &d[m], &sigmn, &sigmx, &sinr, &cosr, &sinl, &cosl);
                d[m - 1] = sigmx;
                e[m - 1] = 0.0;
                d[m] = sigmn;

                // Compute singular vectors, if desired

                if (*ncvt > 0)
                {
                    drot(ncvt, &vt[m - 1 + vt_dim1], ldvt, &vt[m + vt_dim1], ldvt, &cosr, &sinr);
                }
                if (*nru > 0)
                {
                    drot(nru, &u[(m - 1) * u_dim1 + 1], &c__1, &u[m * u_dim1 + 1], &c__1, &cosl, &sinl);
                }
                if (*ncc > 0)
                {
                    drot(ncc, &c[m - 1 + c_dim1], ldc, &c[m + c_dim1], ldc, &cosl, &sinl);
                }
                m += -2;
                goto L60;
            }

            // If working on new submatrix, choose shift direction
            // (from larger end diagonal element towards smaller)

            if (ll > oldm || m < oldll)
            {
                if (Math.Abs(d[ll]) >= Math.Abs(d[m]))
                {
                    // Chase bulge from top (big end) to bottom (small end)

                    idir = 1;
                }
                else
                {
                    // Chase bulge from bottom (big end) to top (small end)

                    idir = 2;
                }
            }

            // Apply convergence tests

            if (idir == 1)
            {
                // Run convergence test in forward direction
                // First apply standard test to bottom of matrix

                if (Math.Abs(e[m - 1]) <= Math.Abs(tol) * Math.Abs(d[m]) || tol < 0.0 && Math.Abs(e[m - 1]) <= thresh)
                {
                    e[m - 1] = 0.0;
                    goto L60;
                }

                if (tol >= 0.0)
                {
                    // If relative accuracy desired,
                    // apply convergence criterion forward

                    mu = Math.Abs(d[ll]);
                    sminl = mu;
                    i__1 = m - 1;
                    for (lll = ll; lll <= i__1; ++lll)
                    {
                        if (Math.Abs(e[lll]) <= tol * mu)
                        {
                            e[lll] = 0.0;
                            goto L60;
                        }
                        mu = Math.Abs(d[lll + 1]) * (mu / (mu + Math.Abs(e[lll])));
                        sminl = Math.Min(sminl, mu);
                    }
                }
            }
            else
            {
                // Run convergence test in backward direction
                // First apply standard test to top of matrix

                if (Math.Abs(e[ll]) <= Math.Abs(tol) * Math.Abs(d[ll]) || tol < 0.0 && Math.Abs(e[ll]) <= thresh)
                {
                    e[ll] = 0.0;
                    goto L60;
                }

                if (tol >= 0.0)
                {
                    // If relative accuracy desired,
                    // apply convergence criterion backward

                    mu = Math.Abs(d[m]);
                    sminl = mu;
                    i__1 = ll;
                    for (lll = m - 1; lll >= i__1; --lll)
                    {
                        if (Math.Abs(e[lll]) <= tol * mu)
                        {
                            e[lll] = 0.0;
                            goto L60;
                        }
                        mu = Math.Abs(d[lll]) * (mu / (mu + Math.Abs(e[lll])));
                        sminl = Math.Min(sminl, mu);
                    }
                }
            }
            oldll = ll;
            oldm = m;

            // Compute shift.  First, test if shifting would ruin relative
            // accuracy, and if so set the shift to zero.

            // Computing MAX
            d__1 = eps;
            d__2 = tol * 0.01;
            if (tol >= 0.0 && *n * tol * (sminl / smax) <= Math.Max(d__1, d__2))
            {
                // Use a zero shift to avoid loss of relative accuracy

                shift = 0.0;
            }
            else
            {
                // Compute the shift from 2-by-2 block at end of matrix

                if (idir == 1)
                {
                    sll = Math.Abs(d[ll]);
                    dlas2(&d[m - 1], &e[m - 1], &d[m], &shift, &r);
                }
                else
                {
                    sll = Math.Abs(d[m]);
                    dlas2(&d[ll], &e[ll], &d[ll + 1], &shift, &r);
                }

                // Test if shift negligible, and if so set to zero

                if (sll > 0.0)
                {
                    // Computing 2nd power
                    d__1 = shift / sll;
                    if (d__1 * d__1 < eps)
                    {
                        shift = 0.0;
                    }
                }
            }

            // Increment iteration count

            iter = iter + m - ll;

            // If SHIFT = 0, do simplified QR iteration

            if (shift == 0.0)
            {
                if (idir == 1)
                {
                    // Chase bulge from top to bottom
                    // Save cosines and sines for later singular vector updates

                    cs = 1.0;
                    oldcs = 1.0;
                    i__1 = m - 1;
                    for (i = ll; i <= i__1; ++i)
                    {
                        d__1 = d[i] * cs;
                        dlartg(&d__1, &e[i], &cs, &sn, &r);
                        if (i > ll)
                        {
                            e[i - 1] = oldsn * r;
                        }
                        d__1 = oldcs * r;
                        d__2 = d[i + 1] * sn;
                        dlartg(&d__1, &d__2, &oldcs, &oldsn, &d[i]);
                        work[i - ll + 1] = cs;
                        work[i - ll + 1 + nm1] = sn;
                        work[i - ll + 1 + nm12] = oldcs;
                        work[i - ll + 1 + nm13] = oldsn;
                    }
                    h = d[m] * cs;
                    d[m] = h * oldcs;
                    e[m - 1] = h * oldsn;

                    // Update singular vectors

                    if (*ncvt > 0)
                    {
                        i__1 = m - ll + 1;
                        dlasr("L", "V", "F", &i__1, ncvt, &work[1], &work[*n], &vt[ll + vt_dim1], ldvt);
                    }
                    if (*nru > 0)
                    {
                        i__1 = m - ll + 1;
                        dlasr("R", "V", "F", nru, &i__1, &work[nm12 + 1], &work[nm13 + 1], &u[ll * u_dim1 + 1], ldu);
                    }
                    if (*ncc > 0)
                    {
                        i__1 = m - ll + 1;
                        dlasr("L", "V", "F", &i__1, ncc, &work[nm12 + 1], &work[nm13 + 1], &c[ll + c_dim1], ldc);
                    }

                    // Test convergence

                    if (Math.Abs(e[m - 1]) <= thresh)
                    {
                        e[m - 1] = 0.0;
                    }

                }
                else
                {
                    // Chase bulge from bottom to top
                    // Save cosines and sines for later singular vector updates

                    cs = 1.0;
                    oldcs = 1.0;
                    i__1 = ll + 1;
                    for (i = m; i >= i__1; --i)
                    {
                        d__1 = d[i] * cs;
                        dlartg(&d__1, &e[i - 1], &cs, &sn, &r);
                        if (i < m)
                        {
                            e[i] = oldsn * r;
                        }
                        d__1 = oldcs * r;
                        d__2 = d[i - 1] * sn;
                        dlartg(&d__1, &d__2, &oldcs, &oldsn, &d[i]);
                        work[i - ll] = cs;
                        work[i - ll + nm1] = -sn;
                        work[i - ll + nm12] = oldcs;
                        work[i - ll + nm13] = -oldsn;
                    }
                    h = d[ll] * cs;
                    d[ll] = h * oldcs;
                    e[ll] = h * oldsn;

                    // Update singular vectors

                    if (*ncvt > 0)
                    {
                        i__1 = m - ll + 1;
                        dlasr("L", "V", "B", &i__1, ncvt, &work[nm12 + 1], &work[nm13 + 1], &vt[ll + vt_dim1], ldvt);
                    }
                    if (*nru > 0)
                    {
                        i__1 = m - ll + 1;
                        dlasr("R", "V", "B", nru, &i__1, &work[1], &work[*n], &u[ll * u_dim1 + 1], ldu);
                    }
                    if (*ncc > 0)
                    {
                        i__1 = m - ll + 1;
                        dlasr("L", "V", "B", &i__1, ncc, &work[1], &work[*n], &c[ll + c_dim1], ldc);
                    }

                    // Test convergence

                    if (Math.Abs(e[ll]) <= thresh)
                    {
                        e[ll] = 0.0;
                    }
                }
            }
            else
            {
                // Use nonzero shift

                if (idir == 1)
                {
                    // Chase bulge from top to bottom
                    // Save cosines and sines for later singular vector updates

                    f = (Math.Abs(d[ll]) - shift) * (d_sign(&c_b49, &d[ll]) + shift / d[ll]);
                    g = e[ll];
                    i__1 = m - 1;
                    for (i = ll; i <= i__1; ++i)
                    {
                        dlartg(&f, &g, &cosr, &sinr, &r);
                        if (i > ll)
                        {
                            e[i - 1] = r;
                        }
                        f = cosr * d[i] + sinr * e[i];
                        e[i] = cosr * e[i] - sinr * d[i];
                        g = sinr * d[i + 1];
                        d[i + 1] = cosr * d[i + 1];
                        dlartg(&f, &g, &cosl, &sinl, &r);
                        d[i] = r;
                        f = cosl * e[i] + sinl * d[i + 1];
                        d[i + 1] = cosl * d[i + 1] - sinl * e[i];
                        if (i < m - 1)
                        {
                            g = sinl * e[i + 1];
                            e[i + 1] = cosl * e[i + 1];
                        }
                        work[i - ll + 1] = cosr;
                        work[i - ll + 1 + nm1] = sinr;
                        work[i - ll + 1 + nm12] = cosl;
                        work[i - ll + 1 + nm13] = sinl;
                    }
                    e[m - 1] = f;

                    // Update singular vectors

                    if (*ncvt > 0)
                    {
                        i__1 = m - ll + 1;
                        dlasr("L", "V", "F", &i__1, ncvt, &work[1], &work[*n], &vt[ll + vt_dim1], ldvt);
                    }
                    if (*nru > 0)
                    {
                        i__1 = m - ll + 1;
                        dlasr("R", "V", "F", nru, &i__1, &work[nm12 + 1], &work[nm13 + 1], &u[ll * u_dim1 + 1], ldu);
                    }
                    if (*ncc > 0)
                    {
                        i__1 = m - ll + 1;
                        dlasr("L", "V", "F", &i__1, ncc, &work[nm12 + 1], &work[nm13 + 1], &c[ll + c_dim1], ldc);
                    }

                    // Test convergence

                    if (Math.Abs(e[m - 1]) <= thresh)
                    {
                        e[m - 1] = 0.0;
                    }

                }
                else
                {
                    // Chase bulge from bottom to top
                    // Save cosines and sines for later singular vector updates

                    f = (Math.Abs(d[m]) - shift) * (d_sign(&c_b49, &d[m]) + shift / d[m]);
                    g = e[m - 1];
                    i__1 = ll + 1;
                    for (i = m; i >= i__1; --i)
                    {
                        dlartg(&f, &g, &cosr, &sinr, &r);
                        if (i < m)
                        {
                            e[i] = r;
                        }
                        f = cosr * d[i] + sinr * e[i - 1];
                        e[i - 1] = cosr * e[i - 1] - sinr * d[i];
                        g = sinr * d[i - 1];
                        d[i - 1] = cosr * d[i - 1];
                        dlartg(&f, &g, &cosl, &sinl, &r);
                        d[i] = r;
                        f = cosl * e[i - 1] + sinl * d[i - 1];
                        d[i - 1] = cosl * d[i - 1] - sinl * e[i - 1];
                        if (i > ll + 1)
                        {
                            g = sinl * e[i - 2];
                            e[i - 2] = cosl * e[i - 2];
                        }
                        work[i - ll] = cosr;
                        work[i - ll + nm1] = -sinr;
                        work[i - ll + nm12] = cosl;
                        work[i - ll + nm13] = -sinl;
                    }
                    e[ll] = f;

                    // Test convergence

                    if (Math.Abs(e[ll]) <= thresh)
                    {
                        e[ll] = 0.0;
                    }

                    // Update singular vectors if desired

                    if (*ncvt > 0)
                    {
                        i__1 = m - ll + 1;
                        dlasr("L", "V", "B", &i__1, ncvt, &work[nm12 + 1], &work[nm13 + 1], &vt[ll + vt_dim1], ldvt);
                    }
                    if (*nru > 0)
                    {
                        i__1 = m - ll + 1;
                        dlasr("R", "V", "B", nru, &i__1, &work[1], &work[*n], &u[ll * u_dim1 + 1], ldu);
                    }
                    if (*ncc > 0)
                    {
                        i__1 = m - ll + 1;
                        dlasr("L", "V", "B", &i__1, ncc, &work[1], &work[*n], &c[ll + c_dim1], ldc);
                    }
                }
            }

            // QR iteration finished, go back and check convergence

            goto L60;

            // All singular values converged, so make them positive

        L160:
            i__1 = *n;
            for (i = 1; i <= i__1; ++i)
            {
                if (d[i] < 0.0)
                {
                    d[i] = -d[i];

                    // Change sign of singular vectors, if desired

                    if (*ncvt > 0)
                    {
                        dscal(ncvt, &c_b72, &vt[i + vt_dim1], ldvt);
                    }
                }
            }

            // Sort the singular values into decreasing order (insertion sort on
            // singular values, but only one transposition per singular vector)

            i__1 = *n - 1;
            for (i = 1; i <= i__1; ++i)
            {
                // Scan for smallest D(I)

                isub = 1;
                smin = d[1];
                i__2 = *n + 1 - i;
                for (j = 2; j <= i__2; ++j)
                {
                    if (d[j] <= smin)
                    {
                        isub = j;
                        smin = d[j];
                    }
                }
                if (isub != *n + 1 - i)
                {
                    // Swap singular values and vectors

                    d[isub] = d[*n + 1 - i];
                    d[*n + 1 - i] = smin;
                    if (*ncvt > 0)
                    {
                        dswap(ncvt, &vt[isub + vt_dim1], ldvt, &vt[*n + 1 - i + vt_dim1], ldvt);
                    }
                    if (*nru > 0)
                    {
                        dswap(nru, &u[isub * u_dim1 + 1], &c__1, &u[(*n + 1 - i) * u_dim1 + 1], &c__1);
                    }
                    if (*ncc > 0)
                    {
                        dswap(ncc, &c[isub + c_dim1], ldc, &c[*n + 1 - i + c_dim1], ldc);
                    }
                }
            }
            goto L220;

            // Maximum number of iterations exceeded, failure to converge

        L200:
            *info = 0;
            i__1 = *n - 1;
            for (i = 1; i <= i__1; ++i)
            {
                if (e[i] != 0.0)
                {
                    ++(*info);
                }
            }

        L220:
            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static bool disnan(double* din)
        {
            //  -- LAPACK auxiliary routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. 
            //     November 2006 

            //  Purpose 
            //  ======= 

            //  DISNAN returns .TRUE. if its argument is NaN, and .FALSE. 
            //  otherwise.  To be replaced by the Fortran 2003 intrinsic in the 
            //  future. 

            //  Arguments 
            //  ========= 

            //  DIN      (input) DOUBLE PRECISION 
            //          Input to test for NaN. 

            //  ===================================================================== 

            return double.IsNaN(*din);
        }

        [SuppressUnmanagedCodeSecurity]
        public static int dlabad(double* small, double* large)
        {
            //  -- LAPACK auxiliary routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. 
            //     November 2006 

            //  Purpose 
            //  ======= 

            //  DLABAD takes as input the values computed by DLAMCH for underflow and 
            //  overflow, and returns the square root of each of these values if the 
            //  log of LARGE is sufficiently large.  This subroutine is intended to 
            //  identify machines with a large exponent range, such as the Crays, and 
            //  redefine the underflow and overflow limits to be the square roots of 
            //  the values computed by DLAMCH.  This subroutine is needed because 
            //  DLAMCH does not compensate for poor arithmetic in the upper half of 
            //  the exponent range, as is found on a Cray. 

            //  Arguments 
            //  ========= 

            //  SMALL   (input/output) DOUBLE PRECISION 
            //          On entry, the underflow threshold as computed by DLAMCH. 
            //          On exit, if LOG10(LARGE) is sufficiently large, the square 
            //          root of SMALL, otherwise unchanged. 

            //  LARGE   (input/output) DOUBLE PRECISION 
            //          On entry, the overflow threshold as computed by DLAMCH. 
            //          On exit, if LOG10(LARGE) is sufficiently large, the square 
            //          root of LARGE, otherwise unchanged. 

            //  ===================================================================== 

            //     If it looks like we're on a Cray, take the square root of 
            //     SMALL and LARGE to avoid overflow and underflow problems. 

            if (Math.Log10(*large) > 2e3)
            {
                *small = Math.Sqrt(*small);
                *large = Math.Sqrt(*large);
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int dlacpy(string uplo, int* m, int* n, double* a, int* lda, double* b, int* ldb)
        {
            //  -- LAPACK auxiliary routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     November 2006

            //  Purpose
            //  =======

            //  DLACPY copies all or part of a two-dimensional matrix A to another
            //  matrix B.

            //  Arguments
            //  =========

            //  UPLO    (input) CHARACTER*1
            //          Specifies the part of the matrix A to be copied to B.
            //          = 'U':      Upper triangular part
            //          = 'L':      Lower triangular part
            //          Otherwise:  All of the matrix A

            //  M       (input) INTEGER
            //          The number of rows of the matrix A.  M >= 0.0

            //  N       (input) INTEGER
            //          The number of columns of the matrix A.  N >= 0.0

            //  A       (input) DOUBLE PRECISION array, dimension (LDA,N)
            //          The m by n matrix A.  If UPLO = 'U', only the upper triangle
            //          or trapezoid is accessed; if UPLO = 'L', only the lower
            //          triangle or trapezoid is accessed.

            //  LDA     (input) INTEGER
            //          The leading dimension of the array A.  LDA >= max(1,M).

            //  B       (output) DOUBLE PRECISION array, dimension (LDB,N)
            //          On exit, B = A in the locations specified by UPLO.

            //  LDB     (input) INTEGER
            //          The leading dimension of the array B.  LDB >= max(1,M).

            //  =====================================================================

            // System generated locals
            int a_dim1, a_offset, b_dim1, b_offset, i__1, i__2;

            // Local variables
            int i, j;

            // Parameter adjustments
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;
            b_dim1 = *ldb;
            b_offset = 1 + b_dim1;
            b -= b_offset;

            // Function Body
            if (lsame(uplo, "U"))
            {
                i__1 = *n;
                for (j = 1; j <= i__1; ++j)
                {
                    i__2 = Math.Min(j, *m);
                    for (i = 1; i <= i__2; ++i)
                    {
                        b[i + j * b_dim1] = a[i + j * a_dim1];
                    }
                }
            }
            else if (lsame(uplo, "L"))
            {
                i__1 = *n;
                for (j = 1; j <= i__1; ++j)
                {
                    i__2 = *m;
                    for (i = j; i <= i__2; ++i)
                    {
                        b[i + j * b_dim1] = a[i + j * a_dim1];
                    }
                }
            }
            else
            {
                i__1 = *n;
                for (j = 1; j <= i__1; ++j)
                {
                    i__2 = *m;
                    for (i = 1; i <= i__2; ++i)
                    {
                        b[i + j * b_dim1] = a[i + j * a_dim1];
                    }
                }
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int dladiv(double* a, double* b, double* c, double* d, double* p, double* q)
        {
            //  -- LAPACK auxiliary routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. 
            //     November 2006 

            //  Purpose 
            //  ======= 

            //  DLADIV performs complex division in  real arithmetic 

            //                        a + i*b 
            //             p + i*q = --------- 
            //                        c + i*d 

            //  The algorithm is due to Robert L. Smith and can be found 
            //  in D. Knuth, The art of Computer Programming, Vol.2, p.195 

            //  Arguments 
            //  ========= 

            //  A       (input) DOUBLE PRECISION 
            //  B       (input) DOUBLE PRECISION 
            //  C       (input) DOUBLE PRECISION 
            //  D       (input) DOUBLE PRECISION 
            //          The scalars a, b, c, and d in the above expression. 

            //  P       (output) DOUBLE PRECISION 
            //  Q       (output) DOUBLE PRECISION 
            //          The scalars p and q in the above expression. 

            //  ===================================================================== 

            double e, f;

            if (Math.Abs(*d) < Math.Abs(*c))
            {
                e = *d / *c;
                f = *c + *d * e;
                *p = (*a + *b * e) / f;
                *q = (*b - *a * e) / f;
            }
            else
            {
                e = *c / *d;
                f = *d + *c * e;
                *p = (*b + *a * e) / f;
                *q = (-(*a) + *b * e) / f;
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int dlaed6(int* kniter, bool* orgati,
            double* rho, double* d, double* z, double* finit, double* tau, int* info)
        {
            // System generated locals
            int i__1;
            double d__1, d__2, d__3, d__4;

            // Local variables
            double a, b, c, f;
            int i;
            double fc, df, ddf, lbd, eta, ubd, eps, base_;
            int iter;
            double temp, temp1, temp2, temp3, temp4;
            bool scale;
            int niter;
            double small1, small2, sminv1, sminv2;
            double sclfac, erretm, sclinv = 0.0;
            double[] dscale = new double[3];
            double[] zscale = new double[3];

            //  -- LAPACK routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     February 2007

            //  Purpose
            //  =======

            //  DLAED6 computes the positive or negative root (closest to the origin)
            //  of
            //                   z(1)        z(2)        z(3)
            //  f(x) =   rho + --------- + ---------- + ---------
            //                  d(1)-x      d(2)-x      d(3)-x

            //  It is assumed that

            //        if ORGATI = .true. the root is between d(2) and d(3);
            //        otherwise it is between d(1) and d(2)

            //  This routine will be called by DLAED4 when necessary. In most cases,
            //  the root sought is the smallest in magnitude, though it might not be
            //  in some extremely rare situations.

            //  Arguments
            //  =========

            //  KNITER       (input) INTEGER
            //               Refer to DLAED4 for its significance.

            //  ORGATI       (input) LOGICAL
            //               If ORGATI is true, the needed root is between d(2) and
            //               d(3); otherwise it is between d(1) and d(2).  See
            //               DLAED4 for further details.

            //  RHO          (input) DOUBLE PRECISION
            //               Refer to the equation f(x) above.

            //  D            (input) DOUBLE PRECISION array, dimension (3)
            //               D satisfies d(1) < d(2) < d(3).

            //  Z            (input) DOUBLE PRECISION array, dimension (3)
            //               Each of the elements in z must be positive.

            //  FINIT        (input) DOUBLE PRECISION
            //               The value of f at 0.0 It is more accurate than the one
            //               evaluated inside this routine (if someone wants to do
            //               so).

            //  TAU          (output) DOUBLE PRECISION
            //               The root of the equation f(x).

            //  INFO         (output) INTEGER
            //               = 0: successful exit
            //               > 0: if INFO = 1, failure to converge

            //  Further Details
            //  ===============

            //  30/06/99: Based on contributions by
            //     Ren-Cang Li, Computer Science Division, University of California
            //     at Berkeley, USA

            //  10/02/03: This version has a few statements commented out for thread
            //  safety (machine parameters are computed on each entry). SJH.

            //  05/10/06: Modified from a new version of Ren-Cang Li, use
            //     Gragg-Thornton-Warner cubic convergent scheme for better stability.

            //  =====================================================================

            // Parameter adjustments
            --z;
            --d;

            // Function Body
            *info = 0;

            if (*orgati)
            {
                lbd = d[2];
                ubd = d[3];
            }
            else
            {
                lbd = d[1];
                ubd = d[2];
            }
            if (*finit < 0.0)
            {
                lbd = 0.0;
            }
            else
            {
                ubd = 0.0;
            }

            niter = 1;
            *tau = 0.0;
            if (*kniter == 2)
            {
                if (*orgati)
                {
                    temp = (d[3] - d[2]) / 2.0;
                    c = *rho + z[1] / (d[1] - d[2] - temp);
                    a = c * (d[2] + d[3]) + z[2] + z[3];
                    b = c * d[2] * d[3] + z[2] * d[3] + z[3] * d[2];
                }
                else
                {
                    temp = (d[1] - d[2]) / 2.0;
                    c = *rho + z[3] / (d[3] - d[2] - temp);
                    a = c * (d[1] + d[2]) + z[1] + z[2];
                    b = c * d[1] * d[2] + z[1] * d[2] + z[2] * d[1];
                }

                // Computing MAX
                d__1 = Math.Abs(a);
                d__2 = Math.Abs(b);
                d__1 = Math.Max(d__1, d__2);
                d__2 = Math.Abs(c);
                temp = Math.Max(d__1, d__2);
                a /= temp;
                b /= temp;
                c /= temp;

                if (c == 0.0)
                {
                    *tau = b / a;
                }
                else if (a <= 0.0)
                {
                    *tau = (a - Math.Sqrt(Math.Abs(a * a - b * 4.0 * c))) / (c * 2.0);
                }
                else
                {
                    *tau = b * 2.0 / (a + Math.Sqrt(Math.Abs(a * a - b * 4.0 * c)));
                }

                if (*tau < lbd || *tau > ubd)
                {
                    *tau = (lbd + ubd) / 2.0;
                }
                if (d[1] == *tau || d[2] == *tau || d[3] == *tau)
                {
                    *tau = 0.0;
                }
                else
                {
                    temp = *finit + *tau * z[1] / (d[1] * (d[1] - *tau)) + *tau * z[2] /
                        (d[2] * (d[2] - *tau)) + *tau * z[3] / (d[3] * (d[3] - *tau));

                    if (temp <= 0.0)
                    {
                        lbd = *tau;
                    }
                    else
                    {
                        ubd = *tau;
                    }

                    if (Math.Abs(*finit) <= Math.Abs(temp))
                    {
                        *tau = 0.0;
                    }
                }
            }

            // get machine parameters for possible scaling to avoid overflow

            // modified by Sven: parameters SMALL1, SMINV1, SMALL2,
            // SMINV2, EPS are not SAVEd anymore between one call to the
            // others but recomputed at each call

            eps = dlamch("Epsilon");
            base_ = dlamch("Base");
            i__1 = (int)(Math.Log(dlamch("SafMin")) / Math.Log(base_) / 3.0);
            small1 = pow_di(&base_, &i__1);
            sminv1 = 1.0 / small1;
            small2 = small1 * small1;
            sminv2 = sminv1 * sminv1;

            // Determine if scaling of inputs necessary to avoid overflow
            // when computing 1/TEMP**3

            if (*orgati)
            {
                // Computing MIN
                d__3 = Math.Abs(d[2] - *tau);
                d__4 = Math.Abs(d[3] - *tau);
                temp = Math.Min(d__3, d__4);
            }
            else
            {
                // Computing MIN
                d__3 = Math.Abs(d[1] - *tau);
                d__4 = Math.Abs(d[2] - *tau);
                temp = Math.Min(d__3, d__4);
            }

            scale = false;
            if (temp <= small1)
            {
                scale = true;
                if (temp <= small2)
                {
                    // Scale up by power of radix nearest 1/SAFMIN**(2/3)

                    sclfac = sminv2;
                    sclinv = small2;
                }
                else
                {
                    // Scale up by power of radix nearest 1/SAFMIN**(1/3)

                    sclfac = sminv1;
                    sclinv = small1;
                }

                // Scaling up safe because D, Z, TAU scaled elsewhere to be O(1)

                for (i = 1; i <= 3; ++i)
                {
                    dscale[i - 1] = d[i] * sclfac;
                    zscale[i - 1] = z[i] * sclfac;
                }
                *tau *= sclfac;
                lbd *= sclfac;
                ubd *= sclfac;
            }
            else
            {
                // Copy D and Z to DSCALE and ZSCALE

                for (i = 1; i <= 3; ++i)
                {
                    dscale[i - 1] = d[i];
                    zscale[i - 1] = z[i];
                }
            }

            fc = 0.0;
            df = 0.0;
            ddf = 0.0;
            for (i = 1; i <= 3; ++i)
            {
                temp = 1.0 / (dscale[i - 1] - *tau);
                temp1 = zscale[i - 1] * temp;
                temp2 = temp1 * temp;
                temp3 = temp2 * temp;
                fc += temp1 / dscale[i - 1];
                df += temp2;
                ddf += temp3;
            }

            f = *finit + *tau * fc;

            if (Math.Abs(f) <= 0.0)
            {
                goto L60;
            }
            if (f <= 0.0)
            {
                lbd = *tau;
            }
            else
            {
                ubd = *tau;
            }

            // Iteration begins -- Use Gragg-Thornton-Warner cubic convergent scheme

            // It is not hard to see that

            //      1) Iterations will go up monotonically
            //          if FINIT < 0;

            //      2) Iterations will go down monotonically
            //          if FINIT > 0.0

            iter = niter + 1;

            for (niter = iter; niter <= 40; ++niter)
            {
                if (*orgati)
                {
                    temp1 = dscale[1] - *tau;
                    temp2 = dscale[2] - *tau;
                }
                else
                {
                    temp1 = dscale[0] - *tau;
                    temp2 = dscale[1] - *tau;
                }

                a = (temp1 + temp2) * f - temp1 * temp2 * df;
                b = temp1 * temp2 * f;
                c = f - (temp1 + temp2) * df + temp1 * temp2 * ddf;
                // Computing MAX
                d__1 = Math.Abs(a);
                d__2 = Math.Abs(b);
                d__1 = Math.Max(d__1, d__2);
                d__2 = Math.Abs(c);
                temp = Math.Max(d__1, d__2);
                a /= temp;
                b /= temp;
                c /= temp;

                if (c == 0.0)
                {
                    eta = b / a;
                }
                else if (a <= 0.0)
                {
                    eta = (a - Math.Sqrt(Math.Abs(a * a - b * 4.0 * c))) / (c * 2.0);
                }
                else
                {
                    eta = b * 2.0 / (a + Math.Sqrt(Math.Abs(a * a - b * 4.0 * c)));
                }

                if (f * eta >= 0.0)
                {
                    eta = -f / df;
                }

                *tau += eta;
                if (*tau < lbd || *tau > ubd)
                {
                    *tau = (lbd + ubd) / 2.0;
                }

                fc = 0.0;
                erretm = 0.0;
                df = 0.0;
                ddf = 0.0;
                for (i = 1; i <= 3; ++i)
                {
                    temp = 1.0 / (dscale[i - 1] - *tau);
                    temp1 = zscale[i - 1] * temp;
                    temp2 = temp1 * temp;
                    temp3 = temp2 * temp;
                    temp4 = temp1 / dscale[i - 1];
                    fc += temp4;
                    erretm += Math.Abs(temp4);
                    df += temp2;
                    ddf += temp3;
                }
                f = *finit + *tau * fc;
                erretm = (Math.Abs(*finit) + Math.Abs(*tau) * erretm) * 8.0 + Math.Abs(*tau) * df;
                if (Math.Abs(f) <= eps * erretm)
                {
                    goto L60;
                }
                if (f <= 0.0)
                {
                    lbd = *tau;
                }
                else
                {
                    ubd = *tau;
                }
            }
            *info = 1;

        L60:
            // Undo scaling

            if (scale)
            {
                *tau *= sclinv;
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int dlamrg(int* n1, int* n2, double* a, int* dtrd1, int* dtrd2, int* index)
        {
            //  -- LAPACK routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     November 2006

            //  Purpose
            //  =======

            //  DLAMRG will create a permutation list which will merge the elements
            //  of A (which is composed of two independently sorted sets) into a
            //  single set which is sorted in ascending order.

            //  Arguments
            //  =========

            //  N1     (input) INTEGER
            //  N2     (input) INTEGER
            //         These arguements contain the respective lengths of the two
            //         sorted lists to be merged.

            //  A      (input) DOUBLE PRECISION array, dimension (N1+N2)
            //         The first N1 elements of A contain a list of numbers which
            //         are sorted in either ascending or descending order.  Likewise
            //         for the final N2 elements.

            //  DTRD1  (input) INTEGER
            //  DTRD2  (input) INTEGER
            //         These are the strides to be taken through the array A.
            //         Allowable strides are 1 and -1.0  They indicate whether a
            //         subset of A is sorted in ascending (DTRDx = 1) or descending
            //         (DTRDx = -1) order.

            //  INDEX  (output) INTEGER array, dimension (N1+N2)
            //         On exit this array will contain a permutation such that
            //         if B( I ) = A( INDEX( I ) ) for I=1,N1+N2, then B will be
            //         sorted in ascending order.

            //  =====================================================================

            // System generated locals
            int i__1;

            // Local variables
            int i, ind1, ind2, n1sv, n2sv;

            // Parameter adjustments
            --index;
            --a;

            // Function Body
            n1sv = *n1;
            n2sv = *n2;
            if (*dtrd1 > 0)
            {
                ind1 = 1;
            }
            else
            {
                ind1 = *n1;
            }
            if (*dtrd2 > 0)
            {
                ind2 = *n1 + 1;
            }
            else
            {
                ind2 = *n1 + *n2;
            }
            i = 1;

            // while ( (N1SV > 0) & (N2SV > 0) )
        L10:
            if (n1sv > 0 && n2sv > 0)
            {
                if (a[ind1] <= a[ind2])
                {
                    index[i] = ind1;
                    ++i;
                    ind1 += *dtrd1;
                    --n1sv;
                }
                else
                {
                    index[i] = ind2;
                    ++i;
                    ind2 += *dtrd2;
                    --n2sv;
                }
                goto L10;
            }
            // end while

            if (n1sv == 0)
            {
                i__1 = n2sv;
                for (n1sv = 1; n1sv <= i__1; ++n1sv)
                {
                    index[i] = ind2;
                    ++i;
                    ind2 += *dtrd2;
                }
            }
            else
            {
                // N2SV .EQ. 0
                i__1 = n1sv;
                for (n2sv = 1; n2sv <= i__1; ++n2sv)
                {
                    index[i] = ind1;
                    ++i;
                    ind1 += *dtrd1;
                }
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static double dlanst(string norm, int* n, double* d, double* e)
        {
            //  -- LAPACK auxiliary routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     November 2006

            //  Purpose
            //  =======

            //  DLANST  returns the value of the one norm,  or the Frobenius norm, or
            //  the  infinity norm,  or the  element of  largest absolute value  of a
            //  real symmetric tridiagonal matrix A.

            //  Description
            //  ===========

            //  DLANST returns the value

            //     DLANST = ( max(abs(A(i,j))), NORM = 'M' or 'm'
            //              (
            //              ( norm1(A),         NORM = '1', 'O' or 'o'
            //              (
            //              ( normI(A),         NORM = 'I' or 'i'
            //              (
            //              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'

            //  where  norm1  denotes the  one norm of a matrix (maximum column sum),
            //  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            //  normF  denotes the  Frobenius norm of a matrix (square root of sum of
            //  squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.

            //  Arguments
            //  =========

            //  NORM    (input) CHARACTER*1
            //          Specifies the value to be returned in DLANST as described
            //          above.

            //  N       (input) int
            //          The order of the matrix A.  N >= 0.  When N = 0, DLANST is
            //          set to zero.

            //  D       (input) DOUBLE PRECISION array, dimension (N)
            //          The diagonal elements of A.

            //  E       (input) DOUBLE PRECISION array, dimension (N-1)
            //          The (n-1) sub-diagonal or super-diagonal elements of A.

            //  =====================================================================

            // System generated locals
            int i__1;
            double ret_val, d__2, d__3, d__4, d__5;

            // Table of constant values
            int c__1 = 1;

            // Local variables
            int i;
            double sum, scale;
            double anorm = 0;

            // Parameter adjustments
            --e;
            --d;

            // Function Body
            if (*n <= 0)
            {
                anorm = 0.0;
            }
            else if (lsame(norm, "M"))
            {
                // Find max(abs(A(i,j))).

                anorm = Math.Abs(d[*n]);
                i__1 = *n - 1;
                for (i = 1; i <= i__1; ++i)
                {
                    // Computing MAX
                    d__2 = anorm;
                    d__3 = Math.Abs(d[i]);
                    anorm = Math.Max(d__2, d__3);
                    // Computing MAX
                    d__2 = anorm;
                    d__3 = Math.Abs(e[i]);
                    anorm = Math.Max(d__2, d__3);
                }
            }
            else if (lsame(norm, "O") || norm[0] == '1' || lsame(norm, "I"))
            {
                // Find norm1(A).

                if (*n == 1)
                {
                    anorm = Math.Abs(d[1]);
                }
                else
                {
                    // Computing MAX
                    d__3 = Math.Abs(d[1]) + Math.Abs(e[1]);
                    d__4 = Math.Abs(e[*n - 1]) + Math.Abs(d[*n]);
                    anorm = Math.Max(d__3, d__4);
                    i__1 = *n - 1;
                    for (i = 2; i <= i__1; ++i)
                    {
                        // Computing MAX
                        d__4 = anorm;
                        d__5 = Math.Abs(d[i]) + Math.Abs(e[i]) + Math.Abs(e[i - 1]);
                        anorm = Math.Max(d__4, d__5);
                    }
                }
            }
            else if (lsame(norm, "F") || lsame(norm, "E"))
            {
                // Find normF(A).

                scale = 0.0;
                sum = 1.0;
                if (*n > 1)
                {
                    i__1 = *n - 1;
                    dlassq(&i__1, &e[1], &c__1, &scale, &sum);
                    sum *= 2;
                }
                dlassq(n, &d[1], &c__1, &scale, &sum);
                anorm = scale * Math.Sqrt(sum);
            }

            ret_val = anorm;
            return ret_val;
        }

        [SuppressUnmanagedCodeSecurity]
        public static double dlapy2(double* x, double* y)
        {
            //  -- LAPACK auxiliary routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. 
            //     November 2006 

            //  Purpose 
            //  ======= 

            //  DLAPY2 returns sqrt(x**2+y**2), taking care not to cause unnecessary 
            //  overflow. 

            //  Arguments 
            //  ========= 

            //  X       (input) DOUBLE PRECISION 
            //  Y       (input) DOUBLE PRECISION 
            //          X and Y specify the values x and y. 

            //  ===================================================================== 

            // System generated locals 
            double ret_val, d__1;

            // Local variables 
            double w, z, xabs, yabs;

            xabs = Math.Abs(*x);
            yabs = Math.Abs(*y);
            w = Math.Max(xabs, yabs);
            z = Math.Min(xabs, yabs);

            if (z == 0.0)
            {
                ret_val = w;
            }
            else
            {
                // Computing 2nd power 
                d__1 = z / w;
                ret_val = w * Math.Sqrt(d__1 * d__1 + 1.0);
            }

            return ret_val;
        }

        [SuppressUnmanagedCodeSecurity]
        public static double dlapy3(double* x, double* y, double* z)
        {
            //  -- LAPACK auxiliary routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. 
            //     November 2006 

            //  Purpose 
            //  ======= 

            //  DLAPY3 returns sqrt(x**2+y**2+z**2), taking care not to cause 
            //  unnecessary overflow. 

            //  Arguments 
            //  ========= 

            //  X       (input) DOUBLE PRECISION 
            //  Y       (input) DOUBLE PRECISION 
            //  Z       (input) DOUBLE PRECISION 
            //          X, Y and Z specify the values x, y and z. 

            //  ===================================================================== 

            // System generated locals 
            double ret_val, d__1, d__2, d__3;

            // Local variables 
            double w, xabs, yabs, zabs;

            xabs = Math.Abs(*x);
            yabs = Math.Abs(*y);
            zabs = Math.Abs(*z);

            // Computing MAX 
            d__1 = Math.Max(xabs, yabs);
            w = Math.Max(d__1, zabs);

            if (w == 0.0)
            {
                // W can be zero for max(0,nan,0) 
                // adding all three entries together will make sure 
                // NaN will not disappear. 
                ret_val = xabs + yabs + zabs;
            }
            else
            {
                // Computing 2nd power 
                d__1 = xabs / w;
                // Computing 2nd power 
                d__2 = yabs / w;
                // Computing 2nd power 
                d__3 = zabs / w;
                ret_val = w * Math.Sqrt(d__1 * d__1 + d__2 * d__2 + d__3 * d__3);
            }

            return ret_val;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int dlartg(double* f, double* g, double* cs, double* sn, double* r)
        {
            //  -- LAPACK auxiliary routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     November 2006

            //  Purpose
            //  =======

            //  DLARTG generate a plane rotation so that

            //     [  CS  SN  ]  .  [ F ]  =  [ R ]   where CS**2 + SN**2 = 1.
            //     [ -SN  CS  ]     [ G ]     [ 0 ]

            //  This is a slower, more accurate version of the BLAS1 routine DROTG,
            //  with the following other differences:
            //     F and G are unchanged on return.
            //     If G=0, then CS=1 and SN=0.
            //     If F=0 and (G .ne. 0), then CS=0 and SN=1 without doing any
            //        floating point operations (saves work in DBDSQR when
            //        there are zeros on the diagonal).

            //  If F exceeds G in magnitude, CS will be positive.

            //  Arguments
            //  =========

            //  F       (input) DOUBLE PRECISION
            //          The first component of vector to be rotated.

            //  G       (input) DOUBLE PRECISION
            //          The second component of vector to be rotated.

            //  CS      (output) DOUBLE PRECISION
            //          The cosine of the rotation.

            //  SN      (output) DOUBLE PRECISION
            //          The sine of the rotation.

            //  R       (output) DOUBLE PRECISION
            //          The nonzero component of the rotated vector.

            //  This version has a few statements commented out for thread safety
            //  (machine parameters are computed on each entry). 10 feb 03, SJH.

            //  =====================================================================

            // System generated locals
            int i__1;
            double d__1, d__2;

            // Local variables
            int i;
            double f1, g1, eps, scale;
            int count;
            double safmn2, safmx2;
            double safmin;

            // IF( FIRST ) THEN
            safmin = dlamch("S");
            eps = dlamch("E");
            d__1 = dlamch("B");
            i__1 = (int)(Math.Log(safmin / eps) / Math.Log(dlamch("B")) / 2.0);
            safmn2 = pow_di(&d__1, &i__1);
            safmx2 = 1.0 / safmn2;

            // FIRST = .FALSE.
            // END IF
            if (*g == 0.0)
            {
                *cs = 1.0;
                *sn = 0.0;
                *r = *f;
            }
            else if (*f == 0.0)
            {
                *cs = 0.0;
                *sn = 1.0;
                *r = *g;
            }
            else
            {
                f1 = *f;
                g1 = *g;
                // Computing MAX
                d__1 = Math.Abs(f1);
                d__2 = Math.Abs(g1);
                scale = Math.Max(d__1, d__2);

                if (scale >= safmx2)
                {
                    count = 0;

                L10:
                    ++count;
                    f1 *= safmn2;
                    g1 *= safmn2;
                    // Computing MAX
                    d__1 = Math.Abs(f1);
                    d__2 = Math.Abs(g1);
                    scale = Math.Max(d__1, d__2);
                    if (scale >= safmx2)
                    {
                        goto L10;
                    }
                    // Computing 2nd power
                    d__1 = f1;
                    // Computing 2nd power
                    d__2 = g1;
                    *r = Math.Sqrt(d__1 * d__1 + d__2 * d__2);
                    *cs = f1 / *r;
                    *sn = g1 / *r;
                    i__1 = count;
                    for (i = 1; i <= i__1; ++i)
                    {
                        *r *= safmx2;
                    }
                }
                else if (scale <= safmn2)
                {
                    count = 0;
                L30:
                    ++count;
                    f1 *= safmx2;
                    g1 *= safmx2;
                    // Computing MAX
                    d__1 = Math.Abs(f1);
                    d__2 = Math.Abs(g1);
                    scale = Math.Max(d__1, d__2);
                    if (scale <= safmn2)
                    {
                        goto L30;
                    }
                    // Computing 2nd power
                    d__1 = f1;
                    // Computing 2nd power
                    d__2 = g1;
                    *r = Math.Sqrt(d__1 * d__1 + d__2 * d__2);
                    *cs = f1 / *r;
                    *sn = g1 / *r;
                    i__1 = count;
                    for (i = 1; i <= i__1; ++i)
                    {
                        *r *= safmn2;
                    }
                }
                else
                {
                    // Computing 2nd power
                    d__1 = f1;
                    // Computing 2nd power
                    d__2 = g1;
                    *r = Math.Sqrt(d__1 * d__1 + d__2 * d__2);
                    *cs = f1 / *r;
                    *sn = g1 / *r;
                }
                if (Math.Abs(*f) > Math.Abs(*g) && *cs < 0.0)
                {
                    *cs = -(*cs);
                    *sn = -(*sn);
                    *r = -(*r);
                }
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int dlas2(double* f, double* g, double* h, double* ssmin, double* ssmax)
        {
            //  -- LAPACK auxiliary routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     November 2006

            //  Purpose
            //  =======

            //  DLAS2  computes the singular values of the 2-by-2 matrix
            //     [  F   G  ]
            //     [  0   H  ].
            //  On return, SSMIN is the smaller singular value and SSMAX is the
            //  larger singular value.

            //  Arguments
            //  =========

            //  F       (input) DOUBLE PRECISION
            //          The (1,1) element of the 2-by-2 matrix.

            //  G       (input) DOUBLE PRECISION
            //          The (1,2) element of the 2-by-2 matrix.

            //  H       (input) DOUBLE PRECISION
            //          The (2,2) element of the 2-by-2 matrix.

            //  SSMIN   (output) DOUBLE PRECISION
            //          The smaller singular value.

            //  SSMAX   (output) DOUBLE PRECISION
            //          The larger singular value.

            //  Further Details
            //  ===============

            //  Barring over/underflow, all output quantities are correct to within
            //  a few units in the las_t place (ulps), even in the absence of a guard
            //  digit in addition/subtraction.

            //  In IEEE arithmetic, the code works correctly if one matrix element is
            //  infinite.

            //  Overflow will not occur unless the largest singular value itself
            //  overflows, or is within a few ulps of overflow. (On machines with
            //  partial overflow, like the Cray, overflow may occur if the largest
            //  singular value is within a factor of 2 of overflow.)

            //  Underflow is harmless if underflow is gradual. Otherwise, results
            //  may correspond to a matrix modified by perturbations of size near
            //  the underflow threshold.

            //  ====================================================================

            // System generated locals
            double d__1, d__2;

            // Local variables
            double c, fa, ga, ha, as_, at, au, fhmn, fhmx;

            fa = Math.Abs(*f);
            ga = Math.Abs(*g);
            ha = Math.Abs(*h);
            fhmn = Math.Min(fa, ha);
            fhmx = Math.Max(fa, ha);

            if (fhmn == 0.0)
            {
                *ssmin = 0.0;
                if (fhmx == 0.0)
                {
                    *ssmax = ga;
                }
                else
                {
                    // Computing 2nd power
                    d__1 = Math.Min(fhmx, ga) / Math.Max(fhmx, ga);
                    *ssmax = Math.Max(fhmx, ga) * Math.Sqrt(d__1 * d__1 + 1.0);
                }
            }
            else
            {
                if (ga < fhmx)
                {
                    as_ = fhmn / fhmx + 1.0;
                    at = (fhmx - fhmn) / fhmx;
                    // Computing 2nd power
                    d__1 = ga / fhmx;
                    au = d__1 * d__1;
                    c = 2.0 / (Math.Sqrt(as_ * as_ + au) + Math.Sqrt(at * at + au));
                    *ssmin = fhmn * c;
                    *ssmax = fhmx / c;
                }
                else
                {
                    au = fhmx / ga;
                    if (au == 0.0)
                    {
                        // Avoid possible harmful underflow if exponent range
                        // asymmetric (true SSMIN may not underflow even if
                        // AU underflows)

                        *ssmin = fhmn * fhmx / ga;
                        *ssmax = ga;
                    }
                    else
                    {
                        as_ = fhmn / fhmx + 1.0;
                        at = (fhmx - fhmn) / fhmx;
                        // Computing 2nd power
                        d__1 = as_ * au;
                        // Computing 2nd power
                        d__2 = at * au;
                        c = 1.0 / (Math.Sqrt(d__1 * d__1 + 1.0) + Math.Sqrt(d__2 * d__2 + 1.0));
                        *ssmin = fhmn * c * au;
                        *ssmin += *ssmin;
                        *ssmax = ga / (c + c);
                    }
                }
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int dlascl(string type, int* kl, int* ku,
            double* cfrom, double* cto, int* m, int* n, double* a, int* lda, int* info)
        {
            //  -- LAPACK auxiliary routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. 
            //     November 2006 

            //  Purpose 
            //  ======= 

            //  DLASCL multiplies the M by N real matrix A by the real scalar 
            //  CTO/CFROM.  This is done without over/underflow as int as the final 
            //  result CTO*A(I,J)/CFROM does not over/underflow. TYPE specifies that 
            //  A may be full, upper triangular, lower triangular, upper Hessenberg, 
            //  or banded. 

            //  Arguments 
            //  ========= 

            //  TYPE    (input) CHARACTER*1 
            //          TYPE indices the storage type of the input matrix. 
            //          = 'G':  A is a full matrix. 
            //          = 'L':  A is a lower triangular matrix. 
            //          = 'U':  A is an upper triangular matrix. 
            //          = 'H':  A is an upper Hessenberg matrix. 
            //          = 'B':  A is a symmetric band matrix with lower bandwidth KL 
            //                  and upper bandwidth KU and with the only the lower 
            //                  half stored. 
            //          = 'Q':  A is a symmetric band matrix with lower bandwidth KL 
            //                  and upper bandwidth KU and with the only the upper 
            //                  half stored. 
            //          = 'Z':  A is a band matrix with lower bandwidth KL and upper 
            //                  bandwidth KU. 

            //  KL      (input) int 
            //          The lower bandwidth of A.  Referenced only if TYPE = 'B', 
            //          'Q' or 'Z'. 

            //  KU      (input) int 
            //          The upper bandwidth of A.  Referenced only if TYPE = 'B', 
            //          'Q' or 'Z'. 

            //  CFROM   (input) DOUBLE PRECISION 
            //  CTO     (input) DOUBLE PRECISION 
            //          The matrix A is multiplied by CTO/CFROM. A(I,J) is computed 
            //          without over/underflow if the final result CTO*A(I,J)/CFROM 
            //          can be represented without over/underflow.  CFROM must be 
            //          nonzero. 

            //  M       (input) int 
            //          The number of rows of the matrix A.  M >= 0. 

            //  N       (input) int 
            //          The number of columns of the matrix A.  N >= 0. 

            //  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N) 
            //          The matrix to be multiplied by CTO/CFROM.  See TYPE for the 
            //          storage type. 

            //  LDA     (input) int 
            //          The leading dimension of the array A.  LDA >= max(1,M). 

            //  INFO    (output) int 
            //          0  - successful exit 
            //          <0 - if INFO = -i, the i-th argument had an illegal value. 

            //  ===================================================================== 

            // System generated locals 
            int a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5;

            // Local variables 
            int i, j, k1, k2, k3, k4;
            double mul, cto1;
            bool done;
            double ctoc;
            int itype;
            double cfrom1;
            double cfromc;
            double bignum, smlnum;

            // Parameter adjustments 
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;

            // Function Body 
            *info = 0;

            if (lsame(type, "G"))
            {
                itype = 0;
            }
            else if (lsame(type, "L"))
            {
                itype = 1;
            }
            else if (lsame(type, "U"))
            {
                itype = 2;
            }
            else if (lsame(type, "H"))
            {
                itype = 3;
            }
            else if (lsame(type, "B"))
            {
                itype = 4;
            }
            else if (lsame(type, "Q"))
            {
                itype = 5;
            }
            else if (lsame(type, "Z"))
            {
                itype = 6;
            }
            else
            {
                itype = -1;
            }

            if (itype == -1)
            {
                *info = -1;
            }
            else if (*cfrom == 0.0 || disnan(cfrom))
            {
                *info = -4;
            }
            else if (disnan(cto))
            {
                *info = -5;
            }
            else if (*m < 0)
            {
                *info = -6;
            }
            else if (*n < 0 || itype == 4 && *n != *m || itype == 5 && *n != *m)
            {
                *info = -7;
            }
            else if (itype <= 3 && *lda < Math.Max(1, *m))
            {
                *info = -9;
            }
            else if (itype >= 4)
            {
                // Computing MAX 
                i__1 = *m - 1;
                if (*kl < 0 || *kl > Math.Max(i__1, 0))
                {
                    *info = -2;
                }
                else // if(complicated condition) 
                {
                    // Computing MAX 
                    i__1 = *n - 1;
                    if (*ku < 0 || *ku > Math.Max(i__1, 0) || (itype == 4 || itype == 5) && *kl != *ku)
                    {
                        *info = -3;
                    }
                    else if (itype == 4 && *lda < *kl + 1 || itype == 5 && *lda < *ku + 1 || itype == 6 && *lda < (*kl << 1) + *ku + 1)
                    {
                        *info = -9;
                    }
                }
            }

            if (*info != 0)
            {
                i__1 = -(*info);
                xerbla("DLASCL", &i__1);
                return 0;
            }

            // Quick return if possible 

            if (*n == 0 || *m == 0)
            {
                return 0;
            }

            // Get machine parameters 

            smlnum = dlamch("S");
            bignum = 1.0 / smlnum;

            cfromc = *cfrom;
            ctoc = *cto;

        L10:
            cfrom1 = cfromc * smlnum;
            if (cfrom1 == cfromc)
            {
                // CFROMC is an inf.  Multiply by a correctly signed zero for 
                // finite CTOC, or a NaN if CTOC is infinite. 
                mul = ctoc / cfromc;
                done = true;
                cto1 = ctoc;
            }
            else
            {
                cto1 = ctoc / bignum;
                if (cto1 == ctoc)
                {
                    // CTOC is either 0 or an inf.  In both cases, CTOC itself 
                    // serves as the correct multiplication factor. 
                    mul = ctoc;
                    done = true;
                    cfromc = 1.0;
                }
                else if (Math.Abs(cfrom1) > Math.Abs(ctoc) && ctoc != 0.0)
                {
                    mul = smlnum;
                    done = false;
                    cfromc = cfrom1;
                }
                else if (Math.Abs(cto1) > Math.Abs(cfromc))
                {
                    mul = bignum;
                    done = false;
                    ctoc = cto1;
                }
                else
                {
                    mul = ctoc / cfromc;
                    done = true;
                }
            }

            if (itype == 0)
            {
                // Full matrix 
                i__1 = *n;
                for (j = 1; j <= i__1; ++j)
                {
                    i__2 = *m;
                    for (i = 1; i <= i__2; ++i)
                    {
                        a[i + j * a_dim1] *= mul;
                    }
                }
            }
            else if (itype == 1)
            {
                // Lower triangular matrix 
                i__1 = *n;
                for (j = 1; j <= i__1; ++j)
                {
                    i__2 = *m;
                    for (i = j; i <= i__2; ++i)
                    {
                        a[i + j * a_dim1] *= mul;
                    }
                }
            }
            else if (itype == 2)
            {
                // Upper triangular matrix 
                i__1 = *n;
                for (j = 1; j <= i__1; ++j)
                {
                    i__2 = Math.Min(j, *m);
                    for (i = 1; i <= i__2; ++i)
                    {
                        a[i + j * a_dim1] *= mul;
                    }
                }
            }
            else if (itype == 3)
            {
                // Upper Hessenberg matrix 
                i__1 = *n;
                for (j = 1; j <= i__1; ++j)
                {
                    // Computing MIN 
                    i__3 = j + 1;
                    i__2 = Math.Min(i__3, *m);

                    for (i = 1; i <= i__2; ++i)
                    {
                        a[i + j * a_dim1] *= mul;
                    }
                }

            }
            else if (itype == 4)
            {
                // Lower half of a symmetric band matrix 
                k3 = *kl + 1;
                k4 = *n + 1;
                i__1 = *n;
                for (j = 1; j <= i__1; ++j)
                {
                    // Computing MIN 
                    i__3 = k3;
                    i__4 = k4 - j;
                    i__2 = Math.Min(i__3, i__4);

                    for (i = 1; i <= i__2; ++i)
                    {
                        a[i + j * a_dim1] *= mul;
                    }
                }
            }
            else if (itype == 5)
            {
                // Upper half of a symmetric band matrix 
                k1 = *ku + 2;
                k3 = *ku + 1;
                i__1 = *n;
                for (j = 1; j <= i__1; ++j)
                {
                    // Computing MAX 
                    i__2 = k1 - j;
                    i__3 = k3;

                    for (i = Math.Max(i__2, 1); i <= i__3; ++i)
                    {
                        a[i + j * a_dim1] *= mul;
                    }
                }

            }
            else if (itype == 6)
            {
                // Band matrix 
                k1 = *kl + *ku + 2;
                k2 = *kl + 1;
                k3 = (*kl << 1) + *ku + 1;
                k4 = *kl + *ku + 1 + *m;
                i__1 = *n;
                for (j = 1; j <= i__1; ++j)
                {
                    // Computing MAX 
                    i__3 = k1 - j;
                    // Computing MIN 
                    i__4 = k3;
                    i__5 = k4 - j;
                    i__2 = Math.Min(i__4, i__5);

                    for (i = Math.Max(i__3, k2); i <= i__2; ++i)
                    {
                        a[i + j * a_dim1] *= mul;
                    }
                }
            }

            if (!done)
            {
                goto L10;
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int dlasd0(int* n, int* sqre, double* d, double* e, double* u,
            int* ldu, double* vt, int* ldvt, int* smlsiz, int* iwork, double* work, int* info)
        {
            //  -- LAPACK auxiliary routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     November 2006

            //  Purpose
            //  =======

            //  Using a divide and conquer approach, DLASD0 computes the singular
            //  value decomposition (SVD) of a float upper bidiagonal N-by-M
            //  matrix B with diagonal D and offdiagonal E, where M = N + SQRE.
            //  The algorithm computes orthogonal matrices U and VT such that
            //  B = U * S * VT. The singular values S are overwritten on D.

            //  A related subroutine, DLASDA, computes only the singular values,
            //  and optionally, the singular vectors in compact form.

            //  Arguments
            //  =========

            //  N      (input) INTEGER
            //         On entry, the row dimension of the upper bidiagonal matrix.
            //         This is also the dimension of the main diagonal array D.

            //  SQRE   (input) INTEGER
            //         Specifies the column dimension of the bidiagonal matrix.
            //         = 0: The bidiagonal matrix has column dimension M = N;
            //         = 1: The bidiagonal matrix has column dimension M = N+1;

            //  D      (input/output) DOUBLE PRECISION array, dimension (N)
            //         On entry D contains the main diagonal of the bidiagonal
            //         matrix.
            //         On exit D, if INFO = 0, contains its singular values.

            //  E      (input) DOUBLE PRECISION array, dimension (M-1)
            //         Contains the subdiagonal entries of the bidiagonal matrix.
            //         On exit, E has been destroyed.

            //  U      (output) DOUBLE PRECISION array, dimension at least (LDQ, N)
            //         On exit, U contains the left singular vectors.

            //  LDU    (input) INTEGER
            //         On entry, leading dimension of U.

            //  VT     (output) DOUBLE PRECISION array, dimension at least (LDVT, M)
            //         On exit, VT' contains the right singular vectors.

            //  LDVT   (input) INTEGER
            //         On entry, leading dimension of VT.

            //  SMLSIZ (input) INTEGER
            //         On entry, maximum size of the subproblems at the
            //         bottom of the computation tree.

            //  IWORK  (workspace) INTEGER work array.
            //         Dimension must be at least (8 * N)

            //  WORK   (workspace) DOUBLE PRECISION work array.
            //         Dimension must be at least (3 * M**2 + 2 * M)

            //  INFO   (output) INTEGER
            //          = 0:  successful exit.
            //          < 0:  if INFO = -i, the i-th argument had an illegal value.
            //          > 0:  if INFO = 1, an singular value did not converge

            //  Further Details
            //  ===============

            //  Based on contributions by
            //     Ming Gu and Huan Ren, Computer Science Division, University of
            //     California at Berkeley, USA

            //  =====================================================================

            // System generated locals
            int u_dim1, u_offset, vt_dim1, vt_offset, i__1, i__2;

            // Table of constant values
            int c__0 = 0;
            int c__2 = 2;

            // Local variables
            int i, j, m, i1, ic, lf, nd, ll, nl, nr, im1, ncc, nlf, nrf, iwk, lvl, ndb1, nlp1, nrp1;
            double beta;
            int idxq, nlvl;
            double alpha;
            int inode, ndiml, idxqc, ndimr, itemp, sqrei;

            // Parameter adjustments
            --d;
            --e;
            u_dim1 = *ldu;
            u_offset = 1 + u_dim1;
            u -= u_offset;
            vt_dim1 = *ldvt;
            vt_offset = 1 + vt_dim1;
            vt -= vt_offset;
            --iwork;
            --work;

            // Function Body
            *info = 0;

            if (*n < 0)
            {
                *info = -1;
            }
            else if (*sqre < 0 || *sqre > 1)
            {
                *info = -2;
            }

            m = *n + *sqre;

            if (*ldu < *n)
            {
                *info = -6;
            }
            else if (*ldvt < m)
            {
                *info = -8;
            }
            else if (*smlsiz < 3)
            {
                *info = -9;
            }

            if (*info != 0)
            {
                i__1 = -(*info);
                xerbla("DLASD0", &i__1);
                return 0;
            }

            // If the input matrix is too small, call DLASDQ to find the SVD.

            if (*n <= *smlsiz)
            {
                dlasdq("U", sqre, n, &m, n, &c__0, &d[1], &e[1], &vt[vt_offset],
                    ldvt, &u[u_offset], ldu, &u[u_offset], ldu, &work[1], info);
                return 0;
            }

            // Set up the computation tree.

            inode = 1;
            ndiml = inode + *n;
            ndimr = ndiml + *n;
            idxq = ndimr + *n;
            iwk = idxq + *n;
            dlasdt(n, &nlvl, &nd, &iwork[inode], &iwork[ndiml], &iwork[ndimr], smlsiz);

            // For the nodes on bottom level of the tree, solve
            // their subproblems by DLASDQ.

            ndb1 = (nd + 1) / 2;
            ncc = 0;
            i__1 = nd;
            for (i = ndb1; i <= i__1; ++i)
            {
                // IC : center row of each node
                // NL : number of rows of left  subproblem
                // NR : number of rows of right subproblem
                // NLF: starting row of the left   subproblem
                // NRF: starting row of the right  subproblem

                i1 = i - 1;
                ic = iwork[inode + i1];
                nl = iwork[ndiml + i1];
                nlp1 = nl + 1;
                nr = iwork[ndimr + i1];
                nrp1 = nr + 1;
                nlf = ic - nl;
                nrf = ic + 1;
                sqrei = 1;

                dlasdq("U", &sqrei, &nl, &nlp1, &nl, &ncc, &d[nlf], &e[nlf], &vt[nlf + nlf * vt_dim1],
                    ldvt, &u[nlf + nlf * u_dim1], ldu, &u[nlf + nlf * u_dim1], ldu, &work[1], info);

                if (*info != 0)
                {
                    return 0;
                }

                itemp = idxq + nlf - 2;

                i__2 = nl;
                for (j = 1; j <= i__2; ++j)
                {
                    iwork[itemp + j] = j;
                }

                if (i == nd)
                {
                    sqrei = *sqre;
                }
                else
                {
                    sqrei = 1;
                }

                nrp1 = nr + sqrei;
                dlasdq("U", &sqrei, &nr, &nrp1, &nr, &ncc, &d[nrf], &e[nrf], &vt[nrf + nrf * vt_dim1],
                    ldvt, &u[nrf + nrf * u_dim1], ldu, &u[nrf + nrf * u_dim1], ldu, &work[1], info);

                if (*info != 0)
                {
                    return 0;
                }

                itemp = idxq + ic;

                i__2 = nr;
                for (j = 1; j <= i__2; ++j)
                {
                    iwork[itemp + j - 1] = j;
                }
            }

            // Now conquer each subproblem bottom-up.

            for (lvl = nlvl; lvl >= 1; --lvl)
            {
                // Find the first node LF and last node LL on the
                // current level LVL.

                if (lvl == 1)
                {
                    lf = 1;
                    ll = 1;
                }
                else
                {
                    i__1 = lvl - 1;
                    lf = pow_ii(&c__2, &i__1);
                    ll = (lf << 1) - 1;
                }

                i__1 = ll;
                for (i = lf; i <= i__1; ++i)
                {
                    im1 = i - 1;
                    ic = iwork[inode + im1];
                    nl = iwork[ndiml + im1];
                    nr = iwork[ndimr + im1];
                    nlf = ic - nl;

                    if (*sqre == 0 && i == ll)
                    {
                        sqrei = *sqre;
                    }
                    else
                    {
                        sqrei = 1;
                    }

                    idxqc = idxq + nlf - 1;
                    alpha = d[ic];
                    beta = e[ic];

                    dlasd1(&nl, &nr, &sqrei, &d[nlf], &alpha, &beta, &u[nlf + nlf * u_dim1], ldu,
                        &vt[nlf + nlf * vt_dim1], ldvt, &iwork[idxqc], &iwork[iwk], &work[1], info);

                    if (*info != 0)
                    {
                        return 0;
                    }
                }
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int dlasd1(int* nl, int* nr, int* sqre, double* d, double* alpha,
            double* beta, double* u, int* ldu, double* vt, int* ldvt, int* idxq, int* iwork, double* work, int* info)
        {
            //  -- LAPACK auxiliary routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     November 2006

            //  Purpose
            //  =======

            //  DLASD1 computes the SVD of an upper bidiagonal N-by-M matrix B,
            //  where N = NL + NR + 1 and M = N + SQRE. DLASD1 is called from DLASD0.0

            //  A related subroutine DLASD7 handles the case in which the singular
            //  values (and the singular vectors in factored form) are desired.

            //  DLASD1 computes the SVD as follows:

            //                ( D1(in)  0    0     0 )
            //    B = U(in) * (   Z1'   a   Z2'    b ) * VT(in)
            //                (   0     0   D2(in) 0 )

            //      = U(out) * ( D(out) 0) * VT(out)

            //  where Z' = (Z1' a Z2' b) = u' VT', and u is a vector of dimension M
            //  with ALPHA and BETA in the NL+1 and NL+2 th entries and zeros
            //  elsewhere; and the entry b is empty if SQRE = 0.0

            //  The left singular vectors of the original matrix are stored in U, and
            //  the transpose of the right singular vectors are stored in VT, and the
            //  singular values are in D.  The algorithm consists of three stages:

            //     The first stage consists of deflating the size of the problem
            //     when there are multiple singular values or when there are zeros in
            //     the Z vector.  For each such occurence the dimension of the
            //     secular equation problem is reduced by one.  This stage is
            //     performed by the routine DLASD2.0

            //     The second stage consists of calculating the updated
            //     singular values. This is done by finding the square roots of the
            //     roots of the secular equation via the routine DLASD4 (as called
            //     by DLASD3). This routine also calculates the singular vectors of
            //     the current problem.

            //     The final stage consists of computing the updated singular vectors
            //     directly using the updated singular values.  The singular vectors
            //     for the current problem are multiplied with the singular vectors
            //     from the overall problem.

            //  Arguments
            //  =========

            //  NL     (input) INTEGER
            //         The row dimension of the upper block.  NL >= 1.0

            //  NR     (input) INTEGER
            //         The row dimension of the lower block.  NR >= 1.0

            //  SQRE   (input) INTEGER
            //         = 0: the lower block is an NR-by-NR square matrix.
            //         = 1: the lower block is an NR-by-(NR+1) rectangular matrix.

            //         The bidiagonal matrix has row dimension N = NL + NR + 1,
            //         and column dimension M = N + SQRE.

            //  D      (input/output) DOUBLE PRECISION array,
            //                        dimension (N = NL+NR+1).
            //         On entry D(1:NL,1:NL) contains the singular values of the
            //         upper block; and D(NL+2:N) contains the singular values of
            //         the lower block. On exit D(1:N) contains the singular values
            //         of the modified matrix.

            //  ALPHA  (input/output) DOUBLE PRECISION
            //         Contains the diagonal element associated with the added row.

            //  BETA   (input/output) DOUBLE PRECISION
            //         Contains the off-diagonal element associated with the added
            //         row.

            //  U      (input/output) DOUBLE PRECISION array, dimension(LDU,N)
            //         On entry U(1:NL, 1:NL) contains the left singular vectors of
            //         the upper block; U(NL+2:N, NL+2:N) contains the left singular
            //         vectors of the lower block. On exit U contains the left
            //         singular vectors of the bidiagonal matrix.

            //  LDU    (input) INTEGER
            //         The leading dimension of the array U.  LDU >= max( 1, N ).

            //  VT     (input/output) DOUBLE PRECISION array, dimension(LDVT,M)
            //         where M = N + SQRE.
            //         On entry VT(1:NL+1, 1:NL+1)' contains the right singular
            //         vectors of the upper block; VT(NL+2:M, NL+2:M)' contains
            //         the right singular vectors of the lower block. On exit
            //         VT' contains the right singular vectors of the
            //         bidiagonal matrix.

            //  LDVT   (input) INTEGER
            //         The leading dimension of the array VT.  LDVT >= max( 1, M ).

            //  IDXQ  (output) INTEGER array, dimension(N)
            //         This contains the permutation which will reintegrate the
            //         subproblem just solved back into sorted order, i.e.
            //         D( IDXQ( I = 1, N ) ) will be in ascending order.

            //  IWORK  (workspace) INTEGER array, dimension( 4 * N )

            //  WORK   (workspace) DOUBLE PRECISION array, dimension( 3*M**2 + 2*M )

            //  INFO   (output) INTEGER
            //          = 0:  successful exit.
            //          < 0:  if INFO = -i, the i-th argument had an illegal value.
            //          > 0:  if INFO = 1, an singular value did not converge

            //  Further Details
            //  ===============

            //  Based on contributions by
            //     Ming Gu and Huan Ren, Computer Science Division, University of
            //     California at Berkeley, USA

            //  =====================================================================

            // System generated locals
            int u_dim1, u_offset, vt_dim1, vt_offset, i__1;
            double d__1, d__2;

            // Table of constant values
            int c__0 = 0;
            double c_b7 = 1.0;
            int c__1 = 1;
            int c_n1 = -1;

            // Local variables
            int i, k, m, n, n1, n2, iq, iz, iu2, ldq, idx, ldu2, ivt2, idxc, idxp, ldvt2;
            int isigma;
            double orgnrm;
            int coltyp;

            // Parameter adjustments
            --d;
            u_dim1 = *ldu;
            u_offset = 1 + u_dim1;
            u -= u_offset;
            vt_dim1 = *ldvt;
            vt_offset = 1 + vt_dim1;
            vt -= vt_offset;
            --idxq;
            --iwork;
            --work;

            // Function Body
            *info = 0;

            if (*nl < 1)
            {
                *info = -1;
            }
            else if (*nr < 1)
            {
                *info = -2;
            }
            else if (*sqre < 0 || *sqre > 1)
            {
                *info = -3;
            }

            if (*info != 0)
            {
                i__1 = -(*info);
                xerbla("DLASD1", &i__1);
                return 0;
            }

            n = *nl + *nr + 1;
            m = n + *sqre;

            // The following values are for bookkeeping purposes only.  They are
            // int pointers which indicate the portion of the workspace
            // used by a particular array in DLASD2 and DLASD3.0

            ldu2 = n;
            ldvt2 = m;

            iz = 1;
            isigma = iz + m;
            iu2 = isigma + n;
            ivt2 = iu2 + ldu2 * n;
            iq = ivt2 + ldvt2 * m;

            idx = 1;
            idxc = idx + n;
            coltyp = idxc + n;
            idxp = coltyp + n;

            // Scale.

            // Computing MAX
            d__1 = Math.Abs(*alpha);
            d__2 = Math.Abs(*beta);
            orgnrm = Math.Max(d__1, d__2);

            d[*nl + 1] = 0.0;
            i__1 = n;
            for (i = 1; i <= i__1; ++i)
            {
                if (Math.Abs(d[i]) > orgnrm)
                {
                    orgnrm = Math.Abs(d[i]);
                }
            }

            dlascl("G", &c__0, &c__0, &orgnrm, &c_b7, &n, &c__1, &d[1], &n, info);
            *alpha /= orgnrm;
            *beta /= orgnrm;

            // Deflate singular values.

            dlasd2(nl, nr, sqre, &k, &d[1], &work[iz], alpha, beta, &u[u_offset],
                ldu, &vt[vt_offset], ldvt, &work[isigma], &work[iu2], &ldu2, &work[ivt2],
                &ldvt2, &iwork[idxp], &iwork[idx], &iwork[idxc], &idxq[1], &iwork[coltyp], info);

            // Solve Secular Equation and update singular vectors.

            ldq = k;
            dlasd3(nl, nr, sqre, &k, &d[1], &work[iq], &ldq, &work[isigma], &u[u_offset],
                ldu, &work[iu2], &ldu2, &vt[vt_offset], ldvt, &work[ivt2],
                &ldvt2, &iwork[idxc], &iwork[coltyp], &work[iz], info);

            if (*info != 0)
            {
                return 0;
            }

            // Unscale.

            dlascl("G", &c__0, &c__0, &c_b7, &orgnrm, &n, &c__1, &d[1], &n, info);

            // Prepare the IDXQ sorting permutation.

            n1 = k;
            n2 = n - k;
            dlamrg(&n1, &n2, &d[1], &c__1, &c_n1, &idxq[1]);

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int dlasd2(int* nl, int* nr, int* sqre, int* k, double* d, double* z,
            double* alpha, double* beta, double* u, int* ldu, double* vt, int* ldvt, double* dsigma,
            double* u2, int* ldu2, double* vt2, int* ldvt2, int* idxp, int* idx, int* idxc, int* idxq,
            int* coltyp, int* info)
        {
            //  -- LAPACK auxiliary routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     November 2006

            //  Purpose
            //  =======

            //  DLASD2 merges the two sets of singular values together into a single
            //  sorted set.  Then it tries to deflate the size of the problem.
            //  There are two ways in which deflation can occur:  when two or more
            //  singular values are close together or if there is a tiny entry in the
            //  Z vector.  For each such occurrence the order of the related secular
            //  equation problem is reduced by one.

            //  DLASD2 is called from DLASD1.0

            //  Arguments
            //  =========

            //  NL     (input) INTEGER
            //         The row dimension of the upper block.  NL >= 1.0

            //  NR     (input) INTEGER
            //         The row dimension of the lower block.  NR >= 1.0

            //  SQRE   (input) INTEGER
            //         = 0: the lower block is an NR-by-NR square matrix.
            //         = 1: the lower block is an NR-by-(NR+1) rectangular matrix.

            //         The bidiagonal matrix has N = NL + NR + 1 rows and
            //         M = N + SQRE >= N columns.

            //  K      (output) INTEGER
            //         Contains the dimension of the non-deflated matrix,
            //         This is the order of the related secular equation. 1 <= K <=N.

            //  D      (input/output) DOUBLE PRECISION array, dimension(N)
            //         On entry D contains the singular values of the two submatrices
            //         to be combined.  On exit D contains the trailing (N-K) updated
            //         singular values (those which were deflated) sorted into
            //         increasing order.

            //  Z      (output) DOUBLE PRECISION array, dimension(N)
            //         On exit Z contains the updating row vector in the secular
            //         equation.

            //  ALPHA  (input) DOUBLE PRECISION
            //         Contains the diagonal element associated with the added row.

            //  BETA   (input) DOUBLE PRECISION
            //         Contains the off-diagonal element associated with the added
            //         row.

            //  U      (input/output) DOUBLE PRECISION array, dimension(LDU,N)
            //         On entry U contains the left singular vectors of two
            //         submatrices in the two square blocks with corners at (1,1),
            //         (NL, NL), and (NL+2, NL+2), (N,N).
            //         On exit U contains the trailing (N-K) updated left singular
            //         vectors (those which were deflated) in its last N-K columns.

            //  LDU    (input) INTEGER
            //         The leading dimension of the array U.  LDU >= N.

            //  VT     (input/output) DOUBLE PRECISION array, dimension(LDVT,M)
            //         On entry VT' contains the right singular vectors of two
            //         submatrices in the two square blocks with corners at (1,1),
            //         (NL+1, NL+1), and (NL+2, NL+2), (M,M).
            //         On exit VT' contains the trailing (N-K) updated right singular
            //         vectors (those which were deflated) in its last N-K columns.
            //         In case SQRE =1, the last row of VT spans the right null
            //         space.

            //  LDVT   (input) INTEGER
            //         The leading dimension of the array VT.  LDVT >= M.

            //  DSIGMA (output) DOUBLE PRECISION array, dimension (N)
            //         Contains a copy of the diagonal elements (K-1 singular values
            //         and one zero) in the secular equation.

            //  U2     (output) DOUBLE PRECISION array, dimension(LDU2,N)
            //         Contains a copy of the first K-1 left singular vectors which
            //         will be used by DLASD3 in a matrix multiply (DGEMM) to solve
            //         for the new left singular vectors. U2 is arranged into four
            //         blocks. The first block contains a column with 1 at NL+1 and
            //         zero everywhere else; the second block contains non-zero
            //         entries only at and above NL; the third contains non-zero
            //         entries only below NL+1; and the fourth is dense.

            //  LDU2   (input) INTEGER
            //         The leading dimension of the array U2.0  LDU2 >= N.

            //  VT2    (output) DOUBLE PRECISION array, dimension(LDVT2,N)
            //         VT2' contains a copy of the first K right singular vectors
            //         which will be used by DLASD3 in a matrix multiply (DGEMM) to
            //         solve for the new right singular vectors. VT2 is arranged into
            //         three blocks. The first block contains a row that corresponds
            //         to the special 0 diagonal element in SIGMA; the second block
            //         contains non-zeros only at and before NL +1; the third block
            //         contains non-zeros only at and after  NL +2.0

            //  LDVT2  (input) INTEGER
            //         The leading dimension of the array VT2.0  LDVT2 >= M.

            //  IDXP   (workspace) INTEGER array dimension(N)
            //         This will contain the permutation used to place deflated
            //         values of D at the end of the array. On output IDXP(2:K)
            //         points to the nondeflated D-values and IDXP(K+1:N)
            //         points to the deflated singular values.

            //  IDX    (workspace) INTEGER array dimension(N)
            //         This will contain the permutation used to sort the contents of
            //         D into ascending order.

            //  IDXC   (output) INTEGER array dimension(N)
            //         This will contain the permutation used to arrange the columns
            //         of the deflated U matrix into three groups:  the first group
            //         contains non-zero entries only at and above NL, the second
            //         contains non-zero entries only below NL+2, and the third is
            //         dense.

            //  IDXQ   (input/output) INTEGER array dimension(N)
            //         This contains the permutation which separately sorts the two
            //         sub-problems in D into ascending order.  Note that entries in
            //         the first hlaf of this permutation must first be moved one
            //         position backward; and entries in the second half
            //         must first have NL+1 added to their values.

            //  COLTYP (workspace/output) INTEGER array dimension(N)
            //         As workspace, this will contain a label which will indicate
            //         which of the following types a column in the U2 matrix or a
            //         row in the VT2 matrix is:
            //         1 : non-zero in the upper half only
            //         2 : non-zero in the lower half only
            //         3 : dense
            //         4 : deflated

            //         On exit, it is an array of dimension 4, with COLTYP(I) being
            //         the dimension of the I-th type columns.

            //  INFO   (output) INTEGER
            //          = 0:  successful exit.
            //          < 0:  if INFO = -i, the i-th argument had an illegal value.

            //  Further Details
            //  ===============

            //  Based on contributions by
            //     Ming Gu and Huan Ren, Computer Science Division, University of
            //     California at Berkeley, USA

            //  =====================================================================

            // System generated locals
            int u_dim1, u_offset, u2_dim1, u2_offset, vt_dim1, vt_offset,
                vt2_dim1, vt2_offset, i__1;
            double d__1, d__2;

            // Table of constant values
            int c__1 = 1;
            double c_b30 = 0.0;

            // Local variables
            double c = 0.0;
            int i, j, m, n;
            double s = 0.0;
            int k2;
            double z1;
            int ct, jp;
            double eps, tau, tol;
            int nlp1, nlp2, idxi, idxj;
            int[] psm = new int[4];
            int idxjp;
            int[] ctot = new int[4];
            int jprev = 0;
            double hlftol;

            // Parameter adjustments
            --d;
            --z;
            u_dim1 = *ldu;
            u_offset = 1 + u_dim1;
            u -= u_offset;
            vt_dim1 = *ldvt;
            vt_offset = 1 + vt_dim1;
            vt -= vt_offset;
            --dsigma;
            u2_dim1 = *ldu2;
            u2_offset = 1 + u2_dim1;
            u2 -= u2_offset;
            vt2_dim1 = *ldvt2;
            vt2_offset = 1 + vt2_dim1;
            vt2 -= vt2_offset;
            --idxp;
            --idx;
            --idxc;
            --idxq;
            --coltyp;

            // Function Body
            *info = 0;

            if (*nl < 1)
            {
                *info = -1;
            }
            else if (*nr < 1)
            {
                *info = -2;
            }
            else if (*sqre != 1 && *sqre != 0)
            {
                *info = -3;
            }

            n = *nl + *nr + 1;
            m = n + *sqre;

            if (*ldu < n)
            {
                *info = -10;
            }
            else if (*ldvt < m)
            {
                *info = -12;
            }
            else if (*ldu2 < n)
            {
                *info = -15;
            }
            else if (*ldvt2 < m)
            {
                *info = -17;
            }

            if (*info != 0)
            {
                i__1 = -(*info);
                xerbla("DLASD2", &i__1);
                return 0;
            }

            nlp1 = *nl + 1;
            nlp2 = *nl + 2;

            // Generate the first part of the vector Z; and move the singular
            // values in the first part of D one position backward.

            z1 = *alpha * vt[nlp1 + nlp1 * vt_dim1];
            z[1] = z1;
            for (i = *nl; i >= 1; --i)
            {
                z[i + 1] = *alpha * vt[i + nlp1 * vt_dim1];
                d[i + 1] = d[i];
                idxq[i + 1] = idxq[i] + 1;
            }

            // Generate the second part of the vector Z.

            i__1 = m;
            for (i = nlp2; i <= i__1; ++i)
            {
                z[i] = *beta * vt[i + nlp2 * vt_dim1];
            }

            // Initialize some reference arrays.

            i__1 = nlp1;
            for (i = 2; i <= i__1; ++i)
            {
                coltyp[i] = 1;
            }
            i__1 = n;
            for (i = nlp2; i <= i__1; ++i)
            {
                coltyp[i] = 2;
            }

            // Sort the singular values into increasing order

            i__1 = n;
            for (i = nlp2; i <= i__1; ++i)
            {
                idxq[i] += nlp1;
            }

            // DSIGMA, IDXC, IDXC, and the first column of U2
            // are used as storage space.

            i__1 = n;
            for (i = 2; i <= i__1; ++i)
            {
                dsigma[i] = d[idxq[i]];
                u2[i + u2_dim1] = z[idxq[i]];
                idxc[i] = coltyp[idxq[i]];
            }

            dlamrg(nl, nr, &dsigma[2], &c__1, &c__1, &idx[2]);

            i__1 = n;
            for (i = 2; i <= i__1; ++i)
            {
                idxi = idx[i] + 1;
                d[i] = dsigma[idxi];
                z[i] = u2[idxi + u2_dim1];
                coltyp[i] = idxc[idxi];
            }

            // Calculate the allowable deflation tolerance

            eps = dlamch("Epsilon");
            // Computing MAX
            d__1 = Math.Abs(*alpha);
            d__2 = Math.Abs(*beta);
            tol = Math.Max(d__1, d__2);
            // Computing MAX
            d__2 = Math.Abs(d[n]);
            tol = eps * 8.0 * Math.Max(d__2, tol);

            // There are 2 kinds of deflation -- first a value in the z-vector
            // is small, second two (or more) singular values are very close
            // together (their difference is small).

            // If the value in the z-vector is small, we simply permute the
            // array so that the corresponding singular value is moved to the
            // end.

            // If two values in the D-vector are close, we perform a two-sided
            // rotation designed to make one of the corresponding z-vector
            // entries zero, and then permute the array so that the deflated
            // singular value is moved to the end.

            // If there are multiple singular values then the problem deflates.
            // Here the number of equal singular values are found.  As each equal
            // singular value is found, an elementary reflector is computed to
            // rotate the corresponding singular subspace so that the
            // corresponding components of Z are zero in this new basis.

            *k = 1;
            k2 = n + 1;
            i__1 = n;
            for (j = 2; j <= i__1; ++j)
            {
                if (Math.Abs(z[j]) <= tol)
                {
                    // Deflate due to small z component.

                    --k2;
                    idxp[k2] = j;
                    coltyp[j] = 4;
                    if (j == n)
                    {
                        goto L120;
                    }
                }
                else
                {
                    jprev = j;
                    goto L90;
                }
            }

        L90:
            j = jprev;

        L100:
            ++j;
            if (j > n)
            {
                goto L110;
            }
            if (Math.Abs(z[j]) <= tol)
            {
                // Deflate due to small z component.

                --k2;
                idxp[k2] = j;
                coltyp[j] = 4;
            }
            else
            {
                // Check if singular values are close enough to allow deflation.

                if (Math.Abs(d[j] - d[jprev]) <= tol)
                {
                    // Deflation is possible.

                    s = z[jprev];
                    c = z[j];

                    // Find sqrt(a**2+b**2) without overflow or
                    // destructive underflow.

                    tau = dlapy2(&c, &s);
                    c /= tau;
                    s = -s / tau;
                    z[j] = tau;
                    z[jprev] = 0.0;

                    // Apply back the Givens rotation to the left and right
                    // singular vector matrices.

                    idxjp = idxq[idx[jprev] + 1];
                    idxj = idxq[idx[j] + 1];
                    if (idxjp <= nlp1)
                    {
                        --idxjp;
                    }
                    if (idxj <= nlp1)
                    {
                        --idxj;
                    }
                    drot(&n, &u[idxjp * u_dim1 + 1], &c__1, &u[idxj * u_dim1 + 1], &c__1, &c, &s);
                    drot(&m, &vt[idxjp + vt_dim1], ldvt, &vt[idxj + vt_dim1], ldvt, &c, &s);

                    if (coltyp[j] != coltyp[jprev])
                    {
                        coltyp[j] = 3;
                    }

                    coltyp[jprev] = 4;
                    --k2;
                    idxp[k2] = jprev;
                    jprev = j;
                }
                else
                {
                    ++(*k);
                    u2[*k + u2_dim1] = z[jprev];
                    dsigma[*k] = d[jprev];
                    idxp[*k] = jprev;
                    jprev = j;
                }
            }

            goto L100;
        L110:

            // Record the last singular value.

            ++(*k);
            u2[*k + u2_dim1] = z[jprev];
            dsigma[*k] = d[jprev];
            idxp[*k] = jprev;

        L120:

            // Count up the total number of the various types of columns, then
            // form a permutation which positions the four column types into
            // four groups of uniform structure (although one or more of these
            // groups may be empty).

            for (j = 1; j <= 4; ++j)
            {
                ctot[j - 1] = 0;
            }
            i__1 = n;
            for (j = 2; j <= i__1; ++j)
            {
                ct = coltyp[j];
                ++ctot[ct - 1];
            }

            // PSM(*) = Position in SubMatrix (of types 1 through 4)

            psm[0] = 2;
            psm[1] = ctot[0] + 2;
            psm[2] = psm[1] + ctot[1];
            psm[3] = psm[2] + ctot[2];

            // Fill out the IDXC array so that the permutation which it induces
            // will place all type-1 columns first, all type-2 columns next,
            // then all type-3's, and finally all type-4's, starting from the
            // second column. This applies similarly to the rows of VT.

            i__1 = n;
            for (j = 2; j <= i__1; ++j)
            {
                jp = idxp[j];
                ct = coltyp[jp];
                idxc[psm[ct - 1]] = j;
                ++psm[ct - 1];
            }

            // Sort the singular values and corresponding singular vectors into
            // DSIGMA, U2, and VT2 respectively.  The singular values/vectors
            // which were not deflated go into the first K slots of DSIGMA, U2,
            // and VT2 respectively, while those which were deflated go into the
            // last N - K slots, except that the first column/row will be treated
            // separately.

            i__1 = n;
            for (j = 2; j <= i__1; ++j)
            {
                jp = idxp[j];
                dsigma[j] = d[jp];
                idxj = idxq[idx[idxp[idxc[j]]] + 1];
                if (idxj <= nlp1)
                {
                    --idxj;
                }
                dcopy(&n, &u[idxj * u_dim1 + 1], &c__1, &u2[j * u2_dim1 + 1], &c__1);
                dcopy(&m, &vt[idxj + vt_dim1], ldvt, &vt2[j + vt2_dim1], ldvt2);
            }

            // Determine DSIGMA(1), DSIGMA(2) and Z(1)

            dsigma[1] = 0.0;
            hlftol = tol / 2.0;
            if (Math.Abs(dsigma[2]) <= hlftol)
            {
                dsigma[2] = hlftol;
            }
            if (m > n)
            {
                z[1] = dlapy2(&z1, &z[m]);
                if (z[1] <= tol)
                {
                    c = 1.0;
                    s = 0.0;
                    z[1] = tol;
                }
                else
                {
                    c = z1 / z[1];
                    s = z[m] / z[1];
                }
            }
            else
            {
                if (Math.Abs(z1) <= tol)
                {
                    z[1] = tol;
                }
                else
                {
                    z[1] = z1;
                }
            }

            // Move the rest of the updating row to Z.

            i__1 = *k - 1;
            dcopy(&i__1, &u2[u2_dim1 + 2], &c__1, &z[2], &c__1);

            // Determine the first column of U2, the first row of VT2 and the
            // last row of VT.

            dlaset("A", &n, &c__1, &c_b30, &c_b30, &u2[u2_offset], ldu2);
            u2[nlp1 + u2_dim1] = 1.0;
            if (m > n)
            {
                i__1 = nlp1;
                for (i = 1; i <= i__1; ++i)
                {
                    vt[m + i * vt_dim1] = -s * vt[nlp1 + i * vt_dim1];
                    vt2[i * vt2_dim1 + 1] = c * vt[nlp1 + i * vt_dim1];
                }
                i__1 = m;
                for (i = nlp2; i <= i__1; ++i)
                {
                    vt2[i * vt2_dim1 + 1] = s * vt[m + i * vt_dim1];
                    vt[m + i * vt_dim1] = c * vt[m + i * vt_dim1];
                }
            }
            else
            {
                dcopy(&m, &vt[nlp1 + vt_dim1], ldvt, &vt2[vt2_dim1 + 1], ldvt2);
            }
            if (m > n)
            {
                dcopy(&m, &vt[m + vt_dim1], ldvt, &vt2[m + vt2_dim1], ldvt2);
            }

            // The deflated singular values and their corresponding vectors go
            // into the back of D, U, and V respectively.

            if (n > *k)
            {
                i__1 = n - *k;
                dcopy(&i__1, &dsigma[*k + 1], &c__1, &d[*k + 1], &c__1);
                i__1 = n - *k;
                dlacpy("A", &n, &i__1, &u2[(*k + 1) * u2_dim1 + 1], ldu2, &u[(*k + 1) * u_dim1 + 1], ldu);
                i__1 = n - *k;
                dlacpy("A", &i__1, &m, &vt2[*k + 1 + vt2_dim1], ldvt2, &vt[*k + 1 + vt_dim1], ldvt);
            }

            // Copy CTOT into COLTYP for referencing in DLASD3.0

            for (j = 1; j <= 4; ++j)
            {
                coltyp[j] = ctot[j - 1];
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int dlasd3(int* nl, int* nr, int* sqre, int* k, double* d, double* q,
            int* ldq, double* dsigma, double* u, int* ldu, double* u2, int* ldu2, double* vt,
            int* ldvt, double* vt2, int* ldvt2, int* idxc, int* ctot, double* z, int* info)
        {
            //  -- LAPACK auxiliary routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     November 2006

            //  Purpose
            //  =======

            //  DLASD3 finds all the square roots of the roots of the secular
            //  equation, as defined by the values in D and Z.  It makes the
            //  appropriate calls to DLASD4 and then updates the singular
            //  vectors by matrix multiplication.

            //  This code makes very mild assumptions about floating point
            //  arithmetic. It will work on machines with a guard digit in
            //  add/subtract, or on those binary machines without guard digits
            //  which subtract like the Cray XMP, Cray YMP, Cray C 90, or Cray 2.0
            //  It could conceivably fail on hexadecimal or decimal machines
            //  without guard digits, but we know of none.

            //  DLASD3 is called from DLASD1.0

            //  Arguments
            //  =========

            //  NL     (input) INTEGER
            //         The row dimension of the upper block.  NL >= 1.0

            //  NR     (input) INTEGER
            //         The row dimension of the lower block.  NR >= 1.0

            //  SQRE   (input) INTEGER
            //         = 0: the lower block is an NR-by-NR square matrix.
            //         = 1: the lower block is an NR-by-(NR+1) rectangular matrix.

            //         The bidiagonal matrix has N = NL + NR + 1 rows and
            //         M = N + SQRE >= N columns.

            //  K      (input) INTEGER
            //         The size of the secular equation, 1 =< K = < N.

            //  D      (output) DOUBLE PRECISION array, dimension(K)
            //         On exit the square roots of the roots of the secular equation,
            //         in ascending order.

            //  Q      (workspace) DOUBLE PRECISION array,
            //                     dimension at least (LDQ,K).

            //  LDQ    (input) INTEGER
            //         The leading dimension of the array Q.  LDQ >= K.

            //  DSIGMA (input) DOUBLE PRECISION array, dimension(K)
            //         The first K elements of this array contain the old roots
            //         of the deflated updating problem.  These are the poles
            //         of the secular equation.

            //  U      (output) DOUBLE PRECISION array, dimension (LDU, N)
            //         The last N - K columns of this matrix contain the deflated
            //         left singular vectors.

            //  LDU    (input) INTEGER
            //         The leading dimension of the array U.  LDU >= N.

            //  U2     (input/output) DOUBLE PRECISION array, dimension (LDU2, N)
            //         The first K columns of this matrix contain the non-deflated
            //         left singular vectors for the split problem.

            //  LDU2   (input) INTEGER
            //         The leading dimension of the array U2.0  LDU2 >= N.

            //  VT     (output) DOUBLE PRECISION array, dimension (LDVT, M)
            //         The last M - K columns of VT' contain the deflated
            //         right singular vectors.

            //  LDVT   (input) INTEGER
            //         The leading dimension of the array VT.  LDVT >= N.

            //  VT2    (input/output) DOUBLE PRECISION array, dimension (LDVT2, N)
            //         The first K columns of VT2' contain the non-deflated
            //         right singular vectors for the split problem.

            //  LDVT2  (input) INTEGER
            //         The leading dimension of the array VT2.0  LDVT2 >= N.

            //  IDXC   (input) INTEGER array, dimension ( N )
            //         The permutation used to arrange the columns of U (and rows of
            //         VT) into three groups:  the first group contains non-zero
            //         entries only at and above (or before) NL +1; the second
            //         contains non-zero entries only at and below (or after) NL+2;
            //         and the third is dense. The first column of U and the row of
            //         VT are treated separately, however.

            //         The rows of the singular vectors found by DLASD4
            //         must be likewise permuted before the matrix multiplies can
            //         take place.

            //  CTOT   (input) INTEGER array, dimension ( 4 )
            //         A count of the total number of the various types of columns
            //         in U (or rows in VT), as described in IDXC. The fourth column
            //         type is any column which has been deflated.

            //  Z      (input) DOUBLE PRECISION array, dimension (K)
            //         The first K elements of this array contain the components
            //         of the deflation-adjusted updating row vector.

            //  INFO   (output) INTEGER
            //         = 0:  successful exit.
            //         < 0:  if INFO = -i, the i-th argument had an illegal value.
            //         > 0:  if INFO = 1, an singular value did not converge

            //  Further Details
            //  ===============

            //  Based on contributions by
            //     Ming Gu and Huan Ren, Computer Science Division, University of
            //     California at Berkeley, USA

            //  =====================================================================

            // System generated locals
            int q_dim1, q_offset, u_dim1, u_offset, u2_dim1, u2_offset, vt_dim1,
                vt_offset, vt2_dim1, vt2_offset, i__1, i__2;
            double d__2;

            // Table of constant values
            int c__1 = 1;
            int c__0 = 0;
            double c_b13 = 1.0;
            double c_b26 = 0.0;

            // Local variables
            int i, j, m, n, jc;
            double rho;
            int nlp1, nlp2, nrp1;
            double temp;
            int ctemp;
            int ktemp;

            // Parameter adjustments
            --d;
            q_dim1 = *ldq;
            q_offset = 1 + q_dim1;
            q -= q_offset;
            --dsigma;
            u_dim1 = *ldu;
            u_offset = 1 + u_dim1;
            u -= u_offset;
            u2_dim1 = *ldu2;
            u2_offset = 1 + u2_dim1;
            u2 -= u2_offset;
            vt_dim1 = *ldvt;
            vt_offset = 1 + vt_dim1;
            vt -= vt_offset;
            vt2_dim1 = *ldvt2;
            vt2_offset = 1 + vt2_dim1;
            vt2 -= vt2_offset;
            --idxc;
            --ctot;
            --z;

            // Function Body
            *info = 0;

            if (*nl < 1)
            {
                *info = -1;
            }
            else if (*nr < 1)
            {
                *info = -2;
            }
            else if (*sqre != 1 && *sqre != 0)
            {
                *info = -3;
            }

            n = *nl + *nr + 1;
            m = n + *sqre;
            nlp1 = *nl + 1;
            nlp2 = *nl + 2;

            if (*k < 1 || *k > n)
            {
                *info = -4;
            }
            else if (*ldq < *k)
            {
                *info = -7;
            }
            else if (*ldu < n)
            {
                *info = -10;
            }
            else if (*ldu2 < n)
            {
                *info = -12;
            }
            else if (*ldvt < m)
            {
                *info = -14;
            }
            else if (*ldvt2 < m)
            {
                *info = -16;
            }

            if (*info != 0)
            {
                i__1 = -(*info);
                xerbla("DLASD3", &i__1);
                return 0;
            }

            // Quick return if possible

            if (*k == 1)
            {
                d[1] = Math.Abs(z[1]);
                dcopy(&m, &vt2[vt2_dim1 + 1], ldvt2, &vt[vt_dim1 + 1], ldvt);
                if (z[1] > 0.0)
                {
                    dcopy(&n, &u2[u2_dim1 + 1], &c__1, &u[u_dim1 + 1], &c__1);
                }
                else
                {
                    i__1 = n;
                    for (i = 1; i <= i__1; ++i)
                    {
                        u[i + u_dim1] = -u2[i + u2_dim1];
                    }
                }
                return 0;
            }

            // Modify values DSIGMA(i) to make sure all DSIGMA(i)-DSIGMA(j) can
            // be computed with high relative accuracy (barring over/underflow).
            // This is a problem on machines without a guard digit in
            // add/subtract (Cray XMP, Cray YMP, Cray C 90 and Cray 2).
            // The following code replaces DSIGMA(I) by 2*DSIGMA(I)-DSIGMA(I),
            // which on any of these machines zeros out the bottommost
            // bit of DSIGMA(I) if it is 1; this makes the subsequent
            // subtractions DSIGMA(I)-DSIGMA(J) unproblematic when cancellation
            // occurs. On binary machines with a guard digit (almost all
            // machines) it does not change DSIGMA(I) at all. On hexadecimal
            // and decimal machines with a guard digit, it slightly
            // changes the bottommost bits of DSIGMA(I). It does not account
            // for hexadecimal or decimal machines without guard digits
            // (we know of none). We use a subroutine call to compute
            // 2*DSIGMA(I) to prevent optimizing compilers from eliminating
            // this code.

            i__1 = *k;
            for (i = 1; i <= i__1; ++i)
            {
                dsigma[i] = dlamc3(&dsigma[i], &dsigma[i]) - dsigma[i];
            }

            // Keep a copy of Z.

            dcopy(k, &z[1], &c__1, &q[q_offset], &c__1);

            // Normalize Z.

            rho = dnrm2(k, &z[1], &c__1);
            dlascl("G", &c__0, &c__0, &rho, &c_b13, k, &c__1, &z[1], k, info);
            rho *= rho;

            // Find the new singular values.

            i__1 = *k;
            for (j = 1; j <= i__1; ++j)
            {
                dlasd4(k, &j, &dsigma[1], &z[1], &u[j * u_dim1 + 1], &rho, &d[j],
                     &vt[j * vt_dim1 + 1], info);

                // If the zero finder fails, the computation is terminated.

                if (*info != 0)
                {
                    return 0;
                }
            }

            // Compute updated Z.

            i__1 = *k;
            for (i = 1; i <= i__1; ++i)
            {
                z[i] = u[i + *k * u_dim1] * vt[i + *k * vt_dim1];
                i__2 = i - 1;
                for (j = 1; j <= i__2; ++j)
                {
                    z[i] *= u[i + j * u_dim1] * vt[i + j * vt_dim1] / (dsigma[
                        i] - dsigma[j]) / (dsigma[i] + dsigma[j]);
                }
                i__2 = *k - 1;
                for (j = i; j <= i__2; ++j)
                {
                    z[i] *= u[i + j * u_dim1] * vt[i + j * vt_dim1] / (dsigma[
                        i] - dsigma[j + 1]) / (dsigma[i] + dsigma[j + 1]);
                }
                d__2 = Math.Sqrt(Math.Abs(z[i]));
                z[i] = d_sign(&d__2, &q[i + q_dim1]);
            }

            // Compute left singular vectors of the modified diagonal matrix,
            // and store related information for the right singular vectors.

            i__1 = *k;
            for (i = 1; i <= i__1; ++i)
            {
                vt[i * vt_dim1 + 1] = z[1] / u[i * u_dim1 + 1] / vt[i * vt_dim1 + 1];
                u[i * u_dim1 + 1] = -1.0;
                i__2 = *k;
                for (j = 2; j <= i__2; ++j)
                {
                    vt[j + i * vt_dim1] = z[j] / u[j + i * u_dim1] / vt[j + i * vt_dim1];
                    u[j + i * u_dim1] = dsigma[j] * vt[j + i * vt_dim1];
                }
                temp = dnrm2(k, &u[i * u_dim1 + 1], &c__1);
                q[i * q_dim1 + 1] = u[i * u_dim1 + 1] / temp;
                i__2 = *k;
                for (j = 2; j <= i__2; ++j)
                {
                    jc = idxc[j];
                    q[j + i * q_dim1] = u[jc + i * u_dim1] / temp;
                }
            }

            // Update the left singular vector matrix.

            if (*k == 2)
            {
                dgemm("N", "N", &n, k, k, &c_b13, &u2[u2_offset], ldu2, &q[q_offset],
                     ldq, &c_b26, &u[u_offset], ldu);
                goto L100;
            }
            if (ctot[1] > 0)
            {
                dgemm("N", "N", nl, k, &ctot[1], &c_b13, &u2[(u2_dim1 << 1) + 1],
                    ldu2, &q[q_dim1 + 2], ldq, &c_b26, &u[u_dim1 + 1], ldu);
                if (ctot[3] > 0)
                {
                    ktemp = ctot[1] + 2 + ctot[2];
                    dgemm("N", "N", nl, k, &ctot[3], &c_b13, &u2[ktemp * u2_dim1 + 1],
                        ldu2, &q[ktemp + q_dim1], ldq, &c_b13, &u[u_dim1 + 1], ldu);
                }
            }
            else if (ctot[3] > 0)
            {
                ktemp = ctot[1] + 2 + ctot[2];
                dgemm("N", "N", nl, k, &ctot[3], &c_b13, &u2[ktemp * u2_dim1 + 1],
                    ldu2, &q[ktemp + q_dim1], ldq, &c_b26, &u[u_dim1 + 1], ldu);
            }
            else
            {
                dlacpy("F", nl, k, &u2[u2_offset], ldu2, &u[u_offset], ldu);
            }
            dcopy(k, &q[q_dim1 + 1], ldq, &u[nlp1 + u_dim1], ldu);
            ktemp = ctot[1] + 2;
            ctemp = ctot[2] + ctot[3];
            dgemm("N", "N", nr, k, &ctemp, &c_b13, &u2[nlp2 + ktemp * u2_dim1], ldu2,
                 &q[ktemp + q_dim1], ldq, &c_b26, &u[nlp2 + u_dim1], ldu);

            // Generate the right singular vectors.

        L100:
            i__1 = *k;
            for (i = 1; i <= i__1; ++i)
            {
                temp = dnrm2(k, &vt[i * vt_dim1 + 1], &c__1);
                q[i + q_dim1] = vt[i * vt_dim1 + 1] / temp;
                i__2 = *k;
                for (j = 2; j <= i__2; ++j)
                {
                    jc = idxc[j];
                    q[i + j * q_dim1] = vt[jc + i * vt_dim1] / temp;
                }
            }

            // Update the right singular vector matrix.

            if (*k == 2)
            {
                dgemm("N", "N", k, &m, k, &c_b13, &q[q_offset], ldq,
                    &vt2[vt2_offset], ldvt2, &c_b26, &vt[vt_offset], ldvt);
                return 0;
            }
            ktemp = ctot[1] + 1;
            dgemm("N", "N", k, &nlp1, &ktemp, &c_b13, &q[q_dim1 + 1], ldq,
                &vt2[vt2_dim1 + 1], ldvt2, &c_b26, &vt[vt_dim1 + 1], ldvt);
            ktemp = ctot[1] + 2 + ctot[2];
            if (ktemp <= *ldvt2)
            {
                dgemm("N", "N", k, &nlp1, &ctot[3], &c_b13, &q[ktemp * q_dim1 + 1],
                    ldq, &vt2[ktemp + vt2_dim1], ldvt2, &c_b13, &vt[vt_dim1 + 1], ldvt);
            }

            ktemp = ctot[1] + 1;
            nrp1 = *nr + *sqre;
            if (ktemp > 1)
            {
                i__1 = *k;
                for (i = 1; i <= i__1; ++i)
                {
                    q[i + ktemp * q_dim1] = q[i + q_dim1];
                }
                i__1 = m;
                for (i = nlp2; i <= i__1; ++i)
                {
                    vt2[ktemp + i * vt2_dim1] = vt2[i * vt2_dim1 + 1];
                }
            }

            ctemp = ctot[2] + 1 + ctot[3];
            dgemm("N", "N", k, &nrp1, &ctemp, &c_b13, &q[ktemp * q_dim1 + 1], ldq,
                &vt2[ktemp + nlp2 * vt2_dim1], ldvt2, &c_b26, &vt[nlp2 * vt_dim1 + 1], ldvt);

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int dlasd4(int* n, int* i, double* d, double* z,
            double* delta, double* rho, double* sigma, double* work, int* info)
        {
            //  -- LAPACK auxiliary routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     November 2006

            //  Purpose
            //  =======

            //  This subroutine computes the square root of the I-th updated
            //  eigenvalue of a positive symmetric rank-one modification to
            //  a positive diagonal matrix whose entries are given as the squares
            //  of the corresponding entries in the array d, and that

            //         0 <= D(i) < D(j)  for  i < j

            //  and that RHO > 0.0 This is arranged by the calling routine, and is
            //  no loss in generality.  The rank-one modified system is thus

            //         diag( D ) * diag( D ) +  RHO *  Z * Z_transpose.

            //  where we assume the Euclidean norm of Z is 1.0

            //  The method consists of approximating the rational functions in the
            //  secular equation by simpler interpolating rational functions.

            //  Arguments
            //  =========

            //  N      (input) INTEGER
            //         The length of all arrays.

            //  I      (input) INTEGER
            //         The index of the eigenvalue to be computed.  1 <= I <= N.

            //  D      (input) DOUBLE PRECISION array, dimension ( N )
            //         The original eigenvalues.  It is assumed that they are in
            //         order, 0 <= D(I) < D(J)  for I < J.

            //  Z      (input) DOUBLE PRECISION array, dimension ( N )
            //         The components of the updating vector.

            //  DELTA  (output) DOUBLE PRECISION array, dimension ( N )
            //         If N .ne. 1, DELTA contains (D(j) - sigma_I) in its  j-th
            //         component.  If N = 1, then DELTA(1) = 1.0  The vector DELTA
            //         contains the information necessary to construct the
            //         (singular) eigenvectors.

            //  RHO    (input) DOUBLE PRECISION
            //         The scalar in the symmetric updating formula.

            //  SIGMA  (output) DOUBLE PRECISION
            //         The computed sigma_I, the I-th updated eigenvalue.

            //  WORK   (workspace) DOUBLE PRECISION array, dimension ( N )
            //         If N .ne. 1, WORK contains (D(j) + sigma_I) in its  j-th
            //         component.  If N = 1, then WORK( 1 ) = 1.0

            //  INFO   (output) INTEGER
            //         = 0:  successful exit
            //         > 0:  if INFO = 1, the updating process failed.

            //  Internal Parameters
            //  ===================

            //  Logical variable ORGATI (origin-at-i?) is used for distinguishing
            //  whether D(i) or D(i+1) is treated as the origin.

            //            ORGATI = .true.    origin at i
            //            ORGATI = .false.   origin at i+1

            //  Logical variable SWTCH3 (switch-for-3-poles?) is for noting
            //  if we are working with THREE poles!

            //  MAXIT is the maximum number of iterations allowed for each
            //  eigenvalue.

            //  Further Details
            //  ===============

            //  Based on contributions by
            //     Ren-Cang Li, Computer Science Division, University of California
            //     at Berkeley, USA

            //  =====================================================================

            //     Since this routine is called in an inner loop, we do no argument
            //     checking.

            //     Quick return for N=1 and 2.0

            // System generated locals
            int i__1;
            double d__1;

            // Local variables
            double a, b, c;
            int j;
            double w;
            double[] dd = new double[3];
            int ii;
            double dw;
            double[] zz = new double[3];
            int ip1;
            double eta, phi, eps, tau, psi;
            int iim1, iip1;
            double dphi, dpsi;
            int iter;
            double temp, prew, sg2lb, sg2ub, temp1, temp2, dtiim, delsq, dtiip;
            int niter;
            double dtisq;
            bool swtch;
            double dtnsq;
            double delsq2, dtnsq1;
            bool swtch3;
            bool orgati;
            double erretm, dtipsq, rhoinv;

            // Parameter adjustments
            --work;
            --delta;
            --z;
            --d;

            // Function Body
            *info = 0;
            if (*n == 1)
            {
                // Presumably, I=1 upon entry

                *sigma = Math.Sqrt(d[1] * d[1] + *rho * z[1] * z[1]);
                delta[1] = 1.0;
                work[1] = 1.0;
                return 0;
            }
            if (*n == 2)
            {
                dlasd5(i, &d[1], &z[1], &delta[1], rho, sigma, &work[1]);
                return 0;
            }

            // Compute machine epsilon

            eps = dlamch("Epsilon");
            rhoinv = 1.0 / *rho;

            // The case I = N

            if (*i == *n)
            {
                // Initialize some basic variables

                ii = *n - 1;
                niter = 1;

                // Calculate initial guess

                temp = *rho / 2.0;

                // If ||Z||_2 is not one, then TEMP should be set to
                // RHO * ||Z||_2^2 / TWO

                temp1 = temp / (d[*n] + Math.Sqrt(d[*n] * d[*n] + temp));
                i__1 = *n;
                for (j = 1; j <= i__1; ++j)
                {
                    work[j] = d[j] + d[*n] + temp1;
                    delta[j] = d[j] - d[*n] - temp1;
                }

                psi = 0.0;
                i__1 = *n - 2;
                for (j = 1; j <= i__1; ++j)
                {
                    psi += z[j] * z[j] / (delta[j] * work[j]);
                }

                c = rhoinv + psi;
                w = c + z[ii] * z[ii] / (delta[ii] * work[ii]) + z[*n] * z[*
                    n] / (delta[*n] * work[*n]);

                if (w <= 0.0)
                {
                    temp1 = Math.Sqrt(d[*n] * d[*n] + *rho);
                    temp = z[*n - 1] * z[*n - 1] / ((d[*n - 1] + temp1) * (d[*
                        n] - d[*n - 1] + *rho / (d[*n] + temp1))) + z[*n] *
                        z[*n] / *rho;

                    // The following TAU is to approximate
                    // SIGMA_n^2 - D( N )*D( N )

                    if (c <= temp)
                    {
                        tau = *rho;
                    }
                    else
                    {
                        delsq = (d[*n] - d[*n - 1]) * (d[*n] + d[*n - 1]);
                        a = -c * delsq + z[*n - 1] * z[*n - 1] + z[*n] * z[*
                            n];
                        b = z[*n] * z[*n] * delsq;
                        if (a < 0.0)
                        {
                            tau = b * 2.0 / (Math.Sqrt(a * a + b * 4.0 * c) - a);
                        }
                        else
                        {
                            tau = (a + Math.Sqrt(a * a + b * 4.0 * c)) / (c * 2.0);
                        }
                    }

                    // It can be proved that
                    // D(N)^2+RHO/2 <= SIGMA_n^2 < D(N)^2+TAU <= D(N)^2+RHO

                }
                else
                {
                    delsq = (d[*n] - d[*n - 1]) * (d[*n] + d[*n - 1]);
                    a = -c * delsq + z[*n - 1] * z[*n - 1] + z[*n] * z[*n];
                    b = z[*n] * z[*n] * delsq;

                    // The following TAU is to approximate
                    // SIGMA_n^2 - D( N )*D( N )

                    if (a < 0.0)
                    {
                        tau = b * 2.0 / (Math.Sqrt(a * a + b * 4.0 * c) - a);
                    }
                    else
                    {
                        tau = (a + Math.Sqrt(a * a + b * 4.0 * c)) / (c * 2.0);
                    }

                    // It can be proved that
                    // D(N)^2 < D(N)^2+TAU < SIGMA(N)^2 < D(N)^2+RHO/2

                }

                // The following ETA is to approximate SIGMA_n - D( N )

                eta = tau / (d[*n] + Math.Sqrt(d[*n] * d[*n] + tau));

                *sigma = d[*n] + eta;
                i__1 = *n;
                for (j = 1; j <= i__1; ++j)
                {
                    delta[j] = d[j] - d[*i] - eta;
                    work[j] = d[j] + d[*i] + eta;
                }

                // Evaluate PSI and the derivative DPSI

                dpsi = 0.0;
                psi = 0.0;
                erretm = 0.0;
                i__1 = ii;
                for (j = 1; j <= i__1; ++j)
                {
                    temp = z[j] / (delta[j] * work[j]);
                    psi += z[j] * temp;
                    dpsi += temp * temp;
                    erretm += psi;
                }
                erretm = Math.Abs(erretm);

                // Evaluate PHI and the derivative DPHI

                temp = z[*n] / (delta[*n] * work[*n]);
                phi = z[*n] * temp;
                dphi = temp * temp;
                erretm = (-phi - psi) * 8.0 + erretm - phi + rhoinv + Math.Abs(tau) * (dpsi + dphi);

                w = rhoinv + phi + psi;

                // Test for convergence

                if (Math.Abs(w) <= eps * erretm)
                {
                    goto L240;
                }

                // Calculate the new step

                ++niter;
                dtnsq1 = work[*n - 1] * delta[*n - 1];
                dtnsq = work[*n] * delta[*n];
                c = w - dtnsq1 * dpsi - dtnsq * dphi;
                a = (dtnsq + dtnsq1) * w - dtnsq * dtnsq1 * (dpsi + dphi);
                b = dtnsq * dtnsq1 * w;
                if (c < 0.0)
                {
                    c = Math.Abs(c);
                }
                if (c == 0.0)
                {
                    eta = *rho - *sigma * *sigma;
                }
                else if (a >= 0.0)
                {
                    eta = (a + Math.Sqrt(Math.Abs(a * a - b * 4.0 * c))) / (c * 2.0);
                }
                else
                {
                    eta = b * 2.0 / (a - Math.Sqrt(Math.Abs(a * a - b * 4.0 * c)));
                }

                // Note, eta should be positive if w is negative, and
                // eta should be negative otherwise. However,
                // if for some reason caused by roundoff, eta*w > 0,
                // we simply use one Newton step instead. This way
                // will guarantee eta*w < 0.0

                if (w * eta > 0.0)
                {
                    eta = -w / (dpsi + dphi);
                }
                temp = eta - dtnsq;
                if (temp > *rho)
                {
                    eta = *rho + dtnsq;
                }

                tau += eta;
                eta /= *sigma + Math.Sqrt(eta + *sigma * *sigma);
                i__1 = *n;
                for (j = 1; j <= i__1; ++j)
                {
                    delta[j] -= eta;
                    work[j] += eta;
                }

                *sigma += eta;

                // Evaluate PSI and the derivative DPSI

                dpsi = 0.0;
                psi = 0.0;
                erretm = 0.0;
                i__1 = ii;
                for (j = 1; j <= i__1; ++j)
                {
                    temp = z[j] / (work[j] * delta[j]);
                    psi += z[j] * temp;
                    dpsi += temp * temp;
                    erretm += psi;
                }
                erretm = Math.Abs(erretm);

                // Evaluate PHI and the derivative DPHI

                temp = z[*n] / (work[*n] * delta[*n]);
                phi = z[*n] * temp;
                dphi = temp * temp;
                erretm = (-phi - psi) * 8.0 + erretm - phi + rhoinv + Math.Abs(tau) * (dpsi
                    + dphi);

                w = rhoinv + phi + psi;

                // Main loop to update the values of the array   DELTA

                iter = niter + 1;

                for (niter = iter; niter <= 20; ++niter)
                {
                    // Test for convergence

                    if (Math.Abs(w) <= eps * erretm)
                    {
                        goto L240;
                    }

                    // Calculate the new step

                    dtnsq1 = work[*n - 1] * delta[*n - 1];
                    dtnsq = work[*n] * delta[*n];
                    c = w - dtnsq1 * dpsi - dtnsq * dphi;
                    a = (dtnsq + dtnsq1) * w - dtnsq1 * dtnsq * (dpsi + dphi);
                    b = dtnsq1 * dtnsq * w;
                    if (a >= 0.0)
                    {
                        eta = (a + Math.Sqrt(Math.Abs(a * a - b * 4.0 * c))) / (c * 2.0);
                    }
                    else
                    {
                        eta = b * 2.0 / (a - Math.Sqrt(Math.Abs(a * a - b * 4.0 * c)));
                    }

                    // Note, eta should be positive if w is negative, and
                    // eta should be negative otherwise. However,
                    // if for some reason caused by roundoff, eta*w > 0,
                    // we simply use one Newton step instead. This way
                    // will guarantee eta*w < 0.0

                    if (w * eta > 0.0)
                    {
                        eta = -w / (dpsi + dphi);
                    }
                    temp = eta - dtnsq;
                    if (temp <= 0.0)
                    {
                        eta /= 2.0;
                    }

                    tau += eta;
                    eta /= *sigma + Math.Sqrt(eta + *sigma * *sigma);
                    i__1 = *n;
                    for (j = 1; j <= i__1; ++j)
                    {
                        delta[j] -= eta;
                        work[j] += eta;
                    }

                    *sigma += eta;

                    // Evaluate PSI and the derivative DPSI

                    dpsi = 0.0;
                    psi = 0.0;
                    erretm = 0.0;
                    i__1 = ii;
                    for (j = 1; j <= i__1; ++j)
                    {
                        temp = z[j] / (work[j] * delta[j]);
                        psi += z[j] * temp;
                        dpsi += temp * temp;
                        erretm += psi;
                    }
                    erretm = Math.Abs(erretm);

                    // Evaluate PHI and the derivative DPHI

                    temp = z[*n] / (work[*n] * delta[*n]);
                    phi = z[*n] * temp;
                    dphi = temp * temp;
                    erretm = (-phi - psi) * 8.0 + erretm - phi + rhoinv + Math.Abs(tau) * (dpsi + dphi);

                    w = rhoinv + phi + psi;
                }

                // Return with INFO = 1, NITER = MAXIT and not converged

                *info = 1;
                goto L240;

                // End for the case I = N

            }
            else
            {
                // The case for I < N

                niter = 1;
                ip1 = *i + 1;

                // Calculate initial guess

                delsq = (d[ip1] - d[*i]) * (d[ip1] + d[*i]);
                delsq2 = delsq / 2.0;
                temp = delsq2 / (d[*i] + Math.Sqrt(d[*i] * d[*i] + delsq2));
                i__1 = *n;
                for (j = 1; j <= i__1; ++j)
                {
                    work[j] = d[j] + d[*i] + temp;
                    delta[j] = d[j] - d[*i] - temp;
                }

                psi = 0.0;
                i__1 = *i - 1;
                for (j = 1; j <= i__1; ++j)
                {
                    psi += z[j] * z[j] / (work[j] * delta[j]);
                }

                phi = 0.0;
                i__1 = *i + 2;
                for (j = *n; j >= i__1; --j)
                {
                    phi += z[j] * z[j] / (work[j] * delta[j]);
                }
                c = rhoinv + psi + phi;
                w = c + z[*i] * z[*i] / (work[*i] * delta[*i]) + z[ip1] * z[ip1] / (work[ip1] * delta[ip1]);

                if (w > 0.0)
                {
                    // d(i)^2 < the ith sigma^2 < (d(i)^2+d(i+1)^2)/2

                    // We choose d(i) as origin.

                    orgati = true;
                    sg2lb = 0.0;
                    sg2ub = delsq2;
                    a = c * delsq + z[*i] * z[*i] + z[ip1] * z[ip1];
                    b = z[*i] * z[*i] * delsq;
                    if (a > 0.0)
                    {
                        tau = b * 2.0 / (a + Math.Sqrt(Math.Abs(a * a - b * 4.0 * c)));
                    }
                    else
                    {
                        tau = (a - Math.Sqrt(Math.Abs(a * a - b * 4.0 * c))) / (c * 2.0);
                    }

                    // TAU now is an estimation of SIGMA^2 - D( I )^2.0 The
                    // following, however, is the corresponding estimation of
                    // SIGMA - D( I ).

                    eta = tau / (d[*i] + Math.Sqrt(d[*i] * d[*i] + tau));
                }
                else
                {
                    // (d(i)^2+d(i+1)^2)/2 <= the ith sigma^2 < d(i+1)^2/2

                    // We choose d(i+1) as origin.

                    orgati = false;
                    sg2lb = -delsq2;
                    sg2ub = 0.0;
                    a = c * delsq - z[*i] * z[*i] - z[ip1] * z[ip1];
                    b = z[ip1] * z[ip1] * delsq;
                    if (a < 0.0)
                    {
                        tau = b * 2.0 / (a - Math.Sqrt(Math.Abs(a * a + b * 4.0 * c)));
                    }
                    else
                    {
                        tau = -(a + Math.Sqrt(Math.Abs(a * a + b * 4.0 * c))) / (c * 2.0);
                    }

                    // TAU now is an estimation of SIGMA^2 - D( IP1 )^2.0 The
                    // following, however, is the corresponding estimation of
                    // SIGMA - D( IP1 ).

                    eta = tau / (d[ip1] + Math.Sqrt(Math.Abs(d[ip1] * d[ip1] + tau)));
                }

                if (orgati)
                {
                    ii = *i;
                    *sigma = d[*i] + eta;
                    i__1 = *n;
                    for (j = 1; j <= i__1; ++j)
                    {
                        work[j] = d[j] + d[*i] + eta;
                        delta[j] = d[j] - d[*i] - eta;
                    }
                }
                else
                {
                    ii = *i + 1;
                    *sigma = d[ip1] + eta;
                    i__1 = *n;
                    for (j = 1; j <= i__1; ++j)
                    {
                        work[j] = d[j] + d[ip1] + eta;
                        delta[j] = d[j] - d[ip1] - eta;
                    }
                }
                iim1 = ii - 1;
                iip1 = ii + 1;

                // Evaluate PSI and the derivative DPSI

                dpsi = 0.0;
                psi = 0.0;
                erretm = 0.0;
                i__1 = iim1;
                for (j = 1; j <= i__1; ++j)
                {
                    temp = z[j] / (work[j] * delta[j]);
                    psi += z[j] * temp;
                    dpsi += temp * temp;
                    erretm += psi;
                }
                erretm = Math.Abs(erretm);

                // Evaluate PHI and the derivative DPHI

                dphi = 0.0;
                phi = 0.0;
                i__1 = iip1;
                for (j = *n; j >= i__1; --j)
                {
                    temp = z[j] / (work[j] * delta[j]);
                    phi += z[j] * temp;
                    dphi += temp * temp;
                    erretm += phi;
                }

                w = rhoinv + phi + psi;

                // W is the value of the secular function with
                // its ii-th element removed.

                swtch3 = false;
                if (orgati)
                {
                    if (w < 0.0)
                    {
                        swtch3 = true;
                    }
                }
                else
                {
                    if (w > 0.0)
                    {
                        swtch3 = true;
                    }
                }
                if (ii == 1 || ii == *n)
                {
                    swtch3 = false;
                }

                temp = z[ii] / (work[ii] * delta[ii]);
                dw = dpsi + dphi + temp * temp;
                temp = z[ii] * temp;
                w += temp;
                erretm = (phi - psi) * 8.0 + erretm + rhoinv * 2.0 + Math.Abs(temp) * 3.0 + Math.Abs(tau) * dw;

                // Test for convergence

                if (Math.Abs(w) <= eps * erretm)
                {
                    goto L240;
                }

                if (w <= 0.0)
                {
                    sg2lb = Math.Max(sg2lb, tau);
                }
                else
                {
                    sg2ub = Math.Min(sg2ub, tau);
                }

                // Calculate the new step

                ++niter;
                if (!swtch3)
                {
                    dtipsq = work[ip1] * delta[ip1];
                    dtisq = work[*i] * delta[*i];
                    if (orgati)
                    {
                        // Computing 2nd power
                        d__1 = z[*i] / dtisq;
                        c = w - dtipsq * dw + delsq * (d__1 * d__1);
                    }
                    else
                    {
                        // Computing 2nd power
                        d__1 = z[ip1] / dtipsq;
                        c = w - dtisq * dw - delsq * (d__1 * d__1);
                    }
                    a = (dtipsq + dtisq) * w - dtipsq * dtisq * dw;
                    b = dtipsq * dtisq * w;
                    if (c == 0.0)
                    {
                        if (a == 0.0)
                        {
                            if (orgati)
                            {
                                a = z[*i] * z[*i] + dtipsq * dtipsq * (dpsi + dphi);
                            }
                            else
                            {
                                a = z[ip1] * z[ip1] + dtisq * dtisq * (dpsi + dphi);
                            }
                        }
                        eta = b / a;
                    }
                    else if (a <= 0.0)
                    {
                        eta = (a - Math.Sqrt(Math.Abs(a * a - b * 4.0 * c))) / (c * 2.0);
                    }
                    else
                    {
                        eta = b * 2.0 / (a + Math.Sqrt(Math.Abs(a * a - b * 4.0 * c)));
                    }
                }
                else
                {
                    // Interpolation using THREE most relevant poles

                    dtiim = work[iim1] * delta[iim1];
                    dtiip = work[iip1] * delta[iip1];
                    temp = rhoinv + psi + phi;
                    if (orgati)
                    {
                        temp1 = z[iim1] / dtiim;
                        temp1 *= temp1;
                        c = temp - dtiip * (dpsi + dphi) - (d[iim1] - d[iip1]) * (d[iim1] + d[iip1]) * temp1;
                        zz[0] = z[iim1] * z[iim1];
                        if (dpsi < temp1)
                        {
                            zz[2] = dtiip * dtiip * dphi;
                        }
                        else
                        {
                            zz[2] = dtiip * dtiip * (dpsi - temp1 + dphi);
                        }
                    }
                    else
                    {
                        temp1 = z[iip1] / dtiip;
                        temp1 *= temp1;
                        c = temp - dtiim * (dpsi + dphi) - (d[iip1] - d[iim1]) * (d[iim1] + d[iip1]) * temp1;
                        if (dphi < temp1)
                        {
                            zz[0] = dtiim * dtiim * dpsi;
                        }
                        else
                        {
                            zz[0] = dtiim * dtiim * (dpsi + (dphi - temp1));
                        }
                        zz[2] = z[iip1] * z[iip1];
                    }
                    zz[1] = z[ii] * z[ii];
                    dd[0] = dtiim;
                    dd[1] = delta[ii] * work[ii];
                    dd[2] = dtiip;
                    dlaed6(&niter, &orgati, &c, dd, zz, &w, &eta, info);
                    if (*info != 0)
                    {
                        goto L240;
                    }
                }

                // Note, eta should be positive if w is negative, and
                // eta should be negative otherwise. However,
                // if for some reason caused by roundoff, eta*w > 0,
                // we simply use one Newton step instead. This way
                // will guarantee eta*w < 0.0

                if (w * eta >= 0.0)
                {
                    eta = -w / dw;
                }
                if (orgati)
                {
                    temp1 = work[*i] * delta[*i];
                    temp = eta - temp1;
                }
                else
                {
                    temp1 = work[ip1] * delta[ip1];
                    temp = eta - temp1;
                }
                if (temp > sg2ub || temp < sg2lb)
                {
                    if (w < 0.0)
                    {
                        eta = (sg2ub - tau) / 2.0;
                    }
                    else
                    {
                        eta = (sg2lb - tau) / 2.0;
                    }
                }

                tau += eta;
                eta /= *sigma + Math.Sqrt(*sigma * *sigma + eta);

                prew = w;

                *sigma += eta;
                i__1 = *n;
                for (j = 1; j <= i__1; ++j)
                {
                    work[j] += eta;
                    delta[j] -= eta;
                }

                // Evaluate PSI and the derivative DPSI

                dpsi = 0.0;
                psi = 0.0;
                erretm = 0.0;
                i__1 = iim1;
                for (j = 1; j <= i__1; ++j)
                {
                    temp = z[j] / (work[j] * delta[j]);
                    psi += z[j] * temp;
                    dpsi += temp * temp;
                    erretm += psi;
                }
                erretm = Math.Abs(erretm);

                // Evaluate PHI and the derivative DPHI

                dphi = 0.0;
                phi = 0.0;
                i__1 = iip1;
                for (j = *n; j >= i__1; --j)
                {
                    temp = z[j] / (work[j] * delta[j]);
                    phi += z[j] * temp;
                    dphi += temp * temp;
                    erretm += phi;
                }

                temp = z[ii] / (work[ii] * delta[ii]);
                dw = dpsi + dphi + temp * temp;
                temp = z[ii] * temp;
                w = rhoinv + phi + psi + temp;
                erretm = (phi - psi) * 8.0 + erretm + rhoinv * 2.0 + Math.Abs(temp) * 3.0 + Math.Abs(tau) * dw;

                if (w <= 0.0)
                {
                    sg2lb = Math.Max(sg2lb, tau);
                }
                else
                {
                    sg2ub = Math.Min(sg2ub, tau);
                }

                swtch = false;
                if (orgati)
                {
                    if (-w > Math.Abs(prew) / 10.0)
                    {
                        swtch = true;
                    }
                }
                else
                {
                    if (w > Math.Abs(prew) / 10.0)
                    {
                        swtch = true;
                    }
                }

                // Main loop to update the values of the array   DELTA and WORK

                iter = niter + 1;

                for (niter = iter; niter <= 20; ++niter)
                {
                    // Test for convergence

                    if (Math.Abs(w) <= eps * erretm)
                    {
                        goto L240;
                    }

                    // Calculate the new step

                    if (!swtch3)
                    {
                        dtipsq = work[ip1] * delta[ip1];
                        dtisq = work[*i] * delta[*i];
                        if (!swtch)
                        {
                            if (orgati)
                            {
                                // Computing 2nd power
                                d__1 = z[*i] / dtisq;
                                c = w - dtipsq * dw + delsq * (d__1 * d__1);
                            }
                            else
                            {
                                // Computing 2nd power
                                d__1 = z[ip1] / dtipsq;
                                c = w - dtisq * dw - delsq * (d__1 * d__1);
                            }
                        }
                        else
                        {
                            temp = z[ii] / (work[ii] * delta[ii]);
                            if (orgati)
                            {
                                dpsi += temp * temp;
                            }
                            else
                            {
                                dphi += temp * temp;
                            }
                            c = w - dtisq * dpsi - dtipsq * dphi;
                        }
                        a = (dtipsq + dtisq) * w - dtipsq * dtisq * dw;
                        b = dtipsq * dtisq * w;

                        if (c == 0.0)
                        {
                            if (a == 0.0)
                            {
                                if (!swtch)
                                {
                                    if (orgati)
                                    {
                                        a = z[*i] * z[*i] + dtipsq * dtipsq * (dpsi + dphi);
                                    }
                                    else
                                    {
                                        a = z[ip1] * z[ip1] + dtisq * dtisq * (dpsi + dphi);
                                    }
                                }
                                else
                                {
                                    a = dtisq * dtisq * dpsi + dtipsq * dtipsq * dphi;
                                }
                            }
                            eta = b / a;
                        }
                        else if (a <= 0.0)
                        {
                            eta = (a - Math.Sqrt(Math.Abs(a * a - b * 4.0 * c))) / (c * 2.0);
                        }
                        else
                        {
                            eta = b * 2.0 / (a + Math.Sqrt(Math.Abs(a * a - b * 4.0 * c)));
                        }
                    }
                    else
                    {
                        // Interpolation using THREE most relevant poles

                        dtiim = work[iim1] * delta[iim1];
                        dtiip = work[iip1] * delta[iip1];
                        temp = rhoinv + psi + phi;
                        if (swtch)
                        {
                            c = temp - dtiim * dpsi - dtiip * dphi;
                            zz[0] = dtiim * dtiim * dpsi;
                            zz[2] = dtiip * dtiip * dphi;
                        }
                        else
                        {
                            if (orgati)
                            {
                                temp1 = z[iim1] / dtiim;
                                temp1 *= temp1;
                                temp2 = (d[iim1] - d[iip1]) * (d[iim1] + d[iip1]) * temp1;
                                c = temp - dtiip * (dpsi + dphi) - temp2;
                                zz[0] = z[iim1] * z[iim1];
                                if (dpsi < temp1)
                                {
                                    zz[2] = dtiip * dtiip * dphi;
                                }
                                else
                                {
                                    zz[2] = dtiip * dtiip * (dpsi - temp1 + dphi);
                                }
                            }
                            else
                            {
                                temp1 = z[iip1] / dtiip;
                                temp1 *= temp1;
                                temp2 = (d[iip1] - d[iim1]) * (d[iim1] + d[iip1]) * temp1;
                                c = temp - dtiim * (dpsi + dphi) - temp2;
                                if (dphi < temp1)
                                {
                                    zz[0] = dtiim * dtiim * dpsi;
                                }
                                else
                                {
                                    zz[0] = dtiim * dtiim * (dpsi + (dphi - temp1));
                                }
                                zz[2] = z[iip1] * z[iip1];
                            }
                        }
                        dd[0] = dtiim;
                        dd[1] = delta[ii] * work[ii];
                        dd[2] = dtiip;
                        dlaed6(&niter, &orgati, &c, dd, zz, &w, &eta, info);

                        if (*info != 0)
                        {
                            goto L240;
                        }
                    }

                    // Note, eta should be positive if w is negative, and
                    // eta should be negative otherwise. However,
                    // if for some reason caused by roundoff, eta*w > 0,
                    // we simply use one Newton step instead. This way
                    // will guarantee eta*w < 0.0

                    if (w * eta >= 0.0)
                    {
                        eta = -w / dw;
                    }
                    if (orgati)
                    {
                        temp1 = work[*i] * delta[*i];
                        temp = eta - temp1;
                    }
                    else
                    {
                        temp1 = work[ip1] * delta[ip1];
                        temp = eta - temp1;
                    }
                    if (temp > sg2ub || temp < sg2lb)
                    {
                        if (w < 0.0)
                        {
                            eta = (sg2ub - tau) / 2.0;
                        }
                        else
                        {
                            eta = (sg2lb - tau) / 2.0;
                        }
                    }

                    tau += eta;
                    eta /= *sigma + Math.Sqrt(*sigma * *sigma + eta);

                    *sigma += eta;
                    i__1 = *n;
                    for (j = 1; j <= i__1; ++j)
                    {
                        work[j] += eta;
                        delta[j] -= eta;
                    }

                    prew = w;

                    // Evaluate PSI and the derivative DPSI

                    dpsi = 0.0;
                    psi = 0.0;
                    erretm = 0.0;
                    i__1 = iim1;
                    for (j = 1; j <= i__1; ++j)
                    {
                        temp = z[j] / (work[j] * delta[j]);
                        psi += z[j] * temp;
                        dpsi += temp * temp;
                        erretm += psi;
                    }
                    erretm = Math.Abs(erretm);

                    // Evaluate PHI and the derivative DPHI

                    dphi = 0.0;
                    phi = 0.0;
                    i__1 = iip1;
                    for (j = *n; j >= i__1; --j)
                    {
                        temp = z[j] / (work[j] * delta[j]);
                        phi += z[j] * temp;
                        dphi += temp * temp;
                        erretm += phi;
                    }

                    temp = z[ii] / (work[ii] * delta[ii]);
                    dw = dpsi + dphi + temp * temp;
                    temp = z[ii] * temp;
                    w = rhoinv + phi + psi + temp;
                    erretm = (phi - psi) * 8.0 + erretm + rhoinv * 2.0 + Math.Abs(temp) * 3.0 + Math.Abs(tau) * dw;
                    if (w * prew > 0.0 && Math.Abs(w) > Math.Abs(prew) / 10.0)
                    {
                        swtch = !swtch;
                    }

                    if (w <= 0.0)
                    {
                        sg2lb = Math.Max(sg2lb, tau);
                    }
                    else
                    {
                        sg2ub = Math.Min(sg2ub, tau);
                    }
                }

                // Return with INFO = 1, NITER = MAXIT and not converged

                *info = 1;

            }

        L240:
            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int dlasd5(int* i, double* d, double* z,
            double* delta, double* rho, double* dsigma, double* work)
        {
            //  -- LAPACK auxiliary routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     November 2006

            //  Purpose
            //  =======

            //  This subroutine computes the square root of the I-th eigenvalue
            //  of a positive symmetric rank-one modification of a 2-by-2 diagonal
            //  matrix

            //             diag( D ) * diag( D ) +  RHO *  Z * transpose(Z) .

            //  The diagonal entries in the array D are assumed to satisfy

            //             0 <= D(i) < D(j)  for  i < j .

            //  We also assume RHO > 0 and that the Euclidean norm of the vector
            //  Z is one.

            //  Arguments
            //  =========

            //  I      (input) INTEGER
            //         The index of the eigenvalue to be computed.  I = 1 or I = 2.0

            //  D      (input) DOUBLE PRECISION array, dimension ( 2 )
            //         The original eigenvalues.  We assume 0 <= D(1) < D(2).

            //  Z      (input) DOUBLE PRECISION array, dimension ( 2 )
            //         The components of the updating vector.

            //  DELTA  (output) DOUBLE PRECISION array, dimension ( 2 )
            //         Contains (D(j) - sigma_I) in its  j-th component.
            //         The vector DELTA contains the information necessary
            //         to construct the eigenvectors.

            //  RHO    (input) DOUBLE PRECISION
            //         The scalar in the symmetric updating formula.

            //  DSIGMA (output) DOUBLE PRECISION
            //         The computed sigma_I, the I-th updated eigenvalue.

            //  WORK   (workspace) DOUBLE PRECISION array, dimension ( 2 )
            //         WORK contains (D(j) + sigma_I) in its  j-th component.

            //  Further Details
            //  ===============

            //  Based on contributions by
            //     Ren-Cang Li, Computer Science Division, University of California
            //     at Berkeley, USA

            //  =====================================================================

            // Local variables
            double b, c, w, del, tau, delsq;

            // Parameter adjustments
            --work;
            --delta;
            --z;
            --d;

            // Function Body
            del = d[2] - d[1];
            delsq = del * (d[2] + d[1]);
            if (*i == 1)
            {
                w = *rho * 4.0 * (z[2] * z[2] / (d[1] + d[2] * 3.0) - z[1] * z[1] / (d[1] * 3.0 + d[2])) / del + 1.0;
                if (w > 0.0)
                {
                    b = delsq + *rho * (z[1] * z[1] + z[2] * z[2]);
                    c = *rho * z[1] * z[1] * delsq;

                    // B > ZERO, always

                    // The following TAU is DSIGMA * DSIGMA - D( 1 ) * D( 1 )

                    tau = c * 2.0 / (b + Math.Sqrt(Math.Abs(b * b - c * 4.0)));

                    // The following TAU is DSIGMA - D( 1 )

                    tau /= d[1] + Math.Sqrt(d[1] * d[1] + tau);
                    *dsigma = d[1] + tau;
                    delta[1] = -tau;
                    delta[2] = del - tau;
                    work[1] = d[1] * 2.0 + tau;
                    work[2] = d[1] + tau + d[2];
                    // DELTA( 1 ) = -Z( 1 ) / TAU
                    // DELTA( 2 ) = Z( 2 ) / ( DEL-TAU )
                }
                else
                {
                    b = -delsq + *rho * (z[1] * z[1] + z[2] * z[2]);
                    c = *rho * z[2] * z[2] * delsq;

                    // The following TAU is DSIGMA * DSIGMA - D( 2 ) * D( 2 )

                    if (b > 0.0)
                    {
                        tau = c * -2.0 / (b + Math.Sqrt(b * b + c * 4.0));
                    }
                    else
                    {
                        tau = (b - Math.Sqrt(b * b + c * 4.0)) / 2.0;
                    }

                    // The following TAU is DSIGMA - D( 2 )

                    tau /= d[2] + Math.Sqrt(Math.Abs(d[2] * d[2] + tau));
                    *dsigma = d[2] + tau;
                    delta[1] = -(del + tau);
                    delta[2] = -tau;
                    work[1] = d[1] + tau + d[2];
                    work[2] = d[2] * 2.0 + tau;
                    // DELTA( 1 ) = -Z( 1 ) / ( DEL+TAU )
                    // DELTA( 2 ) = -Z( 2 ) / TAU
                }

                // TEMP = SQRT( DELTA( 1 )*DELTA( 1 )+DELTA( 2 )*DELTA( 2 ) )
                // DELTA( 1 ) = DELTA( 1 ) / TEMP
                // DELTA( 2 ) = DELTA( 2 ) / TEMP
            }
            else
            {
                // Now I=2

                b = -delsq + *rho * (z[1] * z[1] + z[2] * z[2]);
                c = *rho * z[2] * z[2] * delsq;

                // The following TAU is DSIGMA * DSIGMA - D( 2 ) * D( 2 )

                if (b > 0.0)
                {
                    tau = (b + Math.Sqrt(b * b + c * 4.0)) / 2.0;
                }
                else
                {
                    tau = c * 2.0 / (-b + Math.Sqrt(b * b + c * 4.0));
                }

                // The following TAU is DSIGMA - D( 2 )

                tau /= d[2] + Math.Sqrt(d[2] * d[2] + tau);
                *dsigma = d[2] + tau;
                delta[1] = -(del + tau);
                delta[2] = -tau;
                work[1] = d[1] + tau + d[2];
                work[2] = d[2] * 2.0 + tau;
                // DELTA( 1 ) = -Z( 1 ) / ( DEL+TAU )
                // DELTA( 2 ) = -Z( 2 ) / TAU
                // TEMP = SQRT( DELTA( 1 )*DELTA( 1 )+DELTA( 2 )*DELTA( 2 ) )
                // DELTA( 1 ) = DELTA( 1 ) / TEMP
                // DELTA( 2 ) = DELTA( 2 ) / TEMP
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int dlasd6(int* icompq, int* nl, int* nr, int* sqre, double* d, double* vf,
            double* vl, double* alpha, double* beta, int* idxq, int* perm, int* givptr, int* givcol,
            int* ldgcol, double* givnum, int* ldgnum, double* poles, double* difl, double* difr, double* z,
            int* k, double* c, double* s, double* work, int* iwork, int* info)
        {
            //  -- LAPACK auxiliary routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     November 2006

            //  Purpose
            //  =======

            //  DLASD6 computes the SVD of an updated upper bidiagonal matrix B
            //  obtained by merging two smaller ones by appending a row. This
            //  routine is used only for the problem which requires all singular
            //  values and optionally singular vector matrices in factored form.
            //  B is an N-by-M matrix with N = NL + NR + 1 and M = N + SQRE.
            //  A related subroutine, DLASD1, handles the case in which all singular
            //  values and singular vectors of the bidiagonal matrix are desired.

            //  DLASD6 computes the SVD as follows:

            //                ( D1(in)  0    0     0 )
            //    B = U(in) * (   Z1'   a   Z2'    b ) * VT(in)
            //                (   0     0   D2(in) 0 )

            //      = U(out) * ( D(out) 0) * VT(out)

            //  where Z' = (Z1' a Z2' b) = u' VT', and u is a vector of dimension M
            //  with ALPHA and BETA in the NL+1 and NL+2 th entries and zeros
            //  elsewhere; and the entry b is empty if SQRE = 0.0

            //  The singular values of B can be computed using D1, D2, the first
            //  components of all the right singular vectors of the lower block, and
            //  the last components of all the right singular vectors of the upper
            //  block. These components are stored and updated in VF and VL,
            //  respectively, in DLASD6.0 Hence U and VT are not explicitly
            //  referenced.

            //  The singular values are stored in D. The algorithm consists of two
            //  stages:

            //        The first stage consists of deflating the size of the problem
            //        when there are multiple singular values or if there is a zero
            //        in the Z vector. For each such occurence the dimension of the
            //        secular equation problem is reduced by one. This stage is
            //        performed by the routine DLASD7.0

            //        The second stage consists of calculating the updated
            //        singular values. This is done by finding the roots of the
            //        secular equation via the routine DLASD4 (as called by DLASD8).
            //        This routine also updates VF and VL and computes the distances
            //        between the updated singular values and the old singular
            //        values.

            //  DLASD6 is called from DLASDA.

            //  Arguments
            //  =========

            //  ICOMPQ (input) INTEGER
            //         Specifies whether singular vectors are to be computed in
            //         factored form:
            //         = 0: Compute singular values only.
            //         = 1: Compute singular vectors in factored form as well.

            //  NL     (input) INTEGER
            //         The row dimension of the upper block.  NL >= 1.0

            //  NR     (input) INTEGER
            //         The row dimension of the lower block.  NR >= 1.0

            //  SQRE   (input) INTEGER
            //         = 0: the lower block is an NR-by-NR square matrix.
            //         = 1: the lower block is an NR-by-(NR+1) rectangular matrix.

            //         The bidiagonal matrix has row dimension N = NL + NR + 1,
            //         and column dimension M = N + SQRE.

            //  D      (input/output) DOUBLE PRECISION array, dimension ( NL+NR+1 ).
            //         On entry D(1:NL,1:NL) contains the singular values of the
            //         upper block, and D(NL+2:N) contains the singular values
            //         of the lower block. On exit D(1:N) contains the singular
            //         values of the modified matrix.

            //  VF     (input/output) DOUBLE PRECISION array, dimension ( M )
            //         On entry, VF(1:NL+1) contains the first components of all
            //         right singular vectors of the upper block; and VF(NL+2:M)
            //         contains the first components of all right singular vectors
            //         of the lower block. On exit, VF contains the first components
            //         of all right singular vectors of the bidiagonal matrix.

            //  VL     (input/output) DOUBLE PRECISION array, dimension ( M )
            //         On entry, VL(1:NL+1) contains the  last components of all
            //         right singular vectors of the upper block; and VL(NL+2:M)
            //         contains the last components of all right singular vectors of
            //         the lower block. On exit, VL contains the last components of
            //         all right singular vectors of the bidiagonal matrix.

            //  ALPHA  (input/output) DOUBLE PRECISION
            //         Contains the diagonal element associated with the added row.

            //  BETA   (input/output) DOUBLE PRECISION
            //         Contains the off-diagonal element associated with the added
            //         row.

            //  IDXQ   (output) INTEGER array, dimension ( N )
            //         This contains the permutation which will reintegrate the
            //         subproblem just solved back into sorted order, i.e.
            //         D( IDXQ( I = 1, N ) ) will be in ascending order.

            //  PERM   (output) INTEGER array, dimension ( N )
            //         The permutations (from deflation and sorting) to be applied
            //         to each block. Not referenced if ICOMPQ = 0.0

            //  GIVPTR (output) INTEGER
            //         The number of Givens rotations which took place in this
            //         subproblem. Not referenced if ICOMPQ = 0.0

            //  GIVCOL (output) INTEGER array, dimension ( LDGCOL, 2 )
            //         Each pair of numbers indicates a pair of columns to take place
            //         in a Givens rotation. Not referenced if ICOMPQ = 0.0

            //  LDGCOL (input) INTEGER
            //         leading dimension of GIVCOL, must be at least N.

            //  GIVNUM (output) DOUBLE PRECISION array, dimension ( LDGNUM, 2 )
            //         Each number indicates the C or S value to be used in the
            //         corresponding Givens rotation. Not referenced if ICOMPQ = 0.0

            //  LDGNUM (input) INTEGER
            //         The leading dimension of GIVNUM and POLES, must be at least N.

            //  POLES  (output) DOUBLE PRECISION array, dimension ( LDGNUM, 2 )
            //         On exit, POLES(1,*) is an array containing the new singular
            //         values obtained from solving the secular equation, and
            //         POLES(2,*) is an array containing the poles in the secular
            //         equation. Not referenced if ICOMPQ = 0.0

            //  DIFL   (output) DOUBLE PRECISION array, dimension ( N )
            //         On exit, DIFL(I) is the distance between I-th updated
            //         (undeflated) singular value and the I-th (undeflated) old
            //         singular value.

            //  DIFR   (output) DOUBLE PRECISION array,
            //                  dimension ( LDGNUM, 2 ) if ICOMPQ = 1 and
            //                  dimension ( N ) if ICOMPQ = 0.0
            //         On exit, DIFR(I, 1) is the distance between I-th updated
            //         (undeflated) singular value and the I+1-th (undeflated) old
            //         singular value.

            //         If ICOMPQ = 1, DIFR(1:K,2) is an array containing the
            //         normalizing factors for the right singular vector matrix.

            //         See DLASD8 for details on DIFL and DIFR.

            //  Z      (output) DOUBLE PRECISION array, dimension ( M )
            //         The first elements of this array contain the components
            //         of the deflation-adjusted updating row vector.

            //  K      (output) INTEGER
            //         Contains the dimension of the non-deflated matrix,
            //         This is the order of the related secular equation. 1 <= K <=N.

            //  C      (output) DOUBLE PRECISION
            //         C contains garbage if SQRE =0 and the C-value of a Givens
            //         rotation related to the right null space if SQRE = 1.0

            //  S      (output) DOUBLE PRECISION
            //         S contains garbage if SQRE =0 and the S-value of a Givens
            //         rotation related to the right null space if SQRE = 1.0

            //  WORK   (workspace) DOUBLE PRECISION array, dimension ( 4 * M )

            //  IWORK  (workspace) INTEGER array, dimension ( 3 * N )

            //  INFO   (output) INTEGER
            //          = 0:  successful exit.
            //          < 0:  if INFO = -i, the i-th argument had an illegal value.
            //          > 0:  if INFO = 1, an singular value did not converge

            //  Further Details
            //  ===============

            //  Based on contributions by
            //     Ming Gu and Huan Ren, Computer Science Division, University of
            //     California at Berkeley, USA

            //  =====================================================================

            // System generated locals
            int givcol_dim1, givcol_offset, givnum_dim1, givnum_offset, poles_dim1, poles_offset, i__1;
            double d__1, d__2;

            // Table of constant values
            int c__0 = 0;
            double c_b7 = 1.0;
            int c__1 = 1;
            int c_n1 = -1;

            // Local variables
            int i__, m, n, n1, n2, iw, idx, idxc, idxp, ivfw, ivlw;
            int isigma;
            double orgnrm;

            // Parameter adjustments
            --d;
            --vf;
            --vl;
            --idxq;
            --perm;
            givcol_dim1 = *ldgcol;
            givcol_offset = 1 + givcol_dim1;
            givcol -= givcol_offset;
            poles_dim1 = *ldgnum;
            poles_offset = 1 + poles_dim1;
            poles -= poles_offset;
            givnum_dim1 = *ldgnum;
            givnum_offset = 1 + givnum_dim1;
            givnum -= givnum_offset;
            --difl;
            --difr;
            --z;
            --work;
            --iwork;

            // Function Body
            *info = 0;
            n = *nl + *nr + 1;
            m = n + *sqre;

            if (*icompq < 0 || *icompq > 1)
            {
                *info = -1;
            }
            else if (*nl < 1)
            {
                *info = -2;
            }
            else if (*nr < 1)
            {
                *info = -3;
            }
            else if (*sqre < 0 || *sqre > 1)
            {
                *info = -4;
            }
            else if (*ldgcol < n)
            {
                *info = -14;
            }
            else if (*ldgnum < n)
            {
                *info = -16;
            }
            if (*info != 0)
            {
                i__1 = -(*info);
                xerbla("DLASD6", &i__1);
                return 0;
            }

            // The following values are for bookkeeping purposes only.  They are
            // int pointers which indicate the portion of the workspace
            // used by a particular array in DLASD7 and DLASD8.0

            isigma = 1;
            iw = isigma + n;
            ivfw = iw + m;
            ivlw = ivfw + m;

            idx = 1;
            idxc = idx + n;
            idxp = idxc + n;

            // Scale.

            // Computing MAX
            d__1 = Math.Abs(*alpha);
            d__2 = Math.Abs(*beta);
            orgnrm = Math.Max(d__1, d__2);
            d[*nl + 1] = 0.0;

            i__1 = n;
            for (i__ = 1; i__ <= i__1; ++i__)
            {
                if (Math.Abs(d[i__]) > orgnrm)
                {
                    orgnrm = Math.Abs(d[i__]);
                }
            }
            dlascl("G", &c__0, &c__0, &orgnrm, &c_b7, &n, &c__1, &d[1], &n, info);
            *alpha /= orgnrm;
            *beta /= orgnrm;

            // Sort and Deflate singular values.

            dlasd7(icompq, nl, nr, sqre, k, &d[1], &z[1], &work[iw], &vf[1],
                &work[ivfw], &vl[1], &work[ivlw], alpha, beta, &work[isigma],
                &iwork[idx], &iwork[idxp], &idxq[1], &perm[1], givptr, &givcol[givcol_offset],
                ldgcol, &givnum[givnum_offset], ldgnum, c, s, info);

            // Solve Secular Equation, compute DIFL, DIFR, and update VF, VL.

            dlasd8(icompq, k, &d[1], &z[1], &vf[1], &vl[1], &difl[1], &difr[1],
                ldgnum, &work[isigma], &work[iw], info);

            // Save the poles if ICOMPQ = 1.0

            if (*icompq == 1)
            {
                dcopy(k, &d[1], &c__1, &poles[poles_dim1 + 1], &c__1);
                dcopy(k, &work[isigma], &c__1, &poles[(poles_dim1 << 1) + 1], &c__1);
            }

            // Unscale.

            dlascl("G", &c__0, &c__0, &c_b7, &orgnrm, &n, &c__1, &d[1], &n, info);

            // Prepare the IDXQ sorting permutation.

            n1 = *k;
            n2 = n - *k;
            dlamrg(&n1, &n2, &d[1], &c__1, &c_n1, &idxq[1]);

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int dlasd7(int* icompq, int* nl, int* nr, int* sqre, int* k, double* d, double* z,
            double* zw, double* vf, double* vfw, double* vl, double* vlw, double* alpha, double* beta, double* dsigma,
            int* idx, int* idxp, int* idxq, int* perm, int* givptr, int* givcol, int* ldgcol, double* givnum,
             int* ldgnum, double* c, double* s, int* info)
        {
            //  -- LAPACK auxiliary routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     November 2006

            //  Purpose
            //  =======

            //  DLASD7 merges the two sets of singular values together into a single
            //  sorted set. Then it tries to deflate the size of the problem. There
            //  are two ways in which deflation can occur:  when two or more singular
            //  values are close together or if there is a tiny entry in the Z
            //  vector. For each such occurrence the order of the related
            //  secular equation problem is reduced by one.

            //  DLASD7 is called from DLASD6.0

            //  Arguments
            //  =========

            //  ICOMPQ  (input) INTEGER
            //          Specifies whether singular vectors are to be computed
            //          in compact form, as follows:
            //          = 0: Compute singular values only.
            //          = 1: Compute singular vectors of upper
            //               bidiagonal matrix in compact form.

            //  NL     (input) INTEGER
            //         The row dimension of the upper block. NL >= 1.0

            //  NR     (input) INTEGER
            //         The row dimension of the lower block. NR >= 1.0

            //  SQRE   (input) INTEGER
            //         = 0: the lower block is an NR-by-NR square matrix.
            //         = 1: the lower block is an NR-by-(NR+1) rectangular matrix.

            //         The bidiagonal matrix has
            //         N = NL + NR + 1 rows and
            //         M = N + SQRE >= N columns.

            //  K      (output) INTEGER
            //         Contains the dimension of the non-deflated matrix, this is
            //         the order of the related secular equation. 1 <= K <=N.

            //  D      (input/output) DOUBLE PRECISION array, dimension ( N )
            //         On entry D contains the singular values of the two submatrices
            //         to be combined. On exit D contains the trailing (N-K) updated
            //         singular values (those which were deflated) sorted into
            //         increasing order.

            //  Z      (output) DOUBLE PRECISION array, dimension ( M )
            //         On exit Z contains the updating row vector in the secular
            //         equation.

            //  ZW     (workspace) DOUBLE PRECISION array, dimension ( M )
            //         Workspace for Z.

            //  VF     (input/output) DOUBLE PRECISION array, dimension ( M )
            //         On entry, VF(1:NL+1) contains the first components of all
            //         right singular vectors of the upper block; and VF(NL+2:M)
            //         contains the first components of all right singular vectors
            //         of the lower block. On exit, VF contains the first components
            //         of all right singular vectors of the bidiagonal matrix.

            //  VFW    (workspace) DOUBLE PRECISION array, dimension ( M )
            //         Workspace for VF.

            //  VL     (input/output) DOUBLE PRECISION array, dimension ( M )
            //         On entry, VL(1:NL+1) contains the  last components of all
            //         right singular vectors of the upper block; and VL(NL+2:M)
            //         contains the last components of all right singular vectors
            //         of the lower block. On exit, VL contains the last components
            //         of all right singular vectors of the bidiagonal matrix.

            //  VLW    (workspace) DOUBLE PRECISION array, dimension ( M )
            //         Workspace for VL.

            //  ALPHA  (input) DOUBLE PRECISION
            //         Contains the diagonal element associated with the added row.

            //  BETA   (input) DOUBLE PRECISION
            //         Contains the off-diagonal element associated with the added
            //         row.

            //  DSIGMA (output) DOUBLE PRECISION array, dimension ( N )
            //         Contains a copy of the diagonal elements (K-1 singular values
            //         and one zero) in the secular equation.

            //  IDX    (workspace) INTEGER array, dimension ( N )
            //         This will contain the permutation used to sort the contents of
            //         D into ascending order.

            //  IDXP   (workspace) INTEGER array, dimension ( N )
            //         This will contain the permutation used to place deflated
            //         values of D at the end of the array. On output IDXP(2:K)
            //         points to the nondeflated D-values and IDXP(K+1:N)
            //         points to the deflated singular values.

            //  IDXQ   (input) INTEGER array, dimension ( N )
            //         This contains the permutation which separately sorts the two
            //         sub-problems in D into ascending order.  Note that entries in
            //         the first half of this permutation must first be moved one
            //         position backward; and entries in the second half
            //         must first have NL+1 added to their values.

            //  PERM   (output) INTEGER array, dimension ( N )
            //         The permutations (from deflation and sorting) to be applied
            //         to each singular block. Not referenced if ICOMPQ = 0.0

            //  GIVPTR (output) INTEGER
            //         The number of Givens rotations which took place in this
            //         subproblem. Not referenced if ICOMPQ = 0.0

            //  GIVCOL (output) INTEGER array, dimension ( LDGCOL, 2 )
            //         Each pair of numbers indicates a pair of columns to take place
            //         in a Givens rotation. Not referenced if ICOMPQ = 0.0

            //  LDGCOL (input) INTEGER
            //         The leading dimension of GIVCOL, must be at least N.

            //  GIVNUM (output) DOUBLE PRECISION array, dimension ( LDGNUM, 2 )
            //         Each number indicates the C or S value to be used in the
            //         corresponding Givens rotation. Not referenced if ICOMPQ = 0.0

            //  LDGNUM (input) INTEGER
            //         The leading dimension of GIVNUM, must be at least N.

            //  C      (output) DOUBLE PRECISION
            //         C contains garbage if SQRE =0 and the C-value of a Givens
            //         rotation related to the right null space if SQRE = 1.0

            //  S      (output) DOUBLE PRECISION
            //         S contains garbage if SQRE =0 and the S-value of a Givens
            //         rotation related to the right null space if SQRE = 1.0

            //  INFO   (output) INTEGER
            //         = 0:  successful exit.
            //         < 0:  if INFO = -i, the i-th argument had an illegal value.

            //  Further Details
            //  ===============

            //  Based on contributions by
            //     Ming Gu and Huan Ren, Computer Science Division, University of
            //     California at Berkeley, USA

            //  =====================================================================

            // System generated locals
            int givcol_dim1, givcol_offset, givnum_dim1, givnum_offset, i__1;
            double d__1, d__2;

            // Table of constant values
            int c__1 = 1;

            // Local variables
            int i, j, m, n, k2;
            double z1;
            int jp;
            double eps, tau, tol;
            int nlp1, nlp2, idxi, idxj;
            int idxjp;
            int jprev = 0;
            double hlftol;

            // Parameter adjustments
            --d;
            --z;
            --zw;
            --vf;
            --vfw;
            --vl;
            --vlw;
            --dsigma;
            --idx;
            --idxp;
            --idxq;
            --perm;
            givcol_dim1 = *ldgcol;
            givcol_offset = 1 + givcol_dim1;
            givcol -= givcol_offset;
            givnum_dim1 = *ldgnum;
            givnum_offset = 1 + givnum_dim1;
            givnum -= givnum_offset;

            // Function Body
            *info = 0;
            n = *nl + *nr + 1;
            m = n + *sqre;

            if (*icompq < 0 || *icompq > 1)
            {
                *info = -1;
            }
            else if (*nl < 1)
            {
                *info = -2;
            }
            else if (*nr < 1)
            {
                *info = -3;
            }
            else if (*sqre < 0 || *sqre > 1)
            {
                *info = -4;
            }
            else if (*ldgcol < n)
            {
                *info = -22;
            }
            else if (*ldgnum < n)
            {
                *info = -24;
            }

            if (*info != 0)
            {
                i__1 = -(*info);
                xerbla("DLASD7", &i__1);
                return 0;
            }

            nlp1 = *nl + 1;
            nlp2 = *nl + 2;
            if (*icompq == 1)
            {
                *givptr = 0;
            }

            // Generate the first part of the vector Z and move the singular
            // values in the first part of D one position backward.

            z1 = *alpha * vl[nlp1];
            vl[nlp1] = 0.0;
            tau = vf[nlp1];
            for (i = *nl; i >= 1; --i)
            {
                z[i + 1] = *alpha * vl[i];
                vl[i] = 0.0;
                vf[i + 1] = vf[i];
                d[i + 1] = d[i];
                idxq[i + 1] = idxq[i] + 1;
            }
            vf[1] = tau;

            // Generate the second part of the vector Z.

            i__1 = m;
            for (i = nlp2; i <= i__1; ++i)
            {
                z[i] = *beta * vf[i];
                vf[i] = 0.0;
            }

            // Sort the singular values into increasing order

            i__1 = n;
            for (i = nlp2; i <= i__1; ++i)
            {
                idxq[i] += nlp1;
            }

            // DSIGMA, IDXC, IDXC, and ZW are used as storage space.

            i__1 = n;
            for (i = 2; i <= i__1; ++i)
            {
                dsigma[i] = d[idxq[i]];
                zw[i] = z[idxq[i]];
                vfw[i] = vf[idxq[i]];
                vlw[i] = vl[idxq[i]];
            }

            dlamrg(nl, nr, &dsigma[2], &c__1, &c__1, &idx[2]);

            i__1 = n;
            for (i = 2; i <= i__1; ++i)
            {
                idxi = idx[i] + 1;
                d[i] = dsigma[idxi];
                z[i] = zw[idxi];
                vf[i] = vfw[idxi];
                vl[i] = vlw[idxi];
            }

            // Calculate the allowable deflation tolerence

            eps = dlamch("Epsilon");
            // Computing MAX
            d__1 = Math.Abs(*alpha);
            d__2 = Math.Abs(*beta);
            tol = Math.Max(d__1, d__2);
            // Computing MAX
            d__2 = Math.Abs(d[n]);
            tol = eps * 64.0 * Math.Max(d__2, tol);

            // There are 2 kinds of deflation -- first a value in the z-vector
            // is small, second two (or more) singular values are very close
            // together (their difference is small).

            // If the value in the z-vector is small, we simply permute the
            // array so that the corresponding singular value is moved to the
            // end.

            // If two values in the D-vector are close, we perform a two-sided
            // rotation designed to make one of the corresponding z-vector
            // entries zero, and then permute the array so that the deflated
            // singular value is moved to the end.

            // If there are multiple singular values then the problem deflates.
            // Here the number of equal singular values are found.  As each equal
            // singular value is found, an elementary reflector is computed to
            // rotate the corresponding singular subspace so that the
            // corresponding components of Z are zero in this new basis.

            *k = 1;
            k2 = n + 1;
            i__1 = n;
            for (j = 2; j <= i__1; ++j)
            {
                if (Math.Abs(z[j]) <= tol)
                {
                    // Deflate due to small z component.

                    --k2;
                    idxp[k2] = j;
                    if (j == n)
                    {
                        goto L100;
                    }
                }
                else
                {
                    jprev = j;
                    goto L70;
                }
            }

        L70:
            j = jprev;

        L80:
            ++j;
            if (j > n)
            {
                goto L90;
            }
            if (Math.Abs(z[j]) <= tol)
            {
                // Deflate due to small z component.

                --k2;
                idxp[k2] = j;
            }
            else
            {
                // Check if singular values are close enough to allow deflation.

                if (Math.Abs(d[j] - d[jprev]) <= tol)
                {
                    // Deflation is possible.

                    *s = z[jprev];
                    *c = z[j];

                    // Find sqrt(a**2+b**2) without overflow or
                    // destructive underflow.

                    tau = dlapy2(c, s);
                    z[j] = tau;
                    z[jprev] = 0.0;
                    *c /= tau;
                    *s = -(*s) / tau;

                    // Record the appropriate Givens rotation

                    if (*icompq == 1)
                    {
                        ++(*givptr);
                        idxjp = idxq[idx[jprev] + 1];
                        idxj = idxq[idx[j] + 1];
                        if (idxjp <= nlp1)
                        {
                            --idxjp;
                        }
                        if (idxj <= nlp1)
                        {
                            --idxj;
                        }

                        givcol[*givptr + (givcol_dim1 << 1)] = idxjp;
                        givcol[*givptr + givcol_dim1] = idxj;
                        givnum[*givptr + (givnum_dim1 << 1)] = *c;
                        givnum[*givptr + givnum_dim1] = *s;
                    }

                    drot(&c__1, &vf[jprev], &c__1, &vf[j], &c__1, c, s);
                    drot(&c__1, &vl[jprev], &c__1, &vl[j], &c__1, c, s);
                    --k2;
                    idxp[k2] = jprev;
                    jprev = j;
                }
                else
                {
                    ++(*k);
                    zw[*k] = z[jprev];
                    dsigma[*k] = d[jprev];
                    idxp[*k] = jprev;
                    jprev = j;
                }
            }
            goto L80;
        L90:

            // Record the last singular value.

            ++(*k);
            zw[*k] = z[jprev];
            dsigma[*k] = d[jprev];
            idxp[*k] = jprev;

        L100:

            // Sort the singular values into DSIGMA. The singular values which
            // were not deflated go into the first K slots of DSIGMA, except
            // that DSIGMA(1) is treated separately.

            i__1 = n;
            for (j = 2; j <= i__1; ++j)
            {
                jp = idxp[j];
                dsigma[j] = d[jp];
                vfw[j] = vf[jp];
                vlw[j] = vl[jp];
            }
            if (*icompq == 1)
            {
                i__1 = n;
                for (j = 2; j <= i__1; ++j)
                {
                    jp = idxp[j];
                    perm[j] = idxq[idx[jp] + 1];
                    if (perm[j] <= nlp1)
                    {
                        --perm[j];
                    }
                }
            }

            // The deflated singular values go back into the last N - K slots of
            // D.

            i__1 = n - *k;
            dcopy(&i__1, &dsigma[*k + 1], &c__1, &d[*k + 1], &c__1);

            // Determine DSIGMA(1), DSIGMA(2), Z(1), VF(1), VL(1), VF(M), and
            // VL(M).

            dsigma[1] = 0.0;
            hlftol = tol / 2.0;
            if (Math.Abs(dsigma[2]) <= hlftol)
            {
                dsigma[2] = hlftol;
            }
            if (m > n)
            {
                z[1] = dlapy2(&z1, &z[m]);
                if (z[1] <= tol)
                {
                    *c = 1.0;
                    *s = 0.0;
                    z[1] = tol;
                }
                else
                {
                    *c = z1 / z[1];
                    *s = -z[m] / z[1];
                }
                drot(&c__1, &vf[m], &c__1, &vf[1], &c__1, c, s);
                drot(&c__1, &vl[m], &c__1, &vl[1], &c__1, c, s);
            }
            else
            {
                if (Math.Abs(z1) <= tol)
                {
                    z[1] = tol;
                }
                else
                {
                    z[1] = z1;
                }
            }

            // Restore Z, VF, and VL.

            i__1 = *k - 1;
            dcopy(&i__1, &zw[2], &c__1, &z[2], &c__1);
            i__1 = n - 1;
            dcopy(&i__1, &vfw[2], &c__1, &vf[2], &c__1);
            i__1 = n - 1;
            dcopy(&i__1, &vlw[2], &c__1, &vl[2], &c__1);

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int dlasd8(int* icompq, int* k, double* d, double* z, double* vf, double* vl,
            double* difl, double* difr, int* lddifr, double* dsigma, double* work, int* info)
        {
            //  -- LAPACK auxiliary routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     October 2006

            //  Purpose
            //  =======

            //  DLASD8 finds the square roots of the roots of the secular equation,
            //  as defined by the values in DSIGMA and Z. It makes the appropriate
            //  calls to DLASD4, and stores, for each  element in D, the distance
            //  to its two nearest poles (elements in DSIGMA). It also updates
            //  the arrays VF and VL, the first and last components of all the
            //  right singular vectors of the original bidiagonal matrix.

            //  DLASD8 is called from DLASD6.0

            //  Arguments
            //  =========

            //  ICOMPQ  (input) INTEGER
            //          Specifies whether singular vectors are to be computed in
            //          factored form in the calling routine:
            //          = 0: Compute singular values only.
            //          = 1: Compute singular vectors in factored form as well.

            //  K       (input) INTEGER
            //          The number of terms in the rational function to be solved
            //          by DLASD4.0  K >= 1.0

            //  D       (output) DOUBLE PRECISION array, dimension ( K )
            //          On output, D contains the updated singular values.

            //  Z       (input/output) DOUBLE PRECISION array, dimension ( K )
            //          On entry, the first K elements of this array contain the
            //          components of the deflation-adjusted updating row vector.
            //          On exit, Z is updated.

            //  VF      (input/output) DOUBLE PRECISION array, dimension ( K )
            //          On entry, VF contains  information passed through DBEDE8.0
            //          On exit, VF contains the first K components of the first
            //          components of all right singular vectors of the bidiagonal
            //          matrix.

            //  VL      (input/output) DOUBLE PRECISION array, dimension ( K )
            //          On entry, VL contains  information passed through DBEDE8.0
            //          On exit, VL contains the first K components of the last
            //          components of all right singular vectors of the bidiagonal
            //          matrix.

            //  DIFL    (output) DOUBLE PRECISION array, dimension ( K )
            //          On exit, DIFL(I) = D(I) - DSIGMA(I).

            //  DIFR    (output) DOUBLE PRECISION array,
            //                   dimension ( LDDIFR, 2 ) if ICOMPQ = 1 and
            //                   dimension ( K ) if ICOMPQ = 0.0
            //          On exit, DIFR(I,1) = D(I) - DSIGMA(I+1), DIFR(K,1) is not
            //          defined and will not be referenced.

            //          If ICOMPQ = 1, DIFR(1:K,2) is an array containing the
            //          normalizing factors for the right singular vector matrix.

            //  LDDIFR  (input) INTEGER
            //          The leading dimension of DIFR, must be at least K.

            //  DSIGMA  (input/output) DOUBLE PRECISION array, dimension ( K )
            //          On entry, the first K elements of this array contain the old
            //          roots of the deflated updating problem.  These are the poles
            //          of the secular equation.
            //          On exit, the elements of DSIGMA may be very slightly altered
            //          in value.

            //  WORK    (workspace) DOUBLE PRECISION array, dimension at least 3 * K

            //  INFO    (output) INTEGER
            //          = 0:  successful exit.
            //          < 0:  if INFO = -i, the i-th argument had an illegal value.
            //          > 0:  if INFO = 1, an singular value did not converge

            //  Further Details
            //  ===============

            //  Based on contributions by
            //     Ming Gu and Huan Ren, Computer Science Division, University of
            //     California at Berkeley, USA

            //  =====================================================================

            // System generated locals
            int difr_dim1, difr_offset, i__1, i__2;
            double d__2;

            // Table of constant values
            int c__1 = 1;
            int c__0 = 0;
            double c_b8 = 1.0;

            // Local variables
            int i, j;
            double dj, rho;
            int iwk1, iwk2, iwk3;
            double temp;
            int iwk2i, iwk3i;
            double diflj, difrj = 0, dsigj;
            double dsigjp;

            // Parameter adjustments
            --d;
            --z;
            --vf;
            --vl;
            --difl;
            difr_dim1 = *lddifr;
            difr_offset = 1 + difr_dim1;
            difr -= difr_offset;
            --dsigma;
            --work;

            // Function Body
            *info = 0;

            if (*icompq < 0 || *icompq > 1)
            {
                *info = -1;
            }
            else if (*k < 1)
            {
                *info = -2;
            }
            else if (*lddifr < *k)
            {
                *info = -9;
            }

            if (*info != 0)
            {
                i__1 = -(*info);
                xerbla("DLASD8", &i__1);
                return 0;
            }

            // Quick return if possible

            if (*k == 1)
            {
                d[1] = Math.Abs(z[1]);
                difl[1] = d[1];
                if (*icompq == 1)
                {
                    difl[2] = 1.0;
                    difr[(difr_dim1 << 1) + 1] = 1.0;
                }
                return 0;
            }

            //     Modify values DSIGMA(i) to make sure all DSIGMA(i)-DSIGMA(j) can
            //     be computed with high relative accuracy (barring over/underflow).
            //     This is a problem on machines without a guard digit in
            //     add/subtract (Cray XMP, Cray YMP, Cray C 90 and Cray 2).
            //     The following code replaces DSIGMA(I) by 2*DSIGMA(I)-DSIGMA(I),
            //     which on any of these machines zeros out the bottommost
            //     bit of DSIGMA(I) if it is 1; this makes the subsequent
            //     subtractions DSIGMA(I)-DSIGMA(J) unproblematic when cancellation
            //     occurs. On binary machines with a guard digit (almost all
            //     machines) it does not change DSIGMA(I) at all. On hexadecimal
            //     and decimal machines with a guard digit, it slightly
            //     changes the bottommost bits of DSIGMA(I). It does not account
            //     for hexadecimal or decimal machines without guard digits
            //     (we know of none). We use a subroutine call to compute
            //     2*DLAMBDA(I) to prevent optimizing compilers from eliminating
            //     this code.

            i__1 = *k;
            for (i = 1; i <= i__1; ++i)
            {
                dsigma[i] = dlamc3(&dsigma[i], &dsigma[i]) - dsigma[i];
            }

            // Book keeping.

            iwk1 = 1;
            iwk2 = iwk1 + *k;
            iwk3 = iwk2 + *k;
            iwk2i = iwk2 - 1;
            iwk3i = iwk3 - 1;

            // Normalize Z.

            rho = dnrm2(k, &z[1], &c__1);
            dlascl("G", &c__0, &c__0, &rho, &c_b8, k, &c__1, &z[1], k, info);
            rho *= rho;

            // Initialize WORK(IWK3).

            dlaset("A", k, &c__1, &c_b8, &c_b8, &work[iwk3], k);

            // Compute the updated singular values, the arrays DIFL, DIFR,
            // and the updated Z.

            i__1 = *k;
            for (j = 1; j <= i__1; ++j)
            {
                dlasd4(k, &j, &dsigma[1], &z[1], &work[iwk1], &rho, &d[j], &work[iwk2], info);

                // If the root finder fails, the computation is terminated.

                if (*info != 0)
                {
                    return 0;
                }

                work[iwk3i + j] = work[iwk3i + j] * work[j] * work[iwk2i + j];
                difl[j] = -work[j];
                difr[j + difr_dim1] = -work[j + 1];

                i__2 = j - 1;
                for (i = 1; i <= i__2; ++i)
                {
                    work[iwk3i + i] = work[iwk3i + i] * work[i] * work[iwk2i + i] /
                        (dsigma[i] - dsigma[j]) / (dsigma[i] + dsigma[j]);
                }

                i__2 = *k;
                for (i = j + 1; i <= i__2; ++i)
                {
                    work[iwk3i + i] = work[iwk3i + i] * work[i] * work[iwk2i + i] /
                        (dsigma[i] - dsigma[j]) / (dsigma[i] + dsigma[j]);
                }
            }

            // Compute updated Z.

            i__1 = *k;
            for (i = 1; i <= i__1; ++i)
            {
                d__2 = Math.Sqrt(Math.Abs(work[iwk3i + i]));
                z[i] = d_sign(&d__2, &z[i]);
            }

            // Update VF and VL.

            i__1 = *k;
            for (j = 1; j <= i__1; ++j)
            {
                diflj = difl[j];
                dj = d[j];
                dsigj = -dsigma[j];

                if (j < *k)
                {
                    difrj = -difr[j + difr_dim1];
                    dsigjp = -dsigma[j + 1];
                }

                work[j] = -z[j] / diflj / (dsigma[j] + dj);

                i__2 = j - 1;
                for (i = 1; i <= i__2; ++i)
                {
                    work[i] = z[i] / (dlamc3(&dsigma[i], &dsigj) - diflj) / (
                        dsigma[i] + dj);
                }

                i__2 = *k;
                for (i = j + 1; i <= i__2; ++i)
                {
                    work[i] = z[i] / (dlamc3(&dsigma[i], &dsigjp) + difrj) /
                        (dsigma[i] + dj);
                }

                temp = dnrm2(k, &work[1], &c__1);
                work[iwk2i + j] = ddot(k, &work[1], &c__1, &vf[1], &c__1) / temp;
                work[iwk3i + j] = ddot(k, &work[1], &c__1, &vl[1], &c__1) / temp;

                if (*icompq == 1)
                {
                    difr[j + (difr_dim1 << 1)] = temp;
                }
            }

            dcopy(k, &work[iwk2], &c__1, &vf[1], &c__1);
            dcopy(k, &work[iwk3], &c__1, &vl[1], &c__1);

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int dlasda(int* icompq, int* smlsiz, int* n, int* sqre, double* d, double* e,
            double* u, int* ldu, double* vt, int* k, double* difl, double* difr, double* z, double* poles,
            int* givptr, int* givcol, int* ldgcol, int* perm, double* givnum, double* c,
            double* s, double* work, int* iwork, int* info)
        {
            //  -- LAPACK auxiliary routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     November 2006

            //  Purpose
            //  =======

            //  Using a divide and conquer approach, DLASDA computes the singular
            //  value decomposition (SVD) of a float upper bidiagonal N-by-M matrix
            //  B with diagonal D and offdiagonal E, where M = N + SQRE. The
            //  algorithm computes the singular values in the SVD B = U * S * VT.
            //  The orthogonal matrices U and VT are optionally computed in
            //  compact form.

            //  A related subroutine, DLASD0, computes the singular values and
            //  the singular vectors in explicit form.

            //  Arguments
            //  =========

            //  ICOMPQ (input) INTEGER
            //         Specifies whether singular vectors are to be computed
            //         in compact form, as follows
            //         = 0: Compute singular values only.
            //         = 1: Compute singular vectors of upper bidiagonal
            //              matrix in compact form.

            //  SMLSIZ (input) INTEGER
            //         The maximum size of the subproblems at the bottom of the
            //         computation tree.

            //  N      (input) INTEGER
            //         The row dimension of the upper bidiagonal matrix. This is
            //         also the dimension of the main diagonal array D.

            //  SQRE   (input) INTEGER
            //         Specifies the column dimension of the bidiagonal matrix.
            //         = 0: The bidiagonal matrix has column dimension M = N;
            //         = 1: The bidiagonal matrix has column dimension M = N + 1.0

            //  D      (input/output) DOUBLE PRECISION array, dimension ( N )
            //         On entry D contains the main diagonal of the bidiagonal
            //         matrix. On exit D, if INFO = 0, contains its singular values.

            //  E      (input) DOUBLE PRECISION array, dimension ( M-1 )
            //         Contains the subdiagonal entries of the bidiagonal matrix.
            //         On exit, E has been destroyed.

            //  U      (output) DOUBLE PRECISION array,
            //         dimension ( LDU, SMLSIZ ) if ICOMPQ = 1, and not referenced
            //         if ICOMPQ = 0.0 If ICOMPQ = 1, on exit, U contains the left
            //         singular vector matrices of all subproblems at the bottom
            //         level.

            //  LDU    (input) INTEGER, LDU = > N.
            //         The leading dimension of arrays U, VT, DIFL, DIFR, POLES,
            //         GIVNUM, and Z.

            //  VT     (output) DOUBLE PRECISION array,
            //         dimension ( LDU, SMLSIZ+1 ) if ICOMPQ = 1, and not referenced
            //         if ICOMPQ = 0.0 If ICOMPQ = 1, on exit, VT' contains the right
            //         singular vector matrices of all subproblems at the bottom
            //         level.

            //  K      (output) INTEGER array,
            //         dimension ( N ) if ICOMPQ = 1 and dimension 1 if ICOMPQ = 0.0
            //         If ICOMPQ = 1, on exit, K(I) is the dimension of the I-th
            //         secular equation on the computation tree.

            //  DIFL   (output) DOUBLE PRECISION array, dimension ( LDU, NLVL ),
            //         where NLVL = floor(log_2 (N/SMLSIZ))).

            //  DIFR   (output) DOUBLE PRECISION array,
            //                  dimension ( LDU, 2 * NLVL ) if ICOMPQ = 1 and
            //                  dimension ( N ) if ICOMPQ = 0.0
            //         If ICOMPQ = 1, on exit, DIFL(1:N, I) and DIFR(1:N, 2 * I - 1)
            //         record distances between singular values on the I-th
            //         level and singular values on the (I -1)-th level, and
            //         DIFR(1:N, 2 * I ) contains the normalizing factors for
            //         the right singular vector matrix. See DLASD8 for details.

            //  Z      (output) DOUBLE PRECISION array,
            //                  dimension ( LDU, NLVL ) if ICOMPQ = 1 and
            //                  dimension ( N ) if ICOMPQ = 0.0
            //         The first K elements of Z(1, I) contain the components of
            //         the deflation-adjusted updating row vector for subproblems
            //         on the I-th level.

            //  POLES  (output) DOUBLE PRECISION array,
            //         dimension ( LDU, 2 * NLVL ) if ICOMPQ = 1, and not referenced
            //         if ICOMPQ = 0.0 If ICOMPQ = 1, on exit, POLES(1, 2*I - 1) and
            //         POLES(1, 2*I) contain  the new and old singular values
            //         involved in the secular equations on the I-th level.

            //  GIVPTR (output) INTEGER array,
            //         dimension ( N ) if ICOMPQ = 1, and not referenced if
            //         ICOMPQ = 0.0 If ICOMPQ = 1, on exit, GIVPTR( I ) records
            //         the number of Givens rotations performed on the I-th
            //         problem on the computation tree.

            //  GIVCOL (output) INTEGER array,
            //         dimension ( LDGCOL, 2 * NLVL ) if ICOMPQ = 1, and not
            //         referenced if ICOMPQ = 0.0 If ICOMPQ = 1, on exit, for each I,
            //         GIVCOL(1, 2 *I - 1) and GIVCOL(1, 2 *I) record the locations
            //         of Givens rotations performed on the I-th level on the
            //         computation tree.

            //  LDGCOL (input) INTEGER, LDGCOL = > N.
            //         The leading dimension of arrays GIVCOL and PERM.

            //  PERM   (output) INTEGER array,
            //         dimension ( LDGCOL, NLVL ) if ICOMPQ = 1, and not referenced
            //         if ICOMPQ = 0.0 If ICOMPQ = 1, on exit, PERM(1, I) records
            //         permutations done on the I-th level of the computation tree.

            //  GIVNUM (output) DOUBLE PRECISION array,
            //         dimension ( LDU,  2 * NLVL ) if ICOMPQ = 1, and not
            //         referenced if ICOMPQ = 0.0 If ICOMPQ = 1, on exit, for each I,
            //         GIVNUM(1, 2 *I - 1) and GIVNUM(1, 2 *I) record the C- and S-
            //         values of Givens rotations performed on the I-th level on
            //         the computation tree.

            //  C      (output) DOUBLE PRECISION array,
            //         dimension ( N ) if ICOMPQ = 1, and dimension 1 if ICOMPQ = 0.0
            //         If ICOMPQ = 1 and the I-th subproblem is not square, on exit,
            //         C( I ) contains the C-value of a Givens rotation related to
            //         the right null space of the I-th subproblem.

            //  S      (output) DOUBLE PRECISION array, dimension ( N ) if
            //         ICOMPQ = 1, and dimension 1 if ICOMPQ = 0.0 If ICOMPQ = 1
            //         and the I-th subproblem is not square, on exit, S( I )
            //         contains the S-value of a Givens rotation related to
            //         the right null space of the I-th subproblem.

            //  WORK   (workspace) DOUBLE PRECISION array, dimension
            //         (6 * N + (SMLSIZ + 1)*(SMLSIZ + 1)).

            //  IWORK  (workspace) INTEGER array.
            //         Dimension must be at least (7 * N).

            //  INFO   (output) INTEGER
            //          = 0:  successful exit.
            //          < 0:  if INFO = -i, the i-th argument had an illegal value.
            //          > 0:  if INFO = 1, an singular value did not converge

            //  Further Details
            //  ===============

            //  Based on contributions by
            //     Ming Gu and Huan Ren, Computer Science Division, University of
            //     California at Berkeley, USA

            //  =====================================================================

            // System generated locals
            int givcol_dim1, givcol_offset, perm_dim1, perm_offset, difl_dim1,
                difl_offset, difr_dim1, difr_offset, givnum_dim1, givnum_offset,
                poles_dim1, poles_offset, u_dim1, u_offset, vt_dim1, vt_offset,
                z_dim1, z_offset, i__1, i__2;

            // Table of constant values
            int c__0 = 0;
            double c_b11 = 0.0;
            double c_b12 = 1.0;
            int c__1 = 1;
            int c__2 = 2;

            // Local variables
            int i, j, m, i1, ic, lf, nd, ll, nl, vf, nr, vl, im1, ncc, nlf, nrf,
                 vfi, iwk, vli, lvl, nru, ndb1, nlp1, lvl2, nrp1;
            double beta;
            int idxq, nlvl;
            double alpha;
            int inode, ndiml, ndimr, idxqi, itemp;
            int sqrei;
            int nwork1, nwork2;
            int smlszp;

            // Parameter adjustments
            --d;
            --e;
            givnum_dim1 = *ldu;
            givnum_offset = 1 + givnum_dim1;
            givnum -= givnum_offset;
            poles_dim1 = *ldu;
            poles_offset = 1 + poles_dim1;
            poles -= poles_offset;
            z_dim1 = *ldu;
            z_offset = 1 + z_dim1;
            z -= z_offset;
            difr_dim1 = *ldu;
            difr_offset = 1 + difr_dim1;
            difr -= difr_offset;
            difl_dim1 = *ldu;
            difl_offset = 1 + difl_dim1;
            difl -= difl_offset;
            vt_dim1 = *ldu;
            vt_offset = 1 + vt_dim1;
            vt -= vt_offset;
            u_dim1 = *ldu;
            u_offset = 1 + u_dim1;
            u -= u_offset;
            --k;
            --givptr;
            perm_dim1 = *ldgcol;
            perm_offset = 1 + perm_dim1;
            perm -= perm_offset;
            givcol_dim1 = *ldgcol;
            givcol_offset = 1 + givcol_dim1;
            givcol -= givcol_offset;
            --c;
            --s;
            --work;
            --iwork;

            // Function Body
            *info = 0;

            if (*icompq < 0 || *icompq > 1)
            {
                *info = -1;
            }
            else if (*smlsiz < 3)
            {
                *info = -2;
            }
            else if (*n < 0)
            {
                *info = -3;
            }
            else if (*sqre < 0 || *sqre > 1)
            {
                *info = -4;
            }
            else if (*ldu < *n + *sqre)
            {
                *info = -8;
            }
            else if (*ldgcol < *n)
            {
                *info = -17;
            }

            if (*info != 0)
            {
                i__1 = -(*info);
                xerbla("DLASDA", &i__1);
                return 0;
            }

            m = *n + *sqre;

            // If the input matrix is too small, call DLASDQ to find the SVD.

            if (*n <= *smlsiz)
            {
                if (*icompq == 0)
                {
                    dlasdq("U", sqre, n, &c__0, &c__0, &c__0, &d[1], &e[1], &vt[vt_offset],
                        ldu, &u[u_offset], ldu, &u[u_offset], ldu, &work[1], info);
                }
                else
                {
                    dlasdq("U", sqre, n, &m, n, &c__0, &d[1], &e[1], &vt[vt_offset],
                        ldu, &u[u_offset], ldu, &u[u_offset], ldu, &work[1], info);
                }
                return 0;
            }

            // Book-keeping and  set up the computation tree.

            inode = 1;
            ndiml = inode + *n;
            ndimr = ndiml + *n;
            idxq = ndimr + *n;
            iwk = idxq + *n;

            ncc = 0;
            nru = 0;

            smlszp = *smlsiz + 1;
            vf = 1;
            vl = vf + m;
            nwork1 = vl + m;
            nwork2 = nwork1 + smlszp * smlszp;

            dlasdt(n, &nlvl, &nd, &iwork[inode], &iwork[ndiml], &iwork[ndimr], smlsiz);

            // for the nodes on bottom level of the tree, solve
            // their subproblems by DLASDQ.

            ndb1 = (nd + 1) / 2;
            i__1 = nd;
            for (i = ndb1; i <= i__1; ++i)
            {
                // IC : center row of each node
                // NL : number of rows of left  subproblem
                // NR : number of rows of right subproblem
                // NLF: starting row of the left   subproblem
                // NRF: starting row of the right  subproblem

                i1 = i - 1;
                ic = iwork[inode + i1];
                nl = iwork[ndiml + i1];
                nlp1 = nl + 1;
                nr = iwork[ndimr + i1];
                nlf = ic - nl;
                nrf = ic + 1;
                idxqi = idxq + nlf - 2;
                vfi = vf + nlf - 1;
                vli = vl + nlf - 1;
                sqrei = 1;

                if (*icompq == 0)
                {
                    dlaset("A", &nlp1, &nlp1, &c_b11, &c_b12, &work[nwork1], &smlszp);
                    dlasdq("U", &sqrei, &nl, &nlp1, &nru, &ncc, &d[nlf], &e[nlf], &work[nwork1],
                        &smlszp, &work[nwork2], &nl, &work[nwork2], &nl, &work[nwork2], info);
                    itemp = nwork1 + nl * smlszp;
                    dcopy(&nlp1, &work[nwork1], &c__1, &work[vfi], &c__1);
                    dcopy(&nlp1, &work[itemp], &c__1, &work[vli], &c__1);
                }
                else
                {
                    dlaset("A", &nl, &nl, &c_b11, &c_b12, &u[nlf + u_dim1], ldu);
                    dlaset("A", &nlp1, &nlp1, &c_b11, &c_b12, &vt[nlf + vt_dim1], ldu);
                    dlasdq("U", &sqrei, &nl, &nlp1, &nl, &ncc, &d[nlf], &e[nlf], &vt[nlf + vt_dim1],
                        ldu, &u[nlf + u_dim1], ldu, &u[nlf + u_dim1], ldu, &work[nwork1], info);
                    dcopy(&nlp1, &vt[nlf + vt_dim1], &c__1, &work[vfi], &c__1);
                    dcopy(&nlp1, &vt[nlf + nlp1 * vt_dim1], &c__1, &work[vli], &c__1);
                }

                if (*info != 0)
                {
                    return 0;
                }

                i__2 = nl;
                for (j = 1; j <= i__2; ++j)
                {
                    iwork[idxqi + j] = j;
                }
                if (i == nd && *sqre == 0)
                {
                    sqrei = 0;
                }
                else
                {
                    sqrei = 1;
                }
                idxqi += nlp1;
                vfi += nlp1;
                vli += nlp1;
                nrp1 = nr + sqrei;
                if (*icompq == 0)
                {
                    dlaset("A", &nrp1, &nrp1, &c_b11, &c_b12, &work[nwork1], &smlszp);
                    dlasdq("U", &sqrei, &nr, &nrp1, &nru, &ncc, &d[nrf], &e[nrf], &work[nwork1],
                        &smlszp, &work[nwork2], &nr, &work[nwork2], &nr, &work[nwork2], info);
                    itemp = nwork1 + (nrp1 - 1) * smlszp;
                    dcopy(&nrp1, &work[nwork1], &c__1, &work[vfi], &c__1);
                    dcopy(&nrp1, &work[itemp], &c__1, &work[vli], &c__1);
                }
                else
                {
                    dlaset("A", &nr, &nr, &c_b11, &c_b12, &u[nrf + u_dim1], ldu);
                    dlaset("A", &nrp1, &nrp1, &c_b11, &c_b12, &vt[nrf + vt_dim1], ldu);
                    dlasdq("U", &sqrei, &nr, &nrp1, &nr, &ncc, &d[nrf], &e[nrf], &vt[nrf + vt_dim1],
                        ldu, &u[nrf + u_dim1], ldu, &u[nrf + u_dim1], ldu, &work[nwork1], info);
                    dcopy(&nrp1, &vt[nrf + vt_dim1], &c__1, &work[vfi], &c__1);
                    dcopy(&nrp1, &vt[nrf + nrp1 * vt_dim1], &c__1, &work[vli], &c__1);
                }

                if (*info != 0)
                {
                    return 0;
                }

                i__2 = nr;
                for (j = 1; j <= i__2; ++j)
                {
                    iwork[idxqi + j] = j;
                }
            }

            // Now conquer each subproblem bottom-up.

            j = pow_ii(&c__2, &nlvl);
            for (lvl = nlvl; lvl >= 1; --lvl)
            {
                lvl2 = (lvl << 1) - 1;

                // Find the first node LF and last node LL on
                // the current level LVL.

                if (lvl == 1)
                {
                    lf = 1;
                    ll = 1;
                }
                else
                {
                    i__1 = lvl - 1;
                    lf = pow_ii(&c__2, &i__1);
                    ll = (lf << 1) - 1;
                }

                i__1 = ll;
                for (i = lf; i <= i__1; ++i)
                {
                    im1 = i - 1;
                    ic = iwork[inode + im1];
                    nl = iwork[ndiml + im1];
                    nr = iwork[ndimr + im1];
                    nlf = ic - nl;
                    nrf = ic + 1;
                    if (i == ll)
                    {
                        sqrei = *sqre;
                    }
                    else
                    {
                        sqrei = 1;
                    }
                    vfi = vf + nlf - 1;
                    vli = vl + nlf - 1;
                    idxqi = idxq + nlf - 1;
                    alpha = d[ic];
                    beta = e[ic];

                    if (*icompq == 0)
                    {
                        dlasd6(icompq, &nl, &nr, &sqrei, &d[nlf], &work[vfi], &work[vli], &alpha, &beta, &iwork[idxqi],
                            &perm[perm_offset], &givptr[1], &givcol[givcol_offset], ldgcol, &givnum[givnum_offset], ldu,
                            &poles[poles_offset], &difl[difl_offset], &difr[difr_offset], &z[z_offset], &k[1], &c[1],
                            &s[1], &work[nwork1], &iwork[iwk], info);
                    }
                    else
                    {
                        --j;
                        dlasd6(icompq, &nl, &nr, &sqrei, &d[nlf], &work[vfi], &work[vli], &alpha, &beta,
                            &iwork[idxqi], &perm[nlf + lvl * perm_dim1], &givptr[j], &givcol[nlf + lvl2 * givcol_dim1],
                            ldgcol, &givnum[nlf + lvl2 * givnum_dim1], ldu, &poles[nlf + lvl2 * poles_dim1],
                            &difl[nlf + lvl * difl_dim1], &difr[nlf + lvl2 * difr_dim1], &z[nlf + lvl * z_dim1], &k[j], &c[j],
                            &s[j], &work[nwork1], &iwork[iwk], info);
                    }

                    if (*info != 0)
                    {
                        return 0;
                    }
                }
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int dlasdt(int* n, int* lvl, int* nd, int* inode, int* ndiml, int* ndimr, int* msub)
        {
            //  -- LAPACK auxiliary routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     November 2006

            //  Purpose
            //  =======

            //  DLASDT creates a tree of subproblems for bidiagonal divide and
            //  conquer.

            //  Arguments
            //  =========

            //   N      (input) INTEGER
            //          On entry, the number of diagonal elements of the
            //          bidiagonal matrix.

            //   LVL    (output) INTEGER
            //          On exit, the number of levels on the computation tree.

            //   ND     (output) INTEGER
            //          On exit, the number of nodes on the tree.

            //   INODE  (output) INTEGER array, dimension ( N )
            //          On exit, centers of subproblems.

            //   NDIML  (output) INTEGER array, dimension ( N )
            //          On exit, row dimensions of left children.

            //   NDIMR  (output) INTEGER array, dimension ( N )
            //          On exit, row dimensions of right children.

            //   MSUB   (input) INTEGER.
            //          On entry, the maximum row dimension each subproblem at the
            //          bottom of the tree can be of.

            //  Further Details
            //  ===============

            //  Based on contributions by
            //     Ming Gu and Huan Ren, Computer Science Division, University of
            //     California at Berkeley, USA

            //  =====================================================================

            // System generated locals
            int i__1, i__2;

            // Local variables
            int i, il, ir, maxn;
            double temp;
            int nlvl, llst, ncrnt;

            // Parameter adjustments
            --ndimr;
            --ndiml;
            --inode;

            // Function Body
            maxn = Math.Max(1, *n);
            temp = Math.Log((double)maxn / (double)(*msub + 1)) / Math.Log(2.0);
            *lvl = (int)temp + 1;

            i = *n / 2;
            inode[1] = i + 1;
            ndiml[1] = i;
            ndimr[1] = *n - i - 1;
            il = 0;
            ir = 1;
            llst = 1;
            i__1 = *lvl - 1;
            for (nlvl = 1; nlvl <= i__1; ++nlvl)
            {
                // Constructing the tree at (NLVL+1)-st level. The number of
                // nodes created on this level is LLST * 2.0

                i__2 = llst - 1;
                for (i = 0; i <= i__2; ++i)
                {
                    il += 2;
                    ir += 2;
                    ncrnt = llst + i;
                    ndiml[il] = ndiml[ncrnt] / 2;
                    ndimr[il] = ndiml[ncrnt] - ndiml[il] - 1;
                    inode[il] = inode[ncrnt] - ndimr[il] - 1;
                    ndiml[ir] = ndimr[ncrnt] / 2;
                    ndimr[ir] = ndimr[ncrnt] - ndiml[ir] - 1;
                    inode[ir] = inode[ncrnt] + ndiml[ir] + 1;
                }
                llst <<= 1;
            }
            *nd = (llst << 1) - 1;

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int dlasdq(string uplo, int* sqre, int* n, int* ncvt, int* nru, int* ncc, double* d,
            double* e, double* vt, int* ldvt, double* u, int* ldu, double* c, int* ldc, double* work, int* info)
        {
            //  -- LAPACK auxiliary routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     November 2006

            //  Purpose
            //  =======

            //  DLASDQ computes the singular value decomposition (SVD) of a float
            //  (upper or lower) bidiagonal matrix with diagonal D and offdiagonal
            //  E, accumulating the transformations if desired. Letting B denote
            //  the input bidiagonal matrix, the algorithm computes orthogonal
            //  matrices Q and P such that B = Q * S * P' (P' denotes the transpose
            //  of P). The singular values S are overwritten on D.

            //  The input matrix U  is changed to U  * Q  if desired.
            //  The input matrix VT is changed to P' * VT if desired.
            //  The input matrix C  is changed to Q' * C  if desired.

            //  See "Computing  Small Singular Values of Bidiagonal Matrices With
            //  Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
            //  LAPACK Working Note #3, for a detailed description of the algorithm.

            //  Arguments
            //  =========

            //  UPLO  (input) CHARACTER*1
            //        On entry, UPLO specifies whether the input bidiagonal matrix
            //        is upper or lower bidiagonal, and wether it is square are
            //        not.
            //           UPLO = 'U' or 'u'   B is upper bidiagonal.
            //           UPLO = 'L' or 'l'   B is lower bidiagonal.

            //  SQRE  (input) INTEGER
            //        = 0: then the input matrix is N-by-N.
            //        = 1: then the input matrix is N-by-(N+1) if UPLU = 'U' and
            //             (N+1)-by-N if UPLU = 'L'.

            //        The bidiagonal matrix has
            //        N = NL + NR + 1 rows and
            //        M = N + SQRE >= N columns.

            //  N     (input) INTEGER
            //        On entry, N specifies the number of rows and columns
            //        in the matrix. N must be at least 0.0

            //  NCVT  (input) INTEGER
            //        On entry, NCVT specifies the number of columns of
            //        the matrix VT. NCVT must be at least 0.0

            //  NRU   (input) INTEGER
            //        On entry, NRU specifies the number of rows of
            //        the matrix U. NRU must be at least 0.0

            //  NCC   (input) INTEGER
            //        On entry, NCC specifies the number of columns of
            //        the matrix C. NCC must be at least 0.0

            //  D     (input/output) DOUBLE PRECISION array, dimension (N)
            //        On entry, D contains the diagonal entries of the
            //        bidiagonal matrix whose SVD is desired. On normal exit,
            //        D contains the singular values in ascending order.

            //  E     (input/output) DOUBLE PRECISION array.
            //        dimension is (N-1) if SQRE = 0 and N if SQRE = 1.0
            //        On entry, the entries of E contain the offdiagonal entries
            //        of the bidiagonal matrix whose SVD is desired. On normal
            //        exit, E will contain 0.0 If the algorithm does not converge,
            //        D and E will contain the diagonal and superdiagonal entries
            //        of a bidiagonal matrix orthogonally equivalent to the one
            //        given as input.

            //  VT    (input/output) DOUBLE PRECISION array, dimension (LDVT, NCVT)
            //        On entry, contains a matrix which on exit has been
            //        premultiplied by P', dimension N-by-NCVT if SQRE = 0
            //        and (N+1)-by-NCVT if SQRE = 1 (not referenced if NCVT=0).

            //  LDVT  (input) INTEGER
            //        On entry, LDVT specifies the leading dimension of VT as
            //        declared in the calling (sub) program. LDVT must be at
            //        least 1.0 If NCVT is nonzero LDVT must also be at least N.

            //  U     (input/output) DOUBLE PRECISION array, dimension (LDU, N)
            //        On entry, contains a  matrix which on exit has been
            //        postmultiplied by Q, dimension NRU-by-N if SQRE = 0
            //        and NRU-by-(N+1) if SQRE = 1 (not referenced if NRU=0).

            //  LDU   (input) INTEGER
            //        On entry, LDU  specifies the leading dimension of U as
            //        declared in the calling (sub) program. LDU must be at
            //        least max( 1, NRU ) .

            //  C     (input/output) DOUBLE PRECISION array, dimension (LDC, NCC)
            //        On entry, contains an N-by-NCC matrix which on exit
            //        has been premultiplied by Q'  dimension N-by-NCC if SQRE = 0
            //        and (N+1)-by-NCC if SQRE = 1 (not referenced if NCC=0).

            //  LDC   (input) INTEGER
            //        On entry, LDC  specifies the leading dimension of C as
            //        declared in the calling (sub) program. LDC must be at
            //        least 1.0 If NCC is nonzero, LDC must also be at least N.

            //  WORK  (workspace) DOUBLE PRECISION array, dimension (4*N)
            //        Workspace. Only referenced if one of NCVT, NRU, or NCC is
            //        nonzero, and if N is at least 2.0

            //  INFO  (output) INTEGER
            //        On exit, a value of 0 indicates a successful exit.
            //        If INFO < 0, argument number -INFO is illegal.
            //        If INFO > 0, the algorithm did not converge, and INFO
            //        specifies how many superdiagonals did not converge.

            //  Further Details
            //  ===============

            //  Based on contributions by
            //     Ming Gu and Huan Ren, Computer Science Division, University of
            //     California at Berkeley, USA

            //  =====================================================================

            // System generated locals
            int c_dim1, c_offset, u_dim1, u_offset, vt_dim1, vt_offset, i__1, i__2;

            // Table of constant values
            int c__1 = 1;

            // Local variables
            int i, j;
            double r, cs, sn;
            int np1, isub;
            double smin;
            int sqre1;
            int iuplo;
            bool rotate;

            // Parameter adjustments
            --d;
            --e;
            vt_dim1 = *ldvt;
            vt_offset = 1 + vt_dim1;
            vt -= vt_offset;
            u_dim1 = *ldu;
            u_offset = 1 + u_dim1;
            u -= u_offset;
            c_dim1 = *ldc;
            c_offset = 1 + c_dim1;
            c -= c_offset;
            --work;

            // Function Body
            *info = 0;
            iuplo = 0;
            if (lsame(uplo, "U"))
            {
                iuplo = 1;
            }
            if (lsame(uplo, "L"))
            {
                iuplo = 2;
            }
            if (iuplo == 0)
            {
                *info = -1;
            }
            else if (*sqre < 0 || *sqre > 1)
            {
                *info = -2;
            }
            else if (*n < 0)
            {
                *info = -3;
            }
            else if (*ncvt < 0)
            {
                *info = -4;
            }
            else if (*nru < 0)
            {
                *info = -5;
            }
            else if (*ncc < 0)
            {
                *info = -6;
            }
            else if (*ncvt == 0 && *ldvt < 1 || *ncvt > 0 && *ldvt < Math.Max(1, *n))
            {
                *info = -10;
            }
            else if (*ldu < Math.Max(1, *nru))
            {
                *info = -12;
            }
            else if (*ncc == 0 && *ldc < 1 || *ncc > 0 && *ldc < Math.Max(1, *n))
            {
                *info = -14;
            }

            if (*info != 0)
            {
                i__1 = -(*info);
                xerbla("DLASDQ", &i__1);
                return 0;
            }

            if (*n == 0)
            {
                return 0;
            }

            // ROTATE is true if any singular vectors desired, false otherwise

            rotate = *ncvt > 0 || *nru > 0 || *ncc > 0;
            np1 = *n + 1;
            sqre1 = *sqre;

            // If matrix non-square upper bidiagonal, rotate to be lower
            // bidiagonal.  The rotations are on the right.

            if (iuplo == 1 && sqre1 == 1)
            {
                i__1 = *n - 1;
                for (i = 1; i <= i__1; ++i)
                {
                    dlartg(&d[i], &e[i], &cs, &sn, &r);
                    d[i] = r;
                    e[i] = sn * d[i + 1];
                    d[i + 1] = cs * d[i + 1];
                    if (rotate)
                    {
                        work[i] = cs;
                        work[*n + i] = sn;
                    }
                }
                dlartg(&d[*n], &e[*n], &cs, &sn, &r);
                d[*n] = r;
                e[*n] = 0.0;
                if (rotate)
                {
                    work[*n] = cs;
                    work[*n + *n] = sn;
                }
                iuplo = 2;
                sqre1 = 0;

                // Update singular vectors if desired.

                if (*ncvt > 0)
                {
                    dlasr("L", "V", "F", &np1, ncvt, &work[1], &work[np1], &vt[vt_offset], ldvt);
                }
            }

            // If matrix lower bidiagonal, rotate to be upper bidiagonal
            // by applying Givens rotations on the left.

            if (iuplo == 2)
            {
                i__1 = *n - 1;
                for (i = 1; i <= i__1; ++i)
                {
                    dlartg(&d[i], &e[i], &cs, &sn, &r);
                    d[i] = r;
                    e[i] = sn * d[i + 1];
                    d[i + 1] = cs * d[i + 1];
                    if (rotate)
                    {
                        work[i] = cs;
                        work[*n + i] = sn;
                    }
                }

                // If matrix (N+1)-by-N lower bidiagonal, one additional
                // rotation is needed.

                if (sqre1 == 1)
                {
                    dlartg(&d[*n], &e[*n], &cs, &sn, &r);
                    d[*n] = r;
                    if (rotate)
                    {
                        work[*n] = cs;
                        work[*n + *n] = sn;
                    }
                }

                // Update singular vectors if desired.

                if (*nru > 0)
                {
                    if (sqre1 == 0)
                    {
                        dlasr("R", "V", "F", nru, n, &work[1], &work[np1], &u[u_offset], ldu);
                    }
                    else
                    {
                        dlasr("R", "V", "F", nru, &np1, &work[1], &work[np1], &u[u_offset], ldu);
                    }
                }
                if (*ncc > 0)
                {
                    if (sqre1 == 0)
                    {
                        dlasr("L", "V", "F", n, ncc, &work[1], &work[np1], &c[c_offset], ldc);
                    }
                    else
                    {
                        dlasr("L", "V", "F", &np1, ncc, &work[1], &work[np1], &c[c_offset], ldc);
                    }
                }
            }

            // Call DBDSQR to compute the SVD of the reduced float
            // N-by-N upper bidiagonal matrix.

            dbdsqr("U", n, ncvt, nru, ncc, &d[1], &e[1], &vt[vt_offset],
                ldvt, &u[u_offset], ldu, &c[c_offset], ldc, &work[1], info);

            // Sort the singular values into ascending order (insertion sort on
            // singular values, but only one transposition per singular vector)

            i__1 = *n;
            for (i = 1; i <= i__1; ++i)
            {
                // Scan for smallest D(I).

                isub = i;
                smin = d[i];
                i__2 = *n;
                for (j = i + 1; j <= i__2; ++j)
                {
                    if (d[j] < smin)
                    {
                        isub = j;
                        smin = d[j];
                    }
                }
                if (isub != i)
                {
                    // Swap singular values and vectors.

                    d[isub] = d[i];
                    d[i] = smin;
                    if (*ncvt > 0)
                    {
                        dswap(ncvt, &vt[isub + vt_dim1], ldvt, &vt[i + vt_dim1],
                            ldvt);
                    }
                    if (*nru > 0)
                    {
                        dswap(nru, &u[isub * u_dim1 + 1], &c__1, &u[i * u_dim1 + 1], &c__1);
                    }
                    if (*ncc > 0)
                    {
                        dswap(ncc, &c[isub + c_dim1], ldc, &c[i + c_dim1], ldc);
                    }
                }
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int dlaset(string uplo, int* m, int* n, double* alpha, double* beta, double* a, int* lda)
        {
            //  -- LAPACK auxiliary routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     November 2006

            //  Purpose
            //  =======

            //  DLASET initializes an m-by-n matrix A to BETA on the diagonal and
            //  ALPHA on the offdiagonals.

            //  Arguments
            //  =========

            //  UPLO    (input) CHARACTER*1
            //          Specifies the part of the matrix A to be set.
            //          = 'U':      Upper triangular part is set; the strictly lower
            //                      triangular part of A is not changed.
            //          = 'L':      Lower triangular part is set; the strictly upper
            //                      triangular part of A is not changed.
            //          Otherwise:  All of the matrix A is set.

            //  M       (input) int
            //          The number of rows of the matrix A.  M >= 0.

            //  N       (input) int
            //          The number of columns of the matrix A.  N >= 0.

            //  ALPHA   (input) DOUBLE PRECISION
            //          The constant to which the offdiagonal elements are to be set.

            //  BETA    (input) DOUBLE PRECISION
            //          The constant to which the diagonal elements are to be set.

            //  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            //          On exit, the leading m-by-n submatrix of A is set as follows:

            //          if UPLO = 'U', A(i,j) = ALPHA, 1<=i<=j-1, 1<=j<=n,
            //          if UPLO = 'L', A(i,j) = ALPHA, j+1<=i<=m, 1<=j<=n,
            //          otherwise,     A(i,j) = ALPHA, 1<=i<=m, 1<=j<=n, i.ne.j,

            //          and, for all UPLO, A(i,i) = BETA, 1<=i<=min(m,n).

            //  LDA     (input) int
            //          The leading dimension of the array A.  LDA >= max(1,M).

            // =====================================================================

            // System generated locals
            int a_dim1, a_offset, i__1, i__2, i__3;

            // Local variables
            int i, j;

            // Parameter adjustments
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;

            // Function Body
            if (lsame(uplo, "U"))
            {
                // Set the strictly upper triangular or trapezoidal part of the
                // array to ALPHA.

                i__1 = *n;
                for (j = 2; j <= i__1; ++j)
                {
                    // Computing MIN
                    i__3 = j - 1;
                    i__2 = Math.Min(i__3, *m);
                    for (i = 1; i <= i__2; ++i)
                    {
                        a[i + j * a_dim1] = *alpha;
                    }
                }
            }
            else if (lsame(uplo, "L"))
            {
                // Set the strictly lower triangular or trapezoidal part of the
                // array to ALPHA.

                i__1 = Math.Min(*m, *n);
                for (j = 1; j <= i__1; ++j)
                {
                    i__2 = *m;
                    for (i = j + 1; i <= i__2; ++i)
                    {
                        a[i + j * a_dim1] = *alpha;
                    }
                }
            }
            else
            {
                // Set the leading m-by-n submatrix to ALPHA.

                i__1 = *n;
                for (j = 1; j <= i__1; ++j)
                {
                    i__2 = *m;
                    for (i = 1; i <= i__2; ++i)
                    {
                        a[i + j * a_dim1] = *alpha;
                    }
                }
            }

            // Set the first min(M,N) diagonal elements to BETA.

            i__1 = Math.Min(*m, *n);
            for (i = 1; i <= i__1; ++i)
            {
                a[i + i * a_dim1] = *beta;
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int dlasq1(int* n, double* d, double* e, double* work, int* info)
        {
            //  -- LAPACK routine (version 3.2)                                    --

            //  -- Contributed by Osni Marques of the Lawrence Berkeley National   --
            //  -- Laboratory and Beresford Parlett of the Univ. of California at  --
            //  -- Berkeley                                                        --
            //  -- November 2008                                                   --

            //  -- LAPACK is a software package provided by Univ. of Tennessee,    --
            //  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--

            //  Purpose
            //  =======

            //  DLASQ1 computes the singular values of a float N-by-N bidiagonal
            //  matrix with diagonal D and off-diagonal E. The singular values
            //  are computed to high relative accuracy, in the absence of
            //  denormalization, underflow and overflow. The algorithm was first
            //  presented in

            //  "Accurate singular values and differential qd algorithms" by K. V.
            //  Fernando and B. N. Parlett, Numer. Math., Vol-67, No. 2, pp. 191-230,
            //  1994,

            //  and the present implementation is described in "An implementation of
            //  the dqds Algorithm (Positive Case)", LAPACK Working Note.

            //  Arguments
            //  =========

            //  N     (input) INTEGER
            //        The number of rows and columns in the matrix. N >= 0.0

            //  D     (input/output) DOUBLE PRECISION array, dimension (N)
            //        On entry, D contains the diagonal elements of the
            //        bidiagonal matrix whose SVD is desired. On normal exit,
            //        D contains the singular values in decreasing order.

            //  E     (input/output) DOUBLE PRECISION array, dimension (N)
            //        On entry, elements E(1:N-1) contain the off-diagonal elements
            //        of the bidiagonal matrix whose SVD is desired.
            //        On exit, E is overwritten.

            //  WORK  (workspace) DOUBLE PRECISION array, dimension (4*N)

            //  INFO  (output) INTEGER
            //        = 0: successful exit
            //        < 0: if INFO = -i, the i-th argument had an illegal value
            //        > 0: the algorithm failed
            //             = 1, a split was marked by a positive value in E
            //             = 2, current block of Z not diagonalized after 30*N
            //                  iterations (in inner while loop)
            //             = 3, termination criterion of outer while loop not met
            //                  (program created more than N unreduced blocks)

            //  =====================================================================

            // System generated locals
            int i__1, i__2;
            double d__1, d__2, d__3;

            // Table of constant values
            int c__1 = 1;
            int c__2 = 2;
            int c__0 = 0;

            // Local variables
            int i;
            double eps;
            double scale;
            int iinfo;
            double sigmn;
            double sigmx;
            double safmin;

            // Parameter adjustments
            --work;
            --e;
            --d;

            // Function Body
            *info = 0;
            if (*n < 0)
            {
                *info = -2;
                i__1 = -(*info);
                xerbla("DLASQ1", &i__1);
                return 0;
            }
            else if (*n == 0)
            {
                return 0;
            }
            else if (*n == 1)
            {
                d[1] = Math.Abs(d[1]);
                return 0;
            }
            else if (*n == 2)
            {
                dlas2(&d[1], &e[1], &d[2], &sigmn, &sigmx);
                d[1] = sigmx;
                d[2] = sigmn;
                return 0;
            }

            // Estimate the largest singular value.

            sigmx = 0.0;
            i__1 = *n - 1;
            for (i = 1; i <= i__1; ++i)
            {
                d[i] = Math.Abs(d[i]);
                // Computing MAX
                d__2 = sigmx;
                d__3 = Math.Abs(e[i]);
                sigmx = Math.Max(d__2, d__3);
            }
            d[*n] = Math.Abs(d[*n]);

            // Early return if SIGMX is zero (matrix is already diagonal).

            if (sigmx == 0.0)
            {
                dlasrt("D", n, &d[1], &iinfo);
                return 0;
            }

            i__1 = *n;
            for (i = 1; i <= i__1; ++i)
            {
                // Computing MAX
                d__1 = sigmx;
                d__2 = d[i];
                sigmx = Math.Max(d__1, d__2);
            }

            // Copy D and E into WORK (in the Z format) and scale (squaring the
            // input data makes scaling by a power of the radix pointless).

            eps = dlamch("Precision");
            safmin = dlamch("Safe minimum");
            scale = Math.Sqrt(eps / safmin);
            dcopy(n, &d[1], &c__1, &work[1], &c__2);
            i__1 = *n - 1;
            dcopy(&i__1, &e[1], &c__1, &work[2], &c__2);
            i__1 = (*n << 1) - 1;
            i__2 = (*n << 1) - 1;
            dlascl("G", &c__0, &c__0, &sigmx, &scale, &i__1, &c__1, &work[1], &i__2, &iinfo);

            // Compute the q's and e's.

            i__1 = (*n << 1) - 1;
            for (i = 1; i <= i__1; ++i)
            {
                // Computing 2nd power
                d__1 = work[i];
                work[i] = d__1 * d__1;
            }
            work[*n * 2] = 0.0;

            dlasq2(n, &work[1], info);

            if (*info == 0)
            {
                i__1 = *n;
                for (i = 1; i <= i__1; ++i)
                {
                    d[i] = Math.Sqrt(work[i]);
                }
                dlascl("G", &c__0, &c__0, &scale, &sigmx, n, &c__1, &d[1], n, &iinfo);
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int dlasq2(int* n, double* z, int* info)
        {
            //  -- LAPACK routine (version 3.2)                                    --

            //  -- Contributed by Osni Marques of the Lawrence Berkeley National   --
            //  -- Laboratory and Beresford Parlett of the Univ. of California at  --
            //  -- Berkeley                                                        --
            //  -- November 2008                                                   --

            //  -- LAPACK is a software package provided by Univ. of Tennessee,    --
            //  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--

            //  Purpose
            //  =======

            //  DLASQ2 computes all the eigenvalues of the symmetric positive
            //  definite tridiagonal matrix associated with the qd array Z to high
            //  relative accuracy are computed to high relative accuracy, in the
            //  absence of denormalization, underflow and overflow.

            //  To see the relation of Z to the tridiagonal matrix, let L be a
            //  unit lower bidiagonal matrix with subdiagonals Z(2,4,6,,..) and
            //  let U be an upper bidiagonal matrix with 1's above and diagonal
            //  Z(1,3,5,,..). The tridiagonal is L*U or, if you prefer, the
            //  symmetric tridiagonal to which it is similar.

            //  Note : DLASQ2 defines a bool variable, IEEE, which is true
            //  on machines which follow ieee-754 floating-point standard in their
            //  handling of infinities and NaNs, and false otherwise. This variable
            //  is passed to DLASQ3.0

            //  Arguments
            //  =========

            //  N     (input) INTEGER
            //        The number of rows and columns in the matrix. N >= 0.0

            //  Z     (input/output) DOUBLE PRECISION array, dimension ( 4*N )
            //        On entry Z holds the qd array. On exit, entries 1 to N hold
            //        the eigenvalues in decreasing order, Z( 2*N+1 ) holds the
            //        trace, and Z( 2*N+2 ) holds the sum of the eigenvalues. If
            //        N > 2, then Z( 2*N+3 ) holds the iteration count, Z( 2*N+4 )
            //        holds NDIVS/NIN^2, and Z( 2*N+5 ) holds the percentage of
            //        shifts that failed.

            //  INFO  (output) INTEGER
            //        = 0: successful exit
            //        < 0: if the i-th argument is a scalar and had an illegal
            //             value, then INFO = -i, if the i-th argument is an
            //             array and the j-entry had an illegal value, then
            //             INFO = -(i*100+j)
            //        > 0: the algorithm failed
            //              = 1, a split was marked by a positive value in E
            //              = 2, current block of Z not diagonalized after 30*N
            //                   iterations (in inner while loop)
            //              = 3, termination criterion of outer while loop not met
            //                   (program created more than N unreduced blocks)

            //  Further Details
            //  ===============
            //  Local Variables: I0:N0 defines a current unreduced segment of Z.
            //  The shifts are accumulated in SIGMA. Iteration count is in ITER.
            //  Ping-pong is controlled by PP (alternates between 0 and 1).

            //  =====================================================================

            //     Test the input arguments.
            //     (in case DLASQ2 is not called by DLASQ1)

            // System generated locals
            int i__1, i__2, i__3;
            double d__1, d__2;

            // Table of constant values
            int c__1 = 1;
            int c__2 = 2;
            int c__10 = 10;
            int c__3 = 3;
            int c__4 = 4;
            int c__11 = 11;

            // Local variables
            double d, e, g;
            int k;
            double s, t;
            int i0, i4, n0;
            double dn;
            int pp;
            double dn1, dn2, dee, eps, tau, tol;
            int ipn4;
            double tol2;
            bool ieee;
            int nbig;
            double dmin, emin, emax;
            int kmin, ndiv, iter;
            double qmin, temp, qmax, zmax;
            int splt;
            double dmin1, dmin2;
            int nfail;
            double desig, trace, sigma;
            int iinfo, ttype;
            double deemin;
            int iwhila, iwhilb;
            double oldemn, safmin;

            // Parameter adjustments
            --z;

            // Function Body
            *info = 0;
            eps = dlamch("Precision");
            safmin = dlamch("Safe minimum");
            tol = eps * 100.0;
            // Computing 2nd power
            d__1 = tol;
            tol2 = d__1 * d__1;

            if (*n < 0)
            {
                *info = -1;
                xerbla("DLASQ2", &c__1);
                return 0;
            }
            else if (*n == 0)
            {
                return 0;
            }
            else if (*n == 1)
            {
                // 1-by-1 case.

                if (z[1] < 0.0)
                {
                    *info = -201;
                    xerbla("DLASQ2", &c__2);
                }
                return 0;
            }
            else if (*n == 2)
            {
                // 2-by-2 case.

                if (z[2] < 0.0 || z[3] < 0.0)
                {
                    *info = -2;
                    xerbla("DLASQ2", &c__2);
                    return 0;
                }
                else if (z[3] > z[1])
                {
                    d = z[3];
                    z[3] = z[1];
                    z[1] = d;
                }
                z[5] = z[1] + z[2] + z[3];
                if (z[2] > z[3] * tol2)
                {
                    t = (z[1] - z[3] + z[2]) * 0.5;
                    s = z[3] * (z[2] / t);
                    if (s <= t)
                    {
                        s = z[3] * (z[2] / (t * (Math.Sqrt(s / t + 1.0) + 1.0)));
                    }
                    else
                    {
                        s = z[3] * (z[2] / (t + Math.Sqrt(t) * Math.Sqrt(t + s)));
                    }
                    t = z[1] + (s + z[2]);
                    z[3] *= z[1] / t;
                    z[1] = t;
                }
                z[2] = z[3];
                z[6] = z[2] + z[1];
                return 0;
            }

            // Check for negative data and compute sums of q's and e's.

            z[*n * 2] = 0.0;
            emin = z[2];
            qmax = 0.0;
            zmax = 0.0;
            d = 0.0;
            e = 0.0;

            i__1 = *n - 1 << 1;
            for (k = 1; k <= i__1; k += 2)
            {
                if (z[k] < 0.0)
                {
                    *info = -(k + 200);
                    xerbla("DLASQ2", &c__2);
                    return 0;
                }
                else if (z[k + 1] < 0.0)
                {
                    *info = -(k + 201);
                    xerbla("DLASQ2", &c__2);
                    return 0;
                }
                d += z[k];
                e += z[k + 1];
                // Computing MAX
                d__1 = qmax;
                d__2 = z[k];
                qmax = Math.Max(d__1, d__2);
                // Computing MIN
                d__1 = emin;
                d__2 = z[k + 1];
                emin = Math.Min(d__1, d__2);
                // Computing MAX
                d__1 = Math.Max(qmax, zmax);
                d__2 = z[k + 1];
                zmax = Math.Max(d__1, d__2);
            }

            if (z[(*n << 1) - 1] < 0.0)
            {
                *info = -((*n << 1) + 199);
                xerbla("DLASQ2", &c__2);
                return 0;
            }

            d += z[(*n << 1) - 1];
            // Computing MAX
            d__1 = qmax;
            d__2 = z[(*n << 1) - 1];
            qmax = Math.Max(d__1, d__2);
            zmax = Math.Max(qmax, zmax);

            // Check for diagonality.

            if (e == 0.0)
            {
                i__1 = *n;
                for (k = 2; k <= i__1; ++k)
                {
                    z[k] = z[(k << 1) - 1];
                }

                dlasrt("D", n, &z[1], &iinfo);
                z[(*n << 1) - 1] = d;

                return 0;
            }

            trace = d + e;

            // Check for zero data.

            if (trace == 0.0)
            {
                z[(*n << 1) - 1] = 0.0;
                return 0;
            }

            // Check whether the machine is IEEE conformable.

            ieee = ilaenv(&c__10, "DLASQ2", "N", &c__1, &c__2, &c__3, &c__4) == 1 &&
                ilaenv(&c__11, "DLASQ2", "N", &c__1, &c__2, &c__3, &c__4) == 1;

            // Rearrange data for locality: Z=(q1,qq1,e1,ee1,q2,qq2,e2,ee2,...).

            for (k = *n << 1; k >= 2; k += -2)
            {
                z[k * 2] = 0.0;
                z[(k << 1) - 1] = z[k];
                z[(k << 1) - 2] = 0.0;
                z[(k << 1) - 3] = z[k - 1];
            }

            i0 = 1;
            n0 = *n;

            // Reverse the qd-array, if warranted.

            if (z[(i0 << 2) - 3] * 1.5 < z[(n0 << 2) - 3])
            {
                ipn4 = i0 + n0 << 2;
                i__1 = i0 + n0 - 1 << 1;
                for (i4 = i0 << 2; i4 <= i__1; i4 += 4)
                {
                    temp = z[i4 - 3];
                    z[i4 - 3] = z[ipn4 - i4 - 3];
                    z[ipn4 - i4 - 3] = temp;
                    temp = z[i4 - 1];
                    z[i4 - 1] = z[ipn4 - i4 - 5];
                    z[ipn4 - i4 - 5] = temp;
                }
            }

            // Initial split checking via dqd and Li's test.

            pp = 0;

            for (k = 1; k <= 2; ++k)
            {
                d = z[(n0 << 2) + pp - 3];
                i__1 = (i0 << 2) + pp;
                for (i4 = (n0 - 1 << 2) + pp; i4 >= i__1; i4 += -4)
                {
                    if (z[i4 - 1] <= tol2 * d)
                    {
                        z[i4 - 1] = -0.0;
                        d = z[i4 - 3];
                    }
                    else
                    {
                        d = z[i4 - 3] * (d / (d + z[i4 - 1]));
                    }
                }

                // dqd maps Z to ZZ plus Li's test.

                emin = z[(i0 << 2) + pp + 1];
                d = z[(i0 << 2) + pp - 3];
                i__1 = (n0 - 1 << 2) + pp;
                for (i4 = (i0 << 2) + pp; i4 <= i__1; i4 += 4)
                {
                    z[i4 - (pp << 1) - 2] = d + z[i4 - 1];
                    if (z[i4 - 1] <= tol2 * d)
                    {
                        z[i4 - 1] = -0.0;
                        z[i4 - (pp << 1) - 2] = d;
                        z[i4 - (pp << 1)] = 0.0;
                        d = z[i4 + 1];
                    }
                    else if (safmin * z[i4 + 1] < z[i4 - (pp << 1) - 2] &&
                        safmin * z[i4 - (pp << 1) - 2] < z[i4 + 1])
                    {
                        temp = z[i4 + 1] / z[i4 - (pp << 1) - 2];
                        z[i4 - (pp << 1)] = z[i4 - 1] * temp;
                        d *= temp;
                    }
                    else
                    {
                        z[i4 - (pp << 1)] = z[i4 + 1] * (z[i4 - 1] / z[i4 - (pp << 1) - 2]);
                        d = z[i4 + 1] * (d / z[i4 - (pp << 1) - 2]);
                    }

                    // Computing MIN
                    d__1 = emin;
                    d__2 = z[i4 - (pp << 1)];
                    emin = Math.Min(d__1, d__2);
                }

                z[(n0 << 2) - pp - 2] = d;

                // Now find qmax.

                qmax = z[(i0 << 2) - pp - 2];
                i__1 = (n0 << 2) - pp - 2;
                for (i4 = (i0 << 2) - pp + 2; i4 <= i__1; i4 += 4)
                {
                    // Computing MAX
                    d__1 = qmax;
                    d__2 = z[i4];
                    qmax = Math.Max(d__1, d__2);
                }

                // Prepare for the next iteration on K.

                pp = 1 - pp;
            }

            // Initialise variables to pass to DLASQ3.0

            ttype = 0;
            dmin1 = 0.0;
            dmin2 = 0.0;
            dn = 0.0;
            dn1 = 0.0;
            dn2 = 0.0;
            g = 0.0;
            tau = 0.0;

            iter = 2;
            nfail = 0;
            ndiv = n0 - i0 << 1;

            i__1 = *n + 1;
            for (iwhila = 1; iwhila <= i__1; ++iwhila)
            {
                if (n0 < 1)
                {
                    goto L170;
                }

                // While array unfinished do

                // E(N0) holds the value of SIGMA when submatrix in I0:N0
                // splits from the rest of the array, but is negated.

                desig = 0.0;
                if (n0 == *n)
                {
                    sigma = 0.0;
                }
                else
                {
                    sigma = -z[(n0 << 2) - 1];
                }
                if (sigma < 0.0)
                {
                    *info = 1;
                    return 0;
                }

                // Find last unreduced submatrix's top index I0, find QMAX and
                // EMIN. Find Gershgorin-type bound if Q's much greater than E's.

                emax = 0.0;
                if (n0 > i0)
                {
                    emin = Math.Abs(z[(n0 << 2) - 5]);
                }
                else
                {
                    emin = 0.0;
                }
                qmin = z[(n0 << 2) - 3];
                qmax = qmin;

                for (i4 = n0 << 2; i4 >= 8; i4 += -4)
                {
                    if (z[i4 - 5] <= 0.0)
                    {
                        goto L100;
                    }
                    if (qmin >= emax * 4.0)
                    {
                        // Computing MIN
                        d__1 = qmin;
                        d__2 = z[i4 - 3];
                        qmin = Math.Min(d__1, d__2);
                        // Computing MAX
                        d__1 = emax;
                        d__2 = z[i4 - 5];
                        emax = Math.Max(d__1, d__2);
                    }
                    // Computing MAX
                    d__1 = qmax;
                    d__2 = z[i4 - 7] + z[i4 - 5];
                    qmax = Math.Max(d__1, d__2);
                    // Computing MIN
                    d__1 = emin;
                    d__2 = z[i4 - 5];
                    emin = Math.Min(d__1, d__2);
                }
                i4 = 4;

            L100:
                i0 = i4 / 4;
                pp = 0;

                if (n0 - i0 > 1)
                {
                    dee = z[(i0 << 2) - 3];
                    deemin = dee;
                    kmin = i0;
                    i__2 = (n0 << 2) - 3;
                    for (i4 = (i0 << 2) + 1; i4 <= i__2; i4 += 4)
                    {
                        dee = z[i4] * (dee / (dee + z[i4 - 2]));
                        if (dee <= deemin)
                        {
                            deemin = dee;
                            kmin = (i4 + 3) / 4;
                        }
                    }
                    if (kmin - i0 << 1 < n0 - kmin && deemin <= z[(n0 << 2) - 3] * 0.5)
                    {
                        ipn4 = i0 + n0 << 2;
                        pp = 2;
                        i__2 = i0 + n0 - 1 << 1;
                        for (i4 = i0 << 2; i4 <= i__2; i4 += 4)
                        {
                            temp = z[i4 - 3];
                            z[i4 - 3] = z[ipn4 - i4 - 3];
                            z[ipn4 - i4 - 3] = temp;
                            temp = z[i4 - 2];
                            z[i4 - 2] = z[ipn4 - i4 - 2];
                            z[ipn4 - i4 - 2] = temp;
                            temp = z[i4 - 1];
                            z[i4 - 1] = z[ipn4 - i4 - 5];
                            z[ipn4 - i4 - 5] = temp;
                            temp = z[i4];
                            z[i4] = z[ipn4 - i4 - 4];
                            z[ipn4 - i4 - 4] = temp;
                        }
                    }
                }

                // Put -(initial shift) into DMIN.

                // Computing MAX
                d__1 = 0.0;
                d__2 = qmin - Math.Sqrt(qmin) * 2.0 * Math.Sqrt(emax);
                dmin = -Math.Max(d__1, d__2);

                // Now I0:N0 is unreduced.
                // PP = 0 for ping, PP = 1 for pong.
                // PP = 2 indicates that flipping was applied to the Z array and
                //        and that the tests for deflation upon entry in DLASQ3
                //        should not be performed.

                nbig = (n0 - i0 + 1) * 30;
                i__2 = nbig;
                for (iwhilb = 1; iwhilb <= i__2; ++iwhilb)
                {
                    if (i0 > n0)
                    {
                        goto L150;
                    }

                    // While submatrix unfinished take a good dqds step.

                    dlasq3(&i0, &n0, &z[1], &pp, &dmin, &sigma, &desig, &qmax, &nfail, &iter,
                        &ndiv, &ieee, &ttype, &dmin1, &dmin2, &dn, &dn1, &dn2, &g, &tau);

                    pp = 1 - pp;

                    // When EMIN is very small check for splits.

                    if (pp == 0 && n0 - i0 >= 3)
                    {
                        if (z[n0 * 4] <= tol2 * qmax || z[(n0 << 2) - 1] <= tol2 * sigma)
                        {
                            splt = i0 - 1;
                            qmax = z[(i0 << 2) - 3];
                            emin = z[(i0 << 2) - 1];
                            oldemn = z[i0 * 4];
                            i__3 = n0 - 3 << 2;
                            for (i4 = i0 << 2; i4 <= i__3; i4 += 4)
                            {
                                if (z[i4] <= tol2 * z[i4 - 3] || z[i4 - 1] <= tol2 * sigma)
                                {
                                    z[i4 - 1] = -sigma;
                                    splt = i4 / 4;
                                    qmax = 0.0;
                                    emin = z[i4 + 3];
                                    oldemn = z[i4 + 4];
                                }
                                else
                                {
                                    // Computing MAX
                                    d__1 = qmax;
                                    d__2 = z[i4 + 1];
                                    qmax = Math.Max(d__1, d__2);
                                    // Computing MIN
                                    d__1 = emin;
                                    d__2 = z[i4 - 1];
                                    emin = Math.Min(d__1, d__2);
                                    // Computing MIN
                                    d__1 = oldemn;
                                    d__2 = z[i4];
                                    oldemn = Math.Min(d__1, d__2);
                                }
                            }
                            z[(n0 << 2) - 1] = emin;
                            z[n0 * 4] = oldemn;
                            i0 = splt + 1;
                        }
                    }
                }

                *info = 2;
                return 0;

                // end IWHILB

                L150:
                ;
            }

            *info = 3;
            return 0;

            // end IWHILA

        L170:

            // Move q's to the front.

            i__1 = *n;
            for (k = 2; k <= i__1; ++k)
            {
                z[k] = z[(k << 2) - 3];
            }

            // Sort and compute sum of eigenvalues.

            dlasrt("D", n, &z[1], &iinfo);

            e = 0.0;
            for (k = *n; k >= 1; --k)
            {
                e += z[k];
            }

            // Store trace, sum(eigenvalues) and information on performance.

            z[(*n << 1) + 1] = trace;
            z[(*n << 1) + 2] = e;
            z[(*n << 1) + 3] = (double)iter;
            // Computing 2nd power
            i__1 = *n;
            z[(*n << 1) + 4] = (double)ndiv / (double)(i__1 * i__1);
            z[(*n << 1) + 5] = nfail * 100.0 / (double)iter;

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int dlasq3(int* i0, int* n0, double* z, int* pp, double* dmin, double* sigma,
            double* desig, double* qmax, int* nfail, int* iter, int* ndiv, bool* ieee, int* ttype,
            double* dmin1, double* dmin2, double* dn, double* dn1, double* dn2, double* g, double* tau)
        {
            //  -- LAPACK routine (version 3.2)                                    --

            //  -- Contributed by Osni Marques of the Lawrence Berkeley National   --
            //  -- Laboratory and Beresford Parlett of the Univ. of California at  --
            //  -- Berkeley                                                        --
            //  -- November 2008                                                   --

            //  -- LAPACK is a software package provided by Univ. of Tennessee,    --
            //  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--

            //  Purpose
            //  =======

            //  DLASQ3 checks for deflation, computes a shift (TAU) and calls dqds.
            //  In case of failure it changes shifts, and tries again until output
            //  is positive.

            //  Arguments
            //  =========

            //  I0     (input) INTEGER
            //         First index.

            //  N0     (input) INTEGER
            //         Last index.

            //  Z      (input) DOUBLE PRECISION array, dimension ( 4*N )
            //         Z holds the qd array.

            //  PP     (input/output) INTEGER
            //         PP=0 for ping, PP=1 for pong.
            //         PP=2 indicates that flipping was applied to the Z array
            //         and that the initial tests for deflation should not be
            //         performed.

            //  DMIN   (output) DOUBLE PRECISION
            //         Minimum value of d.

            //  SIGMA  (output) DOUBLE PRECISION
            //         Sum of shifts used in current segment.

            //  DESIG  (input/output) DOUBLE PRECISION
            //         Lower order part of SIGMA

            //  QMAX   (input) DOUBLE PRECISION
            //         Maximum value of q.

            //  NFAIL  (output) INTEGER
            //         Number of times shift was too big.

            //  ITER   (output) INTEGER
            //         Number of iterations.

            //  NDIV   (output) INTEGER
            //         Number of divisions.

            //  IEEE   (input) LOGICAL
            //         Flag for IEEE or non IEEE arithmetic (passed to DLASQ5).

            //  TTYPE  (input/output) INTEGER
            //         Shift type.

            //  DMIN1, DMIN2, DN, DN1, DN2, G, TAU (input/output) DOUBLE PRECISION
            //         These are passed as arguments in order to save their values
            //         between calls to DLASQ3.0

            //  =====================================================================

            // System generated locals
            int i__1;
            double d__1, d__2;

            // Local variables
            double s, t;
            int j4, nn;
            double eps, tol;
            int n0in, ipn4;
            double tol2, temp;

            // Parameter adjustments
            --z;

            // Function Body
            n0in = *n0;
            eps = dlamch("Precision");
            tol = eps * 100.0;
            // Computing 2nd power
            d__1 = tol;
            tol2 = d__1 * d__1;

            // Check for deflation.

        L10:

            if (*n0 < *i0)
            {
                return 0;
            }
            if (*n0 == *i0)
            {
                goto L20;
            }
            nn = (*n0 << 2) + *pp;
            if (*n0 == *i0 + 1)
            {
                goto L40;
            }

            // Check whether E(N0-1) is negligible, 1 eigenvalue.

            if (z[nn - 5] > tol2 * (*sigma + z[nn - 3]) && z[nn - (*pp << 1) -
                4] > tol2 * z[nn - 7])
            {
                goto L30;
            }

        L20:

            z[(*n0 << 2) - 3] = z[(*n0 << 2) + *pp - 3] + *sigma;
            --(*n0);
            goto L10;

            // Check  whether E(N0-2) is negligible, 2 eigenvalues.

        L30:

            if (z[nn - 9] > tol2 * *sigma && z[nn - (*pp << 1) - 8] > tol2 * z[nn - 11])
            {
                goto L50;
            }

        L40:

            if (z[nn - 3] > z[nn - 7])
            {
                s = z[nn - 3];
                z[nn - 3] = z[nn - 7];
                z[nn - 7] = s;
            }

            if (z[nn - 5] > z[nn - 3] * tol2)
            {
                t = (z[nn - 7] - z[nn - 3] + z[nn - 5]) * 0.5;
                s = z[nn - 3] * (z[nn - 5] / t);
                if (s <= t)
                {
                    s = z[nn - 3] * (z[nn - 5] / (t * (Math.Sqrt(s / t + 1.0) + 1.0)));
                }
                else
                {
                    s = z[nn - 3] * (z[nn - 5] / (t + Math.Sqrt(t) * Math.Sqrt(t + s)));
                }
                t = z[nn - 7] + (s + z[nn - 5]);
                z[nn - 3] *= z[nn - 7] / t;
                z[nn - 7] = t;
            }
            z[(*n0 << 2) - 7] = z[nn - 7] + *sigma;
            z[(*n0 << 2) - 3] = z[nn - 3] + *sigma;
            *n0 += -2;
            goto L10;

        L50:
            if (*pp == 2)
            {
                *pp = 0;
            }

            // Reverse the qd-array, if warranted.

            if (*dmin <= 0.0 || *n0 < n0in)
            {
                if (z[(*i0 << 2) + *pp - 3] * 1.5 < z[(*n0 << 2) + *pp - 3])
                {
                    ipn4 = *i0 + *n0 << 2;
                    i__1 = *i0 + *n0 - 1 << 1;
                    for (j4 = *i0 << 2; j4 <= i__1; j4 += 4)
                    {
                        temp = z[j4 - 3];
                        z[j4 - 3] = z[ipn4 - j4 - 3];
                        z[ipn4 - j4 - 3] = temp;
                        temp = z[j4 - 2];
                        z[j4 - 2] = z[ipn4 - j4 - 2];
                        z[ipn4 - j4 - 2] = temp;
                        temp = z[j4 - 1];
                        z[j4 - 1] = z[ipn4 - j4 - 5];
                        z[ipn4 - j4 - 5] = temp;
                        temp = z[j4];
                        z[j4] = z[ipn4 - j4 - 4];
                        z[ipn4 - j4 - 4] = temp;
                    }

                    if (*n0 - *i0 <= 4)
                    {
                        z[(*n0 << 2) + *pp - 1] = z[(*i0 << 2) + *pp - 1];
                        z[(*n0 << 2) - *pp] = z[(*i0 << 2) - *pp];
                    }

                    // Computing MIN
                    d__1 = *dmin2;
                    d__2 = z[(*n0 << 2) + *pp - 1];
                    *dmin2 = Math.Min(d__1, d__2);
                    // Computing MIN
                    d__1 = z[(*n0 << 2) + *pp - 1];
                    d__2 = z[(*i0 << 2) + *pp - 1];

                    d__1 = Math.Min(d__1, d__2);
                    d__2 = z[(*i0 << 2) + *pp + 3];

                    z[(*n0 << 2) + *pp - 1] = Math.Min(d__1, d__2);
                    // Computing MIN
                    d__1 = z[(*n0 << 2) - *pp];
                    d__2 = z[(*i0 << 2) - *pp];

                    d__1 = Math.Min(d__1, d__2);
                    d__2 = z[(*i0 << 2) - *pp + 4];

                    z[(*n0 << 2) - *pp] = Math.Min(d__1, d__2);
                    // Computing MAX
                    d__1 = *qmax;
                    d__2 = z[(*i0 << 2) + *pp - 3];

                    d__1 = Math.Max(d__1, d__2);
                    d__2 = z[(*i0 << 2) + *pp + 1];

                    *qmax = Math.Max(d__1, d__2);
                    *dmin = -0.0;
                }
            }

            // Choose a shift.

            dlasq4(i0, n0, &z[1], pp, &n0in, dmin, dmin1, dmin2, dn, dn1, dn2, tau, ttype, g);

            // Call dqds until DMIN > 0.0

        L70:

            dlasq5(i0, n0, &z[1], pp, tau, dmin, dmin1, dmin2, dn, dn1, dn2, ieee);

            *ndiv += *n0 - *i0 + 2;
            ++(*iter);

            // Check status.

            if (*dmin >= 0.0 && *dmin1 > 0.0)
            {
                // Success.

                goto L90;

            }
            else if (*dmin < 0.0 && *dmin1 > 0.0 && z[(*n0 - 1 << 2) - *pp] <
                tol * (*sigma + *dn1) && Math.Abs(*dn) < tol * *sigma)
            {
                // Convergence hidden by negative DN.

                z[(*n0 - 1 << 2) - *pp + 2] = 0.0;
                *dmin = 0.0;
                goto L90;
            }
            else if (*dmin < 0.0)
            {
                // TAU too big. Select new TAU and try again.

                ++(*nfail);
                if (*ttype < -22)
                {
                    // Failed twice. Play it safe.

                    *tau = 0.0;
                }
                else if (*dmin1 > 0.0)
                {
                    // Late failure. Gives excellent shift.

                    *tau = (*tau + *dmin) * (1.0 - eps * 2.0);
                    *ttype += -11;
                }
                else
                {
                    // Early failure. Divide by 4.0

                    *tau *= 0.25;
                    *ttype += -12;
                }
                goto L70;
            }
            else if (disnan(dmin))
            {
                // NaN.

                if (*tau == 0.0)
                {
                    goto L80;
                }
                else
                {
                    *tau = 0.0;
                    goto L70;
                }
            }
            else
            {
                // Possible underflow. Play it safe.

                goto L80;
            }

            // Risk of underflow.

        L80:
            dlasq6(i0, n0, &z[1], pp, dmin, dmin1, dmin2, dn, dn1, dn2);
            *ndiv += *n0 - *i0 + 2;
            ++(*iter);
            *tau = 0.0;

        L90:
            if (*tau < *sigma)
            {
                *desig += *tau;
                t = *sigma + *desig;
                *desig -= t - *sigma;
            }
            else
            {
                t = *sigma + *tau;
                *desig = *sigma - (t - *tau) + *desig;
            }
            *sigma = t;

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int dlasq4(int* i0, int* n0, double* z, int* pp, int* n0in, double* dmin, double* dmin1,
            double* dmin2, double* dn, double* dn1, double* dn2, double* tau, int* ttype, double* g)
        {
            //  -- LAPACK routine (version 3.2)                                    --

            //  -- Contributed by Osni Marques of the Lawrence Berkeley National   --
            //  -- Laboratory and Beresford Parlett of the Univ. of California at  --
            //  -- Berkeley                                                        --
            //  -- November 2008                                                   --

            //  -- LAPACK is a software package provided by Univ. of Tennessee,    --
            //  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--

            //  Purpose
            //  =======

            //  DLASQ4 computes an approximation TAU to the smallest eigenvalue
            //  using values of d from the previous transform.

            //  I0    (input) INTEGER
            //        First index.

            //  N0    (input) INTEGER
            //        Last index.

            //  Z     (input) DOUBLE PRECISION array, dimension ( 4*N )
            //        Z holds the qd array.

            //  PP    (input) INTEGER
            //        PP=0 for ping, PP=1 for pong.

            //  NOIN  (input) INTEGER
            //        The value of N0 at start of EIGTEST.

            //  DMIN  (input) DOUBLE PRECISION
            //        Minimum value of d.

            //  DMIN1 (input) DOUBLE PRECISION
            //        Minimum value of d, excluding D( N0 ).

            //  DMIN2 (input) DOUBLE PRECISION
            //        Minimum value of d, excluding D( N0 ) and D( N0-1 ).

            //  DN    (input) DOUBLE PRECISION
            //        d(N)

            //  DN1   (input) DOUBLE PRECISION
            //        d(N-1)

            //  DN2   (input) DOUBLE PRECISION
            //        d(N-2)

            //  TAU   (output) DOUBLE PRECISION
            //        This is the shift.

            //  TTYPE (output) INTEGER
            //        Shift type.

            //  G     (input/output) REAL
            //        G is passed as an argument in order to save its value between
            //        calls to DLASQ4.0

            //  Further Details
            //  ===============
            //  CNST1 = 9/16

            //  =====================================================================

            //     A negative DMIN forces the shift to take that absolute value
            //     TTYPE records the type of shift.

            // System generated locals
            int i__1;
            double d__1, d__2;

            // Local variables
            double s = 0, a2, b1, b2;
            int i4, nn, np;
            double gam, gap1, gap2;

            // Parameter adjustments
            --z;

            // Function Body
            if (*dmin <= 0.0)
            {
                *tau = -(*dmin);
                *ttype = -1;
                return 0;
            }

            nn = (*n0 << 2) + *pp;
            if (*n0in == *n0)
            {
                // No eigenvalues deflated.

                if (*dmin == *dn || *dmin == *dn1)
                {
                    b1 = Math.Sqrt(z[nn - 3]) * Math.Sqrt(z[nn - 5]);
                    b2 = Math.Sqrt(z[nn - 7]) * Math.Sqrt(z[nn - 9]);
                    a2 = z[nn - 7] + z[nn - 5];

                    // Cases 2 and 3.0

                    if (*dmin == *dn && *dmin1 == *dn1)
                    {
                        gap2 = *dmin2 - a2 - *dmin2 * 0.25;
                        if (gap2 > 0.0 && gap2 > b2)
                        {
                            gap1 = a2 - *dn - b2 / gap2 * b2;
                        }
                        else
                        {
                            gap1 = a2 - *dn - (b1 + b2);
                        }
                        if (gap1 > 0.0 && gap1 > b1)
                        {
                            // Computing MAX
                            d__1 = *dn - b1 / gap1 * b1;
                            d__2 = *dmin * 0.5;
                            s = Math.Max(d__1, d__2);
                            *ttype = -2;
                        }
                        else
                        {
                            s = 0.0;
                            if (*dn > b1)
                            {
                                s = *dn - b1;
                            }
                            if (a2 > b1 + b2)
                            {
                                // Computing MIN
                                d__1 = s;
                                d__2 = a2 - (b1 + b2);
                                s = Math.Min(d__1, d__2);
                            }
                            // Computing MAX
                            d__1 = s;
                            d__2 = *dmin * 0.333;
                            s = Math.Max(d__1, d__2);
                            *ttype = -3;
                        }
                    }
                    else
                    {
                        // Case 4.0

                        *ttype = -4;
                        s = *dmin * 0.25;
                        if (*dmin == *dn)
                        {
                            gam = *dn;
                            a2 = 0.0;
                            if (z[nn - 5] > z[nn - 7])
                            {
                                return 0;
                            }
                            b2 = z[nn - 5] / z[nn - 7];
                            np = nn - 9;
                        }
                        else
                        {
                            np = nn - (*pp << 1);
                            b2 = z[np - 2];
                            gam = *dn1;
                            if (z[np - 4] > z[np - 2])
                            {
                                return 0;
                            }
                            a2 = z[np - 4] / z[np - 2];
                            if (z[nn - 9] > z[nn - 11])
                            {
                                return 0;
                            }
                            b2 = z[nn - 9] / z[nn - 11];
                            np = nn - 13;
                        }

                        // Approximate contribution to norm squared from I < NN-1.0

                        a2 += b2;
                        i__1 = (*i0 << 2) - 1 + *pp;
                        for (i4 = np; i4 >= i__1; i4 += -4)
                        {
                            if (b2 == 0.0)
                            {
                                goto L20;
                            }
                            b1 = b2;
                            if (z[i4] > z[i4 - 2])
                            {
                                return 0;
                            }
                            b2 *= z[i4] / z[i4 - 2];
                            a2 += b2;
                            if (Math.Max(b2, b1) * 100.0 < a2 || 0.563 < a2)
                            {
                                goto L20;
                            }
                        }
                    L20:
                        a2 *= 1.05;

                        // Rayleigh quotient residual bound.

                        if (a2 < 0.563)
                        {
                            s = gam * (1.0 - Math.Sqrt(a2)) / (a2 + 1.0);
                        }
                    }
                }
                else if (*dmin == *dn2)
                {
                    // Case 5.0

                    *ttype = -5;
                    s = *dmin * 0.25;

                    // Compute contribution to norm squared from I > NN-2.0

                    np = nn - (*pp << 1);
                    b1 = z[np - 2];
                    b2 = z[np - 6];
                    gam = *dn2;
                    if (z[np - 8] > b2 || z[np - 4] > b1)
                    {
                        return 0;
                    }
                    a2 = z[np - 8] / b2 * (z[np - 4] / b1 + 1.0);

                    // Approximate contribution to norm squared from I < NN-2.0

                    if (*n0 - *i0 > 2)
                    {
                        b2 = z[nn - 13] / z[nn - 15];
                        a2 += b2;
                        i__1 = (*i0 << 2) - 1 + *pp;
                        for (i4 = nn - 17; i4 >= i__1; i4 += -4)
                        {
                            if (b2 == 0.0)
                            {
                                goto L40;
                            }
                            b1 = b2;
                            if (z[i4] > z[i4 - 2])
                            {
                                return 0;
                            }
                            b2 *= z[i4] / z[i4 - 2];
                            a2 += b2;
                            if (Math.Max(b2, b1) * 100.0 < a2 || 0.563 < a2)
                            {
                                goto L40;
                            }
                        }
                    L40:
                        a2 *= 1.05;
                    }

                    if (a2 < 0.563)
                    {
                        s = gam * (1.0 - Math.Sqrt(a2)) / (a2 + 1.0);
                    }
                }
                else
                {
                    // Case 6, no information to guide us.

                    if (*ttype == -6)
                    {
                        *g += (1.0 - *g) * 0.333;
                    }
                    else if (*ttype == -18)
                    {
                        *g = 0.083250000000000005;
                    }
                    else
                    {
                        *g = 0.25;
                    }
                    s = *g * *dmin;
                    *ttype = -6;
                }

            }
            else if (*n0in == *n0 + 1)
            {
                // One eigenvalue just deflated. Use DMIN1, DN1 for DMIN and DN.

                if (*dmin1 == *dn1 && *dmin2 == *dn2)
                {
                    // Cases 7 and 8.0

                    *ttype = -7;
                    s = *dmin1 * 0.333;
                    if (z[nn - 5] > z[nn - 7])
                    {
                        return 0;
                    }
                    b1 = z[nn - 5] / z[nn - 7];
                    b2 = b1;
                    if (b2 == 0.0)
                    {
                        goto L60;
                    }
                    i__1 = (*i0 << 2) - 1 + *pp;
                    for (i4 = (*n0 << 2) - 9 + *pp; i4 >= i__1; i4 += -4)
                    {
                        a2 = b1;
                        if (z[i4] > z[i4 - 2])
                        {
                            return 0;
                        }
                        b1 *= z[i4] / z[i4 - 2];
                        b2 += b1;
                        if (Math.Max(b1, a2) * 100.0 < b2)
                        {
                            goto L60;
                        }
                    }
                L60:
                    b2 = Math.Sqrt(b2 * 1.05);
                    // Computing 2nd power
                    d__1 = b2;
                    a2 = *dmin1 / (d__1 * d__1 + 1.0);
                    gap2 = *dmin2 * 0.5 - a2;
                    if (gap2 > 0.0 && gap2 > b2 * a2)
                    {
                        // Computing MAX
                        d__1 = s;
                        d__2 = a2 * (1.0 - a2 * 1.01 * (b2 / gap2) * b2);
                        s = Math.Max(d__1, d__2);
                    }
                    else
                    {
                        // Computing MAX
                        d__1 = s;
                        d__2 = a2 * (1.0 - b2 * 1.01);
                        s = Math.Max(d__1, d__2);
                        *ttype = -8;
                    }
                }
                else
                {
                    // Case 9.0

                    s = *dmin1 * 0.25;
                    if (*dmin1 == *dn1)
                    {
                        s = *dmin1 * 0.5;
                    }
                    *ttype = -9;
                }

            }
            else if (*n0in == *n0 + 2)
            {
                // Two eigenvalues deflated. Use DMIN2, DN2 for DMIN and DN.

                // Cases 10 and 11.0

                if (*dmin2 == *dn2 && z[nn - 5] * 2.0 < z[nn - 7])
                {
                    *ttype = -10;
                    s = *dmin2 * 0.333;
                    if (z[nn - 5] > z[nn - 7])
                    {
                        return 0;
                    }
                    b1 = z[nn - 5] / z[nn - 7];
                    b2 = b1;
                    if (b2 == 0.0)
                    {
                        goto L80;
                    }
                    i__1 = (*i0 << 2) - 1 + *pp;
                    for (i4 = (*n0 << 2) - 9 + *pp; i4 >= i__1; i4 += -4)
                    {
                        if (z[i4] > z[i4 - 2])
                        {
                            return 0;
                        }
                        b1 *= z[i4] / z[i4 - 2];
                        b2 += b1;
                        if (b1 * 100.0 < b2)
                        {
                            goto L80;
                        }
                    }
                L80:
                    b2 = Math.Sqrt(b2 * 1.05);
                    // Computing 2nd power
                    d__1 = b2;
                    a2 = *dmin2 / (d__1 * d__1 + 1.0);
                    gap2 = z[nn - 7] + z[nn - 9] - Math.Sqrt(z[nn - 11]) * Math.Sqrt(z[nn - 9]) - a2;
                    if (gap2 > 0.0 && gap2 > b2 * a2)
                    {
                        // Computing MAX
                        d__1 = s;
                        d__2 = a2 * (1.0 - a2 * 1.01 * (b2 / gap2) * b2);
                        s = Math.Max(d__1, d__2);
                    }
                    else
                    {
                        // Computing MAX
                        d__1 = s;
                        d__2 = a2 * (1.0 - b2 * 1.01);
                        s = Math.Max(d__1, d__2);
                    }
                }
                else
                {
                    s = *dmin2 * 0.25;
                    *ttype = -11;
                }
            }
            else if (*n0in > *n0 + 2)
            {
                // Case 12, more than two eigenvalues deflated. No information.

                s = 0.0;
                *ttype = -12;
            }

            *tau = s;

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int dlasq5(int* i0, int* n0, double* z, int* pp, double* tau, double* dmin,
            double* dmin1, double* dmin2, double* dn, double* dnm1, double* dnm2, bool* ieee)
        {
            //  -- LAPACK routine (version 3.2)                                    --

            //  -- Contributed by Osni Marques of the Lawrence Berkeley National   --
            //  -- Laboratory and Beresford Parlett of the Univ. of California at  --
            //  -- Berkeley                                                        --
            //  -- November 2008                                                   --

            //  -- LAPACK is a software package provided by Univ. of Tennessee,    --
            //  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--

            //  Purpose
            //  =======

            //  DLASQ5 computes one dqds transform in ping-pong form, one
            //  version for IEEE machines another for non IEEE machines.

            //  Arguments
            //  =========

            //  I0    (input) INTEGER
            //        First index.

            //  N0    (input) INTEGER
            //        Last index.

            //  Z     (input) DOUBLE PRECISION array, dimension ( 4*N )
            //        Z holds the qd array. EMIN is stored in Z(4*N0) to avoid
            //        an extra argument.

            //  PP    (input) INTEGER
            //        PP=0 for ping, PP=1 for pong.

            //  TAU   (input) DOUBLE PRECISION
            //        This is the shift.

            //  DMIN  (output) DOUBLE PRECISION
            //        Minimum value of d.

            //  DMIN1 (output) DOUBLE PRECISION
            //        Minimum value of d, excluding D( N0 ).

            //  DMIN2 (output) DOUBLE PRECISION
            //        Minimum value of d, excluding D( N0 ) and D( N0-1 ).

            //  DN    (output) DOUBLE PRECISION
            //        d(N0), the last value of d.

            //  DNM1  (output) DOUBLE PRECISION
            //        d(N0-1).

            //  DNM2  (output) DOUBLE PRECISION
            //        d(N0-2).

            //  IEEE  (input) LOGICAL
            //        Flag for IEEE or non IEEE arithmetic.

            //  =====================================================================

            // System generated locals
            int i__1;
            double d__1, d__2;

            // Local variables
            double d;
            int j4, j4p2;
            double emin, temp;

            // Parameter adjustments
            --z;

            // Function Body
            if (*n0 - *i0 - 1 <= 0)
            {
                return 0;
            }

            j4 = (*i0 << 2) + *pp - 3;
            emin = z[j4 + 4];
            d = z[j4] - *tau;
            *dmin = d;
            *dmin1 = -z[j4];

            if (*ieee)
            {
                // Code for IEEE arithmetic.

                if (*pp == 0)
                {
                    i__1 = *n0 - 3 << 2;
                    for (j4 = *i0 << 2; j4 <= i__1; j4 += 4)
                    {
                        z[j4 - 2] = d + z[j4 - 1];
                        temp = z[j4 + 1] / z[j4 - 2];
                        d = d * temp - *tau;
                        *dmin = Math.Min(*dmin, d);
                        z[j4] = z[j4 - 1] * temp;
                        // Computing MIN
                        d__1 = z[j4];
                        emin = Math.Min(d__1, emin);
                    }
                }
                else
                {
                    i__1 = *n0 - 3 << 2;
                    for (j4 = *i0 << 2; j4 <= i__1; j4 += 4)
                    {
                        z[j4 - 3] = d + z[j4];
                        temp = z[j4 + 2] / z[j4 - 3];
                        d = d * temp - *tau;
                        *dmin = Math.Min(*dmin, d);
                        z[j4 - 1] = z[j4] * temp;
                        // Computing MIN
                        d__1 = z[j4 - 1];
                        emin = Math.Min(d__1, emin);
                    }
                }

                // Unroll last two steps.

                *dnm2 = d;
                *dmin2 = *dmin;
                j4 = (*n0 - 2 << 2) - *pp;
                j4p2 = j4 + (*pp << 1) - 1;
                z[j4 - 2] = *dnm2 + z[j4p2];
                z[j4] = z[j4p2 + 2] * (z[j4p2] / z[j4 - 2]);
                *dnm1 = z[j4p2 + 2] * (*dnm2 / z[j4 - 2]) - *tau;
                *dmin = Math.Min(*dmin, *dnm1);

                *dmin1 = *dmin;
                j4 += 4;
                j4p2 = j4 + (*pp << 1) - 1;
                z[j4 - 2] = *dnm1 + z[j4p2];
                z[j4] = z[j4p2 + 2] * (z[j4p2] / z[j4 - 2]);
                *dn = z[j4p2 + 2] * (*dnm1 / z[j4 - 2]) - *tau;
                *dmin = Math.Min(*dmin, *dn);

            }
            else
            {
                // Code for non IEEE arithmetic.

                if (*pp == 0)
                {
                    i__1 = *n0 - 3 << 2;
                    for (j4 = *i0 << 2; j4 <= i__1; j4 += 4)
                    {
                        z[j4 - 2] = d + z[j4 - 1];
                        if (d < 0.0)
                        {
                            return 0;
                        }
                        else
                        {
                            z[j4] = z[j4 + 1] * (z[j4 - 1] / z[j4 - 2]);
                            d = z[j4 + 1] * (d / z[j4 - 2]) - *tau;
                        }

                        *dmin = Math.Min(*dmin, d);
                        // Computing MIN
                        d__1 = emin;
                        d__2 = z[j4];
                        emin = Math.Min(d__1, d__2);
                    }
                }
                else
                {
                    i__1 = *n0 - 3 << 2;
                    for (j4 = *i0 << 2; j4 <= i__1; j4 += 4)
                    {
                        z[j4 - 3] = d + z[j4];
                        if (d < 0.0)
                        {
                            return 0;
                        }
                        else
                        {
                            z[j4 - 1] = z[j4 + 2] * (z[j4] / z[j4 - 3]);
                            d = z[j4 + 2] * (d / z[j4 - 3]) - *tau;
                        }

                        *dmin = Math.Min(*dmin, d);
                        // Computing MIN
                        d__1 = emin;
                        d__2 = z[j4 - 1];
                        emin = Math.Min(d__1, d__2);
                    }
                }

                // Unroll last two steps.

                *dnm2 = d;
                *dmin2 = *dmin;
                j4 = (*n0 - 2 << 2) - *pp;
                j4p2 = j4 + (*pp << 1) - 1;
                z[j4 - 2] = *dnm2 + z[j4p2];

                if (*dnm2 < 0.0)
                {
                    return 0;
                }
                else
                {
                    z[j4] = z[j4p2 + 2] * (z[j4p2] / z[j4 - 2]);
                    *dnm1 = z[j4p2 + 2] * (*dnm2 / z[j4 - 2]) - *tau;
                }

                *dmin = Math.Min(*dmin, *dnm1);

                *dmin1 = *dmin;
                j4 += 4;
                j4p2 = j4 + (*pp << 1) - 1;
                z[j4 - 2] = *dnm1 + z[j4p2];

                if (*dnm1 < 0.0)
                {
                    return 0;
                }
                else
                {
                    z[j4] = z[j4p2 + 2] * (z[j4p2] / z[j4 - 2]);
                    *dn = z[j4p2 + 2] * (*dnm1 / z[j4 - 2]) - *tau;
                }

                *dmin = Math.Min(*dmin, *dn);

            }

            z[j4 + 2] = *dn;
            z[(*n0 << 2) - *pp] = emin;

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int dlasq6(int* i0, int* n0, double* z, int* pp, double* dmin,
            double* dmin1, double* dmin2, double* dn, double* dnm1, double* dnm2)
        {
            //  -- LAPACK routine (version 3.2)                                    --

            //  -- Contributed by Osni Marques of the Lawrence Berkeley National   --
            //  -- Laboratory and Beresford Parlett of the Univ. of California at  --
            //  -- Berkeley                                                        --
            //  -- November 2008                                                   --

            //  -- LAPACK is a software package provided by Univ. of Tennessee,    --
            //  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--

            //  Purpose
            //  =======

            //  DLASQ6 computes one dqd (shift equal to zero) transform in
            //  ping-pong form, with protection against underflow and overflow.

            //  Arguments
            //  =========

            //  I0    (input) INTEGER
            //        First index.

            //  N0    (input) INTEGER
            //        Last index.

            //  Z     (input) DOUBLE PRECISION array, dimension ( 4*N )
            //        Z holds the qd array. EMIN is stored in Z(4*N0) to avoid
            //        an extra argument.

            //  PP    (input) INTEGER
            //        PP=0 for ping, PP=1 for pong.

            //  DMIN  (output) DOUBLE PRECISION
            //        Minimum value of d.

            //  DMIN1 (output) DOUBLE PRECISION
            //        Minimum value of d, excluding D( N0 ).

            //  DMIN2 (output) DOUBLE PRECISION
            //        Minimum value of d, excluding D( N0 ) and D( N0-1 ).

            //  DN    (output) DOUBLE PRECISION
            //        d(N0), the last value of d.

            //  DNM1  (output) DOUBLE PRECISION
            //        d(N0-1).

            //  DNM2  (output) DOUBLE PRECISION
            //        d(N0-2).

            //  =====================================================================

            // System generated locals
            int i__1;
            double d__1, d__2;

            // Local variables
            double d__;
            int j4, j4p2;
            double emin, temp;
            double safmin;

            // Parameter adjustments
            --z;

            // Function Body
            if (*n0 - *i0 - 1 <= 0)
            {
                return 0;
            }

            safmin = dlamch("Safe minimum");
            j4 = (*i0 << 2) + *pp - 3;
            emin = z[j4 + 4];
            d__ = z[j4];
            *dmin = d__;

            if (*pp == 0)
            {
                i__1 = *n0 - 3 << 2;
                for (j4 = *i0 << 2; j4 <= i__1; j4 += 4)
                {
                    z[j4 - 2] = d__ + z[j4 - 1];
                    if (z[j4 - 2] == 0.0)
                    {
                        z[j4] = 0.0;
                        d__ = z[j4 + 1];
                        *dmin = d__;
                        emin = 0.0;
                    }
                    else if (safmin * z[j4 + 1] < z[j4 - 2] && safmin * z[j4 - 2] < z[j4 + 1])
                    {
                        temp = z[j4 + 1] / z[j4 - 2];
                        z[j4] = z[j4 - 1] * temp;
                        d__ *= temp;
                    }
                    else
                    {
                        z[j4] = z[j4 + 1] * (z[j4 - 1] / z[j4 - 2]);
                        d__ = z[j4 + 1] * (d__ / z[j4 - 2]);
                    }

                    *dmin = Math.Min(*dmin, d__);
                    // Computing MIN
                    d__1 = emin;
                    d__2 = z[j4];
                    emin = Math.Min(d__1, d__2);
                }
            }
            else
            {
                i__1 = *n0 - 3 << 2;
                for (j4 = *i0 << 2; j4 <= i__1; j4 += 4)
                {
                    z[j4 - 3] = d__ + z[j4];
                    if (z[j4 - 3] == 0.0)
                    {
                        z[j4 - 1] = 0.0;
                        d__ = z[j4 + 2];
                        *dmin = d__;
                        emin = 0.0;
                    }
                    else if (safmin * z[j4 + 2] < z[j4 - 3] && safmin * z[j4 - 3] < z[j4 + 2])
                    {
                        temp = z[j4 + 2] / z[j4 - 3];
                        z[j4 - 1] = z[j4] * temp;
                        d__ *= temp;
                    }
                    else
                    {
                        z[j4 - 1] = z[j4 + 2] * (z[j4] / z[j4 - 3]);
                        d__ = z[j4 + 2] * (d__ / z[j4 - 3]);
                    }

                    *dmin = Math.Min(*dmin, d__);
                    // Computing MIN
                    d__1 = emin;
                    d__2 = z[j4 - 1];
                    emin = Math.Min(d__1, d__2);
                }
            }

            // Unroll last two steps.

            *dnm2 = d__;
            *dmin2 = *dmin;
            j4 = (*n0 - 2 << 2) - *pp;
            j4p2 = j4 + (*pp << 1) - 1;
            z[j4 - 2] = *dnm2 + z[j4p2];
            if (z[j4 - 2] == 0.0)
            {
                z[j4] = 0.0;
                *dnm1 = z[j4p2 + 2];
                *dmin = *dnm1;
                emin = 0.0;
            }
            else if (safmin * z[j4p2 + 2] < z[j4 - 2] && safmin * z[j4 - 2] < z[j4p2 + 2])
            {
                temp = z[j4p2 + 2] / z[j4 - 2];
                z[j4] = z[j4p2] * temp;
                *dnm1 = *dnm2 * temp;
            }
            else
            {
                z[j4] = z[j4p2 + 2] * (z[j4p2] / z[j4 - 2]);
                *dnm1 = z[j4p2 + 2] * (*dnm2 / z[j4 - 2]);
            }
            *dmin = Math.Min(*dmin, *dnm1);

            *dmin1 = *dmin;
            j4 += 4;
            j4p2 = j4 + (*pp << 1) - 1;
            z[j4 - 2] = *dnm1 + z[j4p2];
            if (z[j4 - 2] == 0.0)
            {
                z[j4] = 0.0;
                *dn = z[j4p2 + 2];
                *dmin = *dn;
                emin = 0.0;
            }
            else if (safmin * z[j4p2 + 2] < z[j4 - 2] && safmin * z[j4 - 2] < z[j4p2 + 2])
            {
                temp = z[j4p2 + 2] / z[j4 - 2];
                z[j4] = z[j4p2] * temp;
                *dn = *dnm1 * temp;
            }
            else
            {
                z[j4] = z[j4p2 + 2] * (z[j4p2] / z[j4 - 2]);
                *dn = z[j4p2 + 2] * (*dnm1 / z[j4 - 2]);
            }
            *dmin = Math.Min(*dmin, *dn);

            z[j4 + 2] = *dn;
            z[(*n0 << 2) - *pp] = emin;

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int dlasr(string side, string pivot, string direct,
            int* m, int* n, double* c, double* s, double* a, int* lda)
        {
            //  -- LAPACK auxiliary routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     November 2006

            //  Purpose
            //  =======

            //  DLASR applies a sequence of plane rotations to a real matrix A,
            //  from either the left or the right.

            //  When SIDE = 'L', the transformation takes the form

            //     A := P*A

            //  and when SIDE = 'R', the transformation takes the form

            //     A := A*P**T

            //  where P is an orthogonal matrix consisting of a sequence of z plane
            //  rotations, with z = M when SIDE = 'L' and z = N when SIDE = 'R',
            //  and P**T is the transpose of P.

            //  When DIRECT = 'F' (Forward sequence), then

            //     P = P(z-1) * ... * P(2) * P(1)

            //  and when DIRECT = 'B' (Backward sequence), then

            //     P = P(1) * P(2) * ... * P(z-1)

            //  where P(k) is a plane rotation matrix defined by the 2-by-2 rotation

            //     R(k) = (  c(k)  s(k) )
            //          = ( -s(k)  c(k) ).

            //  When PIVOT = 'V' (Variable pivot), the rotation is performed
            //  for the plane (k,k+1), i.e., P(k) has the form

            //     P(k) = (  1                                            )
            //            (       ...                                     )
            //            (              1                                )
            //            (                   c(k)  s(k)                  )
            //            (                  -s(k)  c(k)                  )
            //            (                                1              )
            //            (                                     ...       )
            //            (                                            1  )

            //  where R(k) appears as a rank-2 modification to the identity matrix in
            //  rows and columns k and k+1.

            //  When PIVOT = 'T' (Top pivot), the rotation is performed for the
            //  plane (1,k+1), so P(k) has the form

            //     P(k) = (  c(k)                    s(k)                 )
            //            (         1                                     )
            //            (              ...                              )
            //            (                     1                         )
            //            ( -s(k)                    c(k)                 )
            //            (                                 1             )
            //            (                                      ...      )
            //            (                                             1 )

            //  where R(k) appears in rows and columns 1 and k+1.

            //  Similarly, when PIVOT = 'B' (Bottom pivot), the rotation is
            //  performed for the plane (k,z), giving P(k) the form

            //     P(k) = ( 1                                             )
            //            (      ...                                      )
            //            (             1                                 )
            //            (                  c(k)                    s(k) )
            //            (                         1                     )
            //            (                              ...              )
            //            (                                     1         )
            //            (                 -s(k)                    c(k) )

            //  where R(k) appears in rows and columns k and z.  The rotations are
            //  performed without ever forming P(k) explicitly.

            //  Arguments
            //  =========

            //  SIDE    (input) CHARACTER*1
            //          Specifies whether the plane rotation matrix P is applied to
            //          A on the left or the right.
            //          = 'L':  Left, compute A := P*A
            //          = 'R':  Right, compute A:= A*P**T

            //  PIVOT   (input) CHARACTER*1
            //          Specifies the plane for which P(k) is a plane rotation
            //          matrix.
            //          = 'V':  Variable pivot, the plane (k,k+1)
            //          = 'T':  Top pivot, the plane (1,k+1)
            //          = 'B':  Bottom pivot, the plane (k,z)

            //  DIRECT  (input) CHARACTER*1
            //          Specifies whether P is a forward or backward sequence of
            //          plane rotations.
            //          = 'F':  Forward, P = P(z-1)*...*P(2)*P(1)
            //          = 'B':  Backward, P = P(1)*P(2)*...*P(z-1)

            //  M       (input) int
            //          The number of rows of the matrix A.  If m <= 1, an immediate
            //          return is effected.

            //  N       (input) int
            //          The number of columns of the matrix A.  If n <= 1, an
            //          immediate return is effected.

            //  C       (input) DOUBLE PRECISION array, dimension
            //                  (M-1) if SIDE = 'L'
            //                  (N-1) if SIDE = 'R'
            //          The cosines c(k) of the plane rotations.

            //  S       (input) DOUBLE PRECISION array, dimension
            //                  (M-1) if SIDE = 'L'
            //                  (N-1) if SIDE = 'R'
            //          The sines s(k) of the plane rotations.  The 2-by-2 plane
            //          rotation part of the matrix P(k), R(k), has the form
            //          R(k) = (  c(k)  s(k) )
            //                 ( -s(k)  c(k) ).

            //  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            //          The M-by-N matrix A.  On exit, A is overwritten by P*A if
            //          SIDE = 'R' or by A*P**T if SIDE = 'L'.

            //  LDA     (input) int
            //          The leading dimension of the array A.  LDA >= max(1,M).

            //  =====================================================================

            // System generated locals
            int a_dim1, a_offset, i__1, i__2;

            // Local variables
            int i, j, info;
            double temp;
            double ctemp, stemp;

            // Parameter adjustments
            --c;
            --s;
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;

            // Function Body
            info = 0;
            if (!(lsame(side, "L") || lsame(side, "R")))
            {
                info = 1;
            }
            else if (!(lsame(pivot, "V") || lsame(pivot, "T") || lsame(pivot, "B")))
            {
                info = 2;
            }
            else if (!(lsame(direct, "F") || lsame(direct, "B")))
            {
                info = 3;
            }
            else if (*m < 0)
            {
                info = 4;
            }
            else if (*n < 0)
            {
                info = 5;
            }
            else if (*lda < Math.Max(1, *m))
            {
                info = 9;
            }

            if (info != 0)
            {
                xerbla("DLASR ", &info);
                return 0;
            }

            // Quick return if possible

            if (*m == 0 || *n == 0)
            {
                return 0;
            }

            if (lsame(side, "L"))
            {
                // Form  P * A

                if (lsame(pivot, "V"))
                {
                    if (lsame(direct, "F"))
                    {
                        i__1 = *m - 1;
                        for (j = 1; j <= i__1; ++j)
                        {
                            ctemp = c[j];
                            stemp = s[j];
                            if (ctemp != 1.0 || stemp != 0.0)
                            {
                                i__2 = *n;
                                for (i = 1; i <= i__2; ++i)
                                {
                                    temp = a[j + 1 + i * a_dim1];
                                    a[j + 1 + i * a_dim1] = ctemp * temp - stemp * a[j + i * a_dim1];
                                    a[j + i * a_dim1] = stemp * temp + ctemp * a[j + i * a_dim1];
                                }
                            }
                        }
                    }
                    else if (lsame(direct, "B"))
                    {
                        for (j = *m - 1; j >= 1; --j)
                        {
                            ctemp = c[j];
                            stemp = s[j];
                            if (ctemp != 1.0 || stemp != 0.0)
                            {
                                i__1 = *n;
                                for (i = 1; i <= i__1; ++i)
                                {
                                    temp = a[j + 1 + i * a_dim1];
                                    a[j + 1 + i * a_dim1] = ctemp * temp - stemp * a[j + i * a_dim1];
                                    a[j + i * a_dim1] = stemp * temp + ctemp * a[j + i * a_dim1];
                                }
                            }
                        }
                    }
                }
                else if (lsame(pivot, "T"))
                {
                    if (lsame(direct, "F"))
                    {
                        i__1 = *m;
                        for (j = 2; j <= i__1; ++j)
                        {
                            ctemp = c[j - 1];
                            stemp = s[j - 1];
                            if (ctemp != 1.0 || stemp != 0.0)
                            {
                                i__2 = *n;
                                for (i = 1; i <= i__2; ++i)
                                {
                                    temp = a[j + i * a_dim1];
                                    a[j + i * a_dim1] = ctemp * temp - stemp * a[i * a_dim1 + 1];
                                    a[i * a_dim1 + 1] = stemp * temp + ctemp * a[i * a_dim1 + 1];
                                }
                            }
                        }
                    }
                    else if (lsame(direct, "B"))
                    {
                        for (j = *m; j >= 2; --j)
                        {
                            ctemp = c[j - 1];
                            stemp = s[j - 1];
                            if (ctemp != 1.0 || stemp != 0.0)
                            {
                                i__1 = *n;
                                for (i = 1; i <= i__1; ++i)
                                {
                                    temp = a[j + i * a_dim1];
                                    a[j + i * a_dim1] = ctemp * temp - stemp * a[i * a_dim1 + 1];
                                    a[i * a_dim1 + 1] = stemp * temp + ctemp * a[i * a_dim1 + 1];
                                }
                            }
                        }
                    }
                }
                else if (lsame(pivot, "B"))
                {
                    if (lsame(direct, "F"))
                    {
                        i__1 = *m - 1;
                        for (j = 1; j <= i__1; ++j)
                        {
                            ctemp = c[j];
                            stemp = s[j];
                            if (ctemp != 1.0 || stemp != 0.0)
                            {
                                i__2 = *n;
                                for (i = 1; i <= i__2; ++i)
                                {
                                    temp = a[j + i * a_dim1];
                                    a[j + i * a_dim1] = stemp * a[*m + i * a_dim1] + ctemp * temp;
                                    a[*m + i * a_dim1] = ctemp * a[*m + i * a_dim1] - stemp * temp;
                                }
                            }
                        }
                    }
                    else if (lsame(direct, "B"))
                    {
                        for (j = *m - 1; j >= 1; --j)
                        {
                            ctemp = c[j];
                            stemp = s[j];
                            if (ctemp != 1.0 || stemp != 0.0)
                            {
                                i__1 = *n;
                                for (i = 1; i <= i__1; ++i)
                                {
                                    temp = a[j + i * a_dim1];
                                    a[j + i * a_dim1] = stemp * a[*m + i * a_dim1] + ctemp * temp;
                                    a[*m + i * a_dim1] = ctemp * a[*m + i * a_dim1] - stemp * temp;
                                }
                            }
                        }
                    }
                }
            }
            else if (lsame(side, "R"))
            {
                // Form A * P'

                if (lsame(pivot, "V"))
                {
                    if (lsame(direct, "F"))
                    {
                        i__1 = *n - 1;
                        for (j = 1; j <= i__1; ++j)
                        {
                            ctemp = c[j];
                            stemp = s[j];
                            if (ctemp != 1.0 || stemp != 0.0)
                            {
                                i__2 = *m;
                                for (i = 1; i <= i__2; ++i)
                                {
                                    temp = a[i + (j + 1) * a_dim1];
                                    a[i + (j + 1) * a_dim1] = ctemp * temp - stemp * a[i + j * a_dim1];
                                    a[i + j * a_dim1] = stemp * temp + ctemp * a[i + j * a_dim1];
                                }
                            }
                        }
                    }
                    else if (lsame(direct, "B"))
                    {
                        for (j = *n - 1; j >= 1; --j)
                        {
                            ctemp = c[j];
                            stemp = s[j];
                            if (ctemp != 1.0 || stemp != 0.0)
                            {
                                i__1 = *m;
                                for (i = 1; i <= i__1; ++i)
                                {
                                    temp = a[i + (j + 1) * a_dim1];
                                    a[i + (j + 1) * a_dim1] = ctemp * temp - stemp * a[i + j * a_dim1];
                                    a[i + j * a_dim1] = stemp * temp + ctemp * a[i + j * a_dim1];
                                }
                            }
                        }
                    }
                }
                else if (lsame(pivot, "T"))
                {
                    if (lsame(direct, "F"))
                    {
                        i__1 = *n;
                        for (j = 2; j <= i__1; ++j)
                        {
                            ctemp = c[j - 1];
                            stemp = s[j - 1];
                            if (ctemp != 1.0 || stemp != 0.0)
                            {
                                i__2 = *m;
                                for (i = 1; i <= i__2; ++i)
                                {
                                    temp = a[i + j * a_dim1];
                                    a[i + j * a_dim1] = ctemp * temp - stemp * a[i + a_dim1];
                                    a[i + a_dim1] = stemp * temp + ctemp * a[i + a_dim1];
                                }
                            }
                        }
                    }
                    else if (lsame(direct, "B"))
                    {
                        for (j = *n; j >= 2; --j)
                        {
                            ctemp = c[j - 1];
                            stemp = s[j - 1];
                            if (ctemp != 1.0 || stemp != 0.0)
                            {
                                i__1 = *m;
                                for (i = 1; i <= i__1; ++i)
                                {
                                    temp = a[i + j * a_dim1];
                                    a[i + j * a_dim1] = ctemp * temp - stemp * a[i + a_dim1];
                                    a[i + a_dim1] = stemp * temp + ctemp * a[i + a_dim1];
                                }
                            }
                        }
                    }
                }
                else if (lsame(pivot, "B"))
                {
                    if (lsame(direct, "F"))
                    {
                        i__1 = *n - 1;
                        for (j = 1; j <= i__1; ++j)
                        {
                            ctemp = c[j];
                            stemp = s[j];
                            if (ctemp != 1.0 || stemp != 0.0)
                            {
                                i__2 = *m;
                                for (i = 1; i <= i__2; ++i)
                                {
                                    temp = a[i + j * a_dim1];
                                    a[i + j * a_dim1] = stemp * a[i + *n * a_dim1] + ctemp * temp;
                                    a[i + *n * a_dim1] = ctemp * a[i + *n * a_dim1] - stemp * temp;
                                }
                            }
                        }
                    }
                    else if (lsame(direct, "B"))
                    {
                        for (j = *n - 1; j >= 1; --j)
                        {
                            ctemp = c[j];
                            stemp = s[j];
                            if (ctemp != 1.0 || stemp != 0.0)
                            {
                                i__1 = *m;
                                for (i = 1; i <= i__1; ++i)
                                {
                                    temp = a[i + j * a_dim1];
                                    a[i + j * a_dim1] = stemp * a[i + *n * a_dim1] + ctemp * temp;
                                    a[i + *n * a_dim1] = ctemp * a[i + *n * a_dim1] - stemp * temp;
                                }
                            }
                        }
                    }
                }
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int dlasrt(string id, int* n, double* d, int* info)
        {
            //  -- LAPACK routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     November 2006

            //  Purpose
            //  =======

            //  Sort the numbers in D in increasing order (if ID = 'I') or
            //  in decreasing order (if ID = 'D' ).

            //  Use Quick Sort, reverting to Insertion sort on arrays of
            //  size <= 20.0 Dimension of STACK limits N to about 2**32.0

            //  Arguments
            //  =========

            //  ID      (input) CHARACTER*1
            //          = 'I': sort D in increasing order;
            //          = 'D': sort D in decreasing order.

            //  N       (input) INTEGER
            //          The length of the array D.

            //  D       (input/output) DOUBLE PRECISION array, dimension (N)
            //          On entry, the array to be sorted.
            //          On exit, D has been sorted into increasing order
            //          (D(1) <= ... <= D(N) ) or into decreasing order
            //          (D(1) >= ... >= D(N) ), depending on ID.

            //  INFO    (output) INTEGER
            //          = 0:  successful exit
            //          < 0:  if INFO = -i, the i-th argument had an illegal value

            //  =====================================================================

            // System generated locals
            int i__1, i__2;

            // Local variables
            int i, j;
            double d1, d2, d3;
            int dir;
            double tmp;
            int endd;
            int[] stack = new int[64]; // was [2][32]
            double dmnmx;
            int start;
            int stkpnt;

            // Parameter adjustments
            --d;

            // Function Body
            *info = 0;
            dir = -1;
            if (lsame(id, "D"))
            {
                dir = 0;
            }
            else if (lsame(id, "I"))
            {
                dir = 1;
            }
            if (dir == -1)
            {
                *info = -1;
            }
            else if (*n < 0)
            {
                *info = -2;
            }

            if (*info != 0)
            {
                i__1 = -(*info);
                xerbla("DLASRT", &i__1);
                return 0;
            }

            // Quick return if possible

            if (*n <= 1)
            {
                return 0;
            }

            stkpnt = 1;
            stack[0] = 1;
            stack[1] = *n;

        L10:
            start = stack[(stkpnt << 1) - 2];
            endd = stack[(stkpnt << 1) - 1];
            --stkpnt;
            if (endd - start <= 20 && endd - start > 0)
            {
                // Do Insertion sort on D( START:ENDD )

                if (dir == 0)
                {
                    // Sort into decreasing order

                    i__1 = endd;
                    for (i = start + 1; i <= i__1; ++i)
                    {
                        i__2 = start + 1;
                        for (j = i; j >= i__2; --j)
                        {
                            if (d[j] > d[j - 1])
                            {
                                dmnmx = d[j];
                                d[j] = d[j - 1];
                                d[j - 1] = dmnmx;
                            }
                            else
                            {
                                goto L30;
                            }
                        }
                    L30:
                        ;
                    }
                }
                else
                {
                    // Sort into increasing order

                    i__1 = endd;
                    for (i = start + 1; i <= i__1; ++i)
                    {
                        i__2 = start + 1;
                        for (j = i; j >= i__2; --j)
                        {
                            if (d[j] < d[j - 1])
                            {
                                dmnmx = d[j];
                                d[j] = d[j - 1];
                                d[j - 1] = dmnmx;
                            }
                            else
                            {
                                goto L50;
                            }
                        }
                    L50:
                        ;
                    }

                }
            }
            else if (endd - start > 20)
            {
                // Partition D( START:ENDD ) and stack parts, largest one first

                // Choose partition entry as median of 3

                d1 = d[start];
                d2 = d[endd];
                i = (start + endd) / 2;
                d3 = d[i];
                if (d1 < d2)
                {
                    if (d3 < d1)
                    {
                        dmnmx = d1;
                    }
                    else if (d3 < d2)
                    {
                        dmnmx = d3;
                    }
                    else
                    {
                        dmnmx = d2;
                    }
                }
                else
                {
                    if (d3 < d2)
                    {
                        dmnmx = d2;
                    }
                    else if (d3 < d1)
                    {
                        dmnmx = d3;
                    }
                    else
                    {
                        dmnmx = d1;
                    }
                }

                if (dir == 0)
                {
                    // Sort into decreasing order

                    i = start - 1;
                    j = endd + 1;
                L60:
                L70:
                    --j;
                    if (d[j] < dmnmx)
                    {
                        goto L70;
                    }
                L80:
                    ++i;
                    if (d[i] > dmnmx)
                    {
                        goto L80;
                    }
                    if (i < j)
                    {
                        tmp = d[i];
                        d[i] = d[j];
                        d[j] = tmp;
                        goto L60;
                    }
                    if (j - start > endd - j - 1)
                    {
                        ++stkpnt;
                        stack[(stkpnt << 1) - 2] = start;
                        stack[(stkpnt << 1) - 1] = j;
                        ++stkpnt;
                        stack[(stkpnt << 1) - 2] = j + 1;
                        stack[(stkpnt << 1) - 1] = endd;
                    }
                    else
                    {
                        ++stkpnt;
                        stack[(stkpnt << 1) - 2] = j + 1;
                        stack[(stkpnt << 1) - 1] = endd;
                        ++stkpnt;
                        stack[(stkpnt << 1) - 2] = start;
                        stack[(stkpnt << 1) - 1] = j;
                    }
                }
                else
                {
                    // Sort into increasing order

                    i = start - 1;
                    j = endd + 1;
                L90:
                L100:
                    --j;
                    if (d[j] > dmnmx)
                    {
                        goto L100;
                    }
                L110:
                    ++i;
                    if (d[i] < dmnmx)
                    {
                        goto L110;
                    }
                    if (i < j)
                    {
                        tmp = d[i];
                        d[i] = d[j];
                        d[j] = tmp;
                        goto L90;
                    }
                    if (j - start > endd - j - 1)
                    {
                        ++stkpnt;
                        stack[(stkpnt << 1) - 2] = start;
                        stack[(stkpnt << 1) - 1] = j;
                        ++stkpnt;
                        stack[(stkpnt << 1) - 2] = j + 1;
                        stack[(stkpnt << 1) - 1] = endd;
                    }
                    else
                    {
                        ++stkpnt;
                        stack[(stkpnt << 1) - 2] = j + 1;
                        stack[(stkpnt << 1) - 1] = endd;
                        ++stkpnt;
                        stack[(stkpnt << 1) - 2] = start;
                        stack[(stkpnt << 1) - 1] = j;
                    }
                }
            }
            if (stkpnt > 0)
            {
                goto L10;
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int dlassq(int* n, double* x, int* incx, double* scale, double* sumsq)
        {
            //  -- LAPACK auxiliary routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     November 2006

            //  Purpose
            //  =======

            //  DLASSQ  returns the values  scl  and  smsq  such that

            //     ( scl**2 )*smsq = x( 1 )**2 +...+ x( n )**2 + ( scale**2 )*sumsq,

            //  where  x( i ) = X( 1 + ( i - 1 )*INCX ). The value of  sumsq  is
            //  assumed to be non-negative and  scl  returns the value

            //     scl = max( scale, abs( x( i ) ) ).

            //  scale and sumsq must be supplied in SCALE and SUMSQ and
            //  scl and smsq are overwritten on SCALE and SUMSQ respectively.

            //  The routine makes only one pass through the vector x.

            //  Arguments
            //  =========

            //  N       (input) int
            //          The number of elements to be used from the vector X.

            //  X       (input) DOUBLE PRECISION array, dimension (N)
            //          The vector for which a scaled sum of squares is computed.
            //             x( i )  = X( 1 + ( i - 1 )*INCX ), 1 <= i <= n.

            //  INCX    (input) int
            //          The increment between successive values of the vector X.
            //          INCX > 0.

            //  SCALE   (input/output) DOUBLE PRECISION
            //          On entry, the value  scale  in the equation above.
            //          On exit, SCALE is overwritten with  scl , the scaling factor
            //          for the sum of squares.

            //  SUMSQ   (input/output) DOUBLE PRECISION
            //          On entry, the value  sumsq  in the equation above.
            //          On exit, SUMSQ is overwritten with  smsq , the basic sum of
            //          squares from which  scl  has been factored out.

            // =====================================================================

            // System generated locals
            int i__1, i__2;
            double d__1;

            // Local variables
            int ix;
            double absxi;

            // Parameter adjustments
            --x;

            // Function Body
            if (*n > 0)
            {
                i__1 = (*n - 1) * *incx + 1;
                i__2 = *incx;
                for (ix = 1; i__2 < 0 ? ix >= i__1 : ix <= i__1; ix += i__2)
                {
                    if (x[ix] != 0.0)
                    {
                        absxi = Math.Abs(x[ix]);
                        if (*scale < absxi)
                        {
                            // Computing 2nd power
                            d__1 = *scale / absxi;
                            *sumsq = *sumsq * (d__1 * d__1) + 1;
                            *scale = absxi;
                        }
                        else
                        {
                            // Computing 2nd power
                            d__1 = absxi / *scale;
                            *sumsq += d__1 * d__1;
                        }
                    }
                }
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int dlasv2(double* f, double* g, double* h,
            double* ssmin, double* ssmax, double* snr, double* csr, double* snl, double* csl)
        {
            //  -- LAPACK auxiliary routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     November 2006

            //  Purpose
            //  =======

            //  DLASV2 computes the singular value decomposition of a 2-by-2
            //  triangular matrix
            //     [  F   G  ]
            //     [  0   H  ].
            //  On return, abs(SSMAX) is the larger singular value, abs(SSMIN) is the
            //  smaller singular value, and (CSL,SNL) and (CSR,SNR) are the left and
            //  right singular vectors for abs(SSMAX), giving the decomposition

            //     [ CSL  SNL ] [  F   G  ] [ CSR -SNR ]  =  [ SSMAX   0   ]
            //     [-SNL  CSL ] [  0   H  ] [ SNR  CSR ]     [  0    SSMIN ].

            //  Arguments
            //  =========

            //  F       (input) DOUBLE PRECISION
            //          The (1,1) element of the 2-by-2 matrix.

            //  G       (input) DOUBLE PRECISION
            //          The (1,2) element of the 2-by-2 matrix.

            //  H       (input) DOUBLE PRECISION
            //          The (2,2) element of the 2-by-2 matrix.

            //  SSMIN   (output) DOUBLE PRECISION
            //          abs(SSMIN) is the smaller singular value.

            //  SSMAX   (output) DOUBLE PRECISION
            //          abs(SSMAX) is the larger singular value.

            //  SNL     (output) DOUBLE PRECISION
            //  CSL     (output) DOUBLE PRECISION
            //          The vector (CSL, SNL) is a unit left singular vector for the
            //          singular value abs(SSMAX).

            //  SNR     (output) DOUBLE PRECISION
            //  CSR     (output) DOUBLE PRECISION
            //          The vector (CSR, SNR) is a unit right singular vector for the
            //          singular value abs(SSMAX).

            //  Further Details
            //  ===============

            //  Any input parameter may be aliased with any output parameter.

            //  Barring over/underflow and assuming a guard digit in subtraction, all
            //  output quantities are correct to within a few units in the last
            //  place (ulps).

            //  In IEEE arithmetic, the code works correctly if one matrix element is
            //  infinite.

            //  Overflow will not occur unless the largest singular value itself
            //  overflows or is within a few ulps of overflow. (On machines with
            //  partial overflow, like the Cray, overflow may occur if the largest
            //  singular value is within a factor of 2 of overflow.)

            //  Underflow is harmless if underflow is gradual. Otherwise, results
            //  may correspond to a matrix modified by perturbations of size near
            //  the underflow threshold.

            // =====================================================================

            // System generated locals
            double d__1;

            // Table of constant values
            double c_b3 = 2.0;
            double c_b4 = 1.0;

            // Local variables
            double a, d, l, m, r, s, t, fa, ga, ha, ft, gt, ht, mm, tt, clt = 0, crt = 0, slt = 0, srt = 0;
            int pmax;
            double temp;
            bool swap;
            double tsign;
            bool gasmal;

            ft = *f;
            fa = Math.Abs(ft);
            ht = *h;
            ha = Math.Abs(*h);

            // PMAX points to the maximum absolute element of matrix
            //   PMAX = 1 if F largest in absolute values
            //   PMAX = 2 if G largest in absolute values
            //   PMAX = 3 if H largest in absolute values

            pmax = 1;
            swap = ha > fa;
            if (swap)
            {
                pmax = 3;
                temp = ft;
                ft = ht;
                ht = temp;
                temp = fa;
                fa = ha;
                ha = temp;

                // Now FA .ge. HA
            }
            gt = *g;
            ga = Math.Abs(gt);
            if (ga == 0.0)
            {
                // Diagonal matrix

                *ssmin = ha;
                *ssmax = fa;
                clt = 1.0;
                crt = 1.0;
                slt = 0.0;
                srt = 0.0;
            }
            else
            {
                gasmal = true;
                if (ga > fa)
                {
                    pmax = 2;
                    if (fa / ga < dlamch("EPS"))
                    {
                        // Case of very large GA

                        gasmal = false;
                        *ssmax = ga;
                        if (ha > 1.0)
                        {
                            *ssmin = fa / (ga / ha);
                        }
                        else
                        {
                            *ssmin = fa / ga * ha;
                        }
                        clt = 1.0;
                        slt = ht / gt;
                        srt = 1.0;
                        crt = ft / gt;
                    }
                }
                if (gasmal)
                {
                    // Normal case

                    d = fa - ha;
                    if (d == fa)
                    {
                        // Copes with infinite F or H

                        l = 1.0;
                    }
                    else
                    {
                        l = d / fa;
                    }

                    // Note that 0 .le. L .le. 1

                    m = gt / ft;

                    // Note that abs(M) .le. 1/macheps

                    t = 2.0 - l;

                    // Note that T .ge. 1

                    mm = m * m;
                    tt = t * t;
                    s = Math.Sqrt(tt + mm);

                    // Note that 1 .le. S .le. 1 + 1/macheps

                    if (l == 0.0)
                    {
                        r = Math.Abs(m);
                    }
                    else
                    {
                        r = Math.Sqrt(l * l + mm);
                    }

                    // Note that 0 .le. R .le. 1 + 1/macheps

                    a = (s + r) * 0.5;

                    // Note that 1 .le. A .le. 1 + abs(M)

                    *ssmin = ha / a;
                    *ssmax = fa * a;
                    if (mm == 0.0)
                    {
                        // Note that M is very tiny

                        if (l == 0.0)
                        {
                            t = d_sign(&c_b3, &ft) * d_sign(&c_b4, &gt);
                        }
                        else
                        {
                            t = gt / d_sign(&d, &ft) + m / t;
                        }
                    }
                    else
                    {
                        t = (m / (s + t) + m / (r + l)) * (a + 1.0);
                    }
                    l = Math.Sqrt(t * t + 4.0);
                    crt = 2.0 / l;
                    srt = t / l;
                    clt = (crt + srt * m) / a;
                    slt = ht / ft * srt / a;
                }
            }

            if (swap)
            {
                *csl = srt;
                *snl = crt;
                *csr = slt;
                *snr = clt;
            }
            else
            {
                *csl = clt;
                *snl = slt;
                *csr = crt;
                *snr = srt;
            }

            // Correct signs of SSMAX and SSMIN

            if (pmax == 1)
            {
                tsign = d_sign(&c_b4, csr) * d_sign(&c_b4, csl) * d_sign(&c_b4, f);
            }
            if (pmax == 2)
            {
                tsign = d_sign(&c_b4, snr) * d_sign(&c_b4, csl) * d_sign(&c_b4, g);
            }
            if (pmax == 3)
            {
                tsign = d_sign(&c_b4, snr) * d_sign(&c_b4, snl) * d_sign(&c_b4, h);
            }

            *ssmax = d_sign(ssmax, &tsign);
            d__1 = tsign * d_sign(&c_b4, f) * d_sign(&c_b4, h);
            *ssmin = d_sign(ssmin, &d__1);

            return 0;
        }

        #endregion

        #region Double precision complex routines

        [SuppressUnmanagedCodeSecurity]
        public static int zdrscl(int* n, double* sa, complex16* sx, int* incx)
        {
            //  -- LAPACK auxiliary routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. 
            //     November 2006 

            //  Purpose 
            //  ======= 

            //  ZDRSCL multiplies an n-element complex vector x by the real scalar 
            //  1/a.  This is done without overflow or underflow as int as 
            //  the final result x/a does not overflow or underflow. 

            //  Arguments 
            //  ========= 

            //  N       (input) int 
            //          The number of components of the vector x. 

            //  SA      (input) DOUBLE PRECISION 
            //          The scalar a which is used to divide each component of x. 
            //          SA must be >= 0, or the subroutine will divide by zero. 

            //  SX      (input/output) COMPLEX*16 array, dimension 
            //                         (1+(N-1)*abs(INCX)) 
            //          The n-element vector x. 

            //  INCX    (input) int 
            //          The increment between successive values of the vector SX. 
            //          > 0:  SX(1) = X(1) and SX(1+(i-1)*INCX) = x(i),     1< i<= n 

            // ===================================================================== 

            // Local variables
            double mul, cden;
            bool done;
            double cnum, cden1, cnum1;
            double bignum, smlnum;

            // Parameter adjustments 
            --sx;

            // Function Body 
            if (*n <= 0)
            {
                return 0;
            }

            // Get machine parameters 

            smlnum = dlamch("S");
            bignum = 1.0 / smlnum;
            dlabad(&smlnum, &bignum);

            // Initialize the denominator to SA and the numerator to 1. 

            cden = *sa;
            cnum = 1.0;

        L10:
            cden1 = cden * smlnum;
            cnum1 = cnum / bignum;

            if (Math.Abs(cden1) > Math.Abs(cnum) && cnum != 0.0)
            {
                // Pre-multiply X by SMLNUM if CDEN is large compared to CNUM. 

                mul = smlnum;
                done = false;
                cden = cden1;
            }
            else if (Math.Abs(cnum1) > Math.Abs(cden))
            {
                // Pre-multiply X by BIGNUM if CDEN is small compared to CNUM. 

                mul = bignum;
                done = false;
                cnum = cnum1;
            }
            else
            {
                // Multiply X by CNUM / CDEN and return. 

                mul = cnum / cden;
                done = true;
            }

            // Scale the vector X by MUL 

            zdscal(n, &mul, &sx[1], incx);

            if (!done)
            {
                goto L10;
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zgebak(string job, string side, int* n, int* ilo,
            int* ihi, double* scale, int* m, complex16* v, int* ldv, int* info)
        {
            //  -- LAPACK routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. 
            //     November 2006 

            //  Purpose 
            //  ======= 

            //  ZGEBAK forms the right or left eigenvectors of a complex general 
            //  matrix by backward transformation on the computed eigenvectors of the 
            //  balanced matrix output by ZGEBAL. 

            //  Arguments 
            //  ========= 

            //  JOB     (input) CHARACTER*1 
            //          Specifies the type of backward transformation required: 
            //          = 'N', do nothing, return immediately; 
            //          = 'P', do backward transformation for permutation only; 
            //          = 'S', do backward transformation for scaling only; 
            //          = 'B', do backward transformations for both permutation and 
            //                 scaling. 
            //          JOB must be the same as the argument JOB supplied to ZGEBAL. 

            //  SIDE    (input) CHARACTER*1 
            //          = 'R':  V contains right eigenvectors; 
            //          = 'L':  V contains left eigenvectors. 

            //  N       (input) INTEGER 
            //          The number of rows of the matrix V.  N >= 0. 

            //  ILO     (input) INTEGER 
            //  IHI     (input) INTEGER 
            //          The integers ILO and IHI determined by ZGEBAL. 
            //          1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0. 

            //  SCALE   (input) DOUBLE PRECISION array, dimension (N) 
            //          Details of the permutation and scaling factors, as returned 
            //          by ZGEBAL. 

            //  M       (input) INTEGER 
            //          The number of columns of the matrix V.  M >= 0. 

            //  V       (input/output) COMPLEX*16 array, dimension (LDV,M) 
            //          On entry, the matrix of right or left eigenvectors to be 
            //          transformed, as returned by ZHSEIN or ZTREVC. 
            //          On exit, V is overwritten by the transformed eigenvectors. 

            //  LDV     (input) INTEGER 
            //          The leading dimension of the array V. LDV >= max(1,N). 

            //  INFO    (output) INTEGER 
            //          = 0:  successful exit 
            //          < 0:  if INFO = -i, the i-th argument had an illegal value. 

            //  ===================================================================== 

            // System generated locals 
            int v_dim1, v_offset, i__1;

            // Local variables 
            int i, k;
            double s;
            int ii;
            bool leftv;
            bool rightv;

            // Parameter adjustments 
            --scale;
            v_dim1 = *ldv;
            v_offset = 1 + v_dim1;
            v -= v_offset;

            // Function Body 
            rightv = lsame(side, "R");
            leftv = lsame(side, "L");

            *info = 0;
            if (!lsame(job, "N") && !lsame(job, "P") && !lsame(job, "S") && !lsame(job, "B"))
            {
                *info = -1;
            }
            else if (!rightv && !leftv)
            {
                *info = -2;
            }
            else if (*n < 0)
            {
                *info = -3;
            }
            else if (*ilo < 1 || *ilo > Math.Max(1, *n))
            {
                *info = -4;
            }
            else if (*ihi < Math.Min(*ilo, *n) || *ihi > *n)
            {
                *info = -5;
            }
            else if (*m < 0)
            {
                *info = -7;
            }
            else if (*ldv < Math.Max(1, *n))
            {
                *info = -9;
            }

            if (*info != 0)
            {
                i__1 = -(*info);
                xerbla("ZGEBAK", &i__1);
                return 0;
            }

            // Quick return if possible 

            if (*n == 0)
            {
                return 0;
            }
            if (*m == 0)
            {
                return 0;
            }
            if (lsame(job, "N"))
            {
                return 0;
            }

            if (*ilo == *ihi)
            {
                goto L30;
            }

            // Backward balance 

            if (lsame(job, "S") || lsame(job, "B"))
            {
                if (rightv)
                {
                    i__1 = *ihi;
                    for (i = *ilo; i <= i__1; ++i)
                    {
                        s = scale[i];
                        zdscal(m, &s, &v[i + v_dim1], ldv);
                    }
                }

                if (leftv)
                {
                    i__1 = *ihi;
                    for (i = *ilo; i <= i__1; ++i)
                    {
                        s = 1.0 / scale[i];
                        zdscal(m, &s, &v[i + v_dim1], ldv);
                    }
                }
            }

            // Backward permutation 

            // For  I = ILO-1 step -1 until 1, 
        // IHI+1 step 1 until N do -- 

            L30:
            if (lsame(job, "P") || lsame(job, "B"))
            {
                if (rightv)
                {
                    i__1 = *n;
                    for (ii = 1; ii <= i__1; ++ii)
                    {
                        i = ii;
                        if (i >= *ilo && i <= *ihi)
                        {
                            goto L40;
                        }
                        if (i < *ilo)
                        {
                            i = *ilo - ii;
                        }
                        k = (int)scale[i];
                        if (k == i)
                        {
                            goto L40;
                        }
                        zswap(m, &v[i + v_dim1], ldv, &v[k + v_dim1], ldv);

                    L40:
                        ;
                    }
                }

                if (leftv)
                {
                    i__1 = *n;
                    for (ii = 1; ii <= i__1; ++ii)
                    {
                        i = ii;
                        if (i >= *ilo && i <= *ihi)
                        {
                            goto L50;
                        }
                        if (i < *ilo)
                        {
                            i = *ilo - ii;
                        }
                        k = (int)scale[i];
                        if (k == i)
                        {
                            goto L50;
                        }
                        zswap(m, &v[i + v_dim1], ldv, &v[k + v_dim1], ldv);

                    L50:
                        ;
                    }
                }
            }

            return 0;

            // End of ZGEBAK 
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zgebal(string job, int* n, complex16* a, int* lda, int* ilo, int* ihi, double* scale, int* info)
        {
            //  -- LAPACK routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. 
            //     November 2006 

            //  Purpose 
            //  ======= 

            //  ZGEBAL balances a general complex matrix A.  This involves, first, 
            //  permuting A by a similarity transformation to isolate eigenvalues 
            //  in the first 1 to ILO-1 and last IHI+1 to N elements on the 
            //  diagonal; and second, applying a diagonal similarity transformation 
            //  to rows and columns ILO to IHI to make the rows and columns as 
            //  close in norm as possible.  Both steps are optional. 

            //  Balancing may reduce the 1-norm of the matrix, and improve the 
            //  accuracy of the computed eigenvalues and/or eigenvectors. 

            //  Arguments 
            //  ========= 

            //  JOB     (input) CHARACTER*1 
            //          Specifies the operations to be performed on A: 
            //          = 'N':  none:  simply set ILO = 1, IHI = N, SCALE(I) = 1.0 
            //                  for i = 1,...,N; 
            //          = 'P':  permute only; 
            //          = 'S':  scale only; 
            //          = 'B':  both permute and scale. 

            //  N       (input) int 
            //          The order of the matrix A.  N >= 0. 

            //  A       (input/output) COMPLEX*16 array, dimension (LDA,N) 
            //          On entry, the input matrix A. 
            //          On exit,  A is overwritten by the balanced matrix. 
            //          If JOB = 'N', A is not referenced. 
            //          See Further Details. 

            //  LDA     (input) int 
            //          The leading dimension of the array A.  LDA >= max(1,N). 

            //  ILO     (output) int 
            //  IHI     (output) int 
            //          ILO and IHI are set to ints such that on exit 
            //          A(i,j) = 0 if i > j and j = 1,...,ILO-1 or I = IHI+1,...,N. 
            //          If JOB = 'N' or 'S', ILO = 1 and IHI = N. 

            //  SCALE   (output) DOUBLE PRECISION array, dimension (N) 
            //          Details of the permutations and scaling factors applied to 
            //          A.  If P(j) is the index of the row and column interchanged 
            //          with row and column j and D(j) is the scaling factor 
            //          applied to row and column j, then 
            //          SCALE(j) = P(j)    for j = 1,...,ILO-1 
            //                   = D(j)    for j = ILO,...,IHI 
            //                   = P(j)    for j = IHI+1,...,N. 
            //          The order in which the interchanges are made is N to IHI+1, 
            //          then 1 to ILO-1. 

            //  INFO    (output) int 
            //          = 0:  successful exit. 
            //          < 0:  if INFO = -i, the i-th argument had an illegal value. 

            //  Further Details 
            //  =============== 

            //  The permutations consist of row and column interchanges which put 
            //  the matrix in the form 

            //             ( T1   X   Y  ) 
            //     P A P = (  0   B   Z  ) 
            //             (  0   0   T2 ) 

            //  where T1 and T2 are upper triangular matrices whose eigenvalues lie 
            //  aint the diagonal.  The column indices ILO and IHI mark the starting 
            //  and ending columns of the submatrix B. Balancing consists of applying 
            //  a diagonal similarity transformation inv(D) * B * D to make the 
            //  1-norms of each row of B and its corresponding column nearly equal. 
            //  The output matrix is 

            //     ( T1     X*D          Y    ) 
            //     (  0  inv(D)*B*D  inv(D)*Z ). 
            //     (  0      0           T2   ) 

            //  Information about the permutations P and the diagonal matrix D is 
            //  returned in the vector SCALE. 

            //  This subroutine is based on the EISPACK routine CBAL. 

            //  Modified by Tzu-Yi Chen, Computer Science Division, University of 
            //    California at Berkeley, USA 

            //  ===================================================================== 

            // System generated locals 
            int a_dim1, a_offset, i__1, i__2, i__3;
            double d__1, d__2;

            // Table of constant values
            int c__1 = 1;

            // Local variables 
            double c, f, g;
            int i, j, k, l, m;
            double r, s, ca, ra;
            int ica, ira, iexc;
            double sfmin1, sfmin2, sfmax1, sfmax2;
            bool noconv;

            // Parameter adjustments 
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;
            --scale;

            // Function Body 
            *info = 0;
            if (!lsame(job, "N") && !lsame(job, "P") && !lsame(job, "S") && !lsame(job, "B"))
            {
                *info = -1;
            }
            else if (*n < 0)
            {
                *info = -2;
            }
            else if (*lda < Math.Max(1, *n))
            {
                *info = -4;
            }
            if (*info != 0)
            {
                i__1 = -(*info);
                xerbla("ZGEBAL", &i__1);
                return 0;
            }

            k = 1;
            l = *n;

            if (*n == 0)
            {
                goto L210;
            }

            if (lsame(job, "N"))
            {
                i__1 = *n;
                for (i = 1; i <= i__1; ++i)
                {
                    scale[i] = 1.0;
                }
                goto L210;
            }

            if (lsame(job, "S"))
            {
                goto L120;
            }

            // Permutation to isolate eigenvalues if possible 

            goto L50;

            // Row and column exchange. 

            L20:
            scale[m] = (double)j;
            if (j == m)
            {
                goto L30;
            }

            zswap(&l, &a[j * a_dim1 + 1], &c__1, &a[m * a_dim1 + 1], &c__1);
            i__1 = *n - k + 1;
            zswap(&i__1, &a[j + k * a_dim1], lda, &a[m + k * a_dim1], lda);

        L30:
            switch (iexc)
            {
                case 1: goto L40;
                case 2: goto L80;
            }

            // Search for rows isolating an eigenvalue and push them down. 

            L40:
            if (l == 1)
            {
                goto L210;
            }
            --l;

        L50:
            for (j = l; j >= 1; --j)
            {
                i__1 = l;
                for (i = 1; i <= i__1; ++i)
                {
                    if (i == j)
                    {
                        goto L60;
                    }
                    i__2 = j + i * a_dim1;
                    if (a[i__2].r != 0.0 || d_imag(&a[j + i * a_dim1]) != 0.0)
                    {
                        goto L70;
                    }
                L60:
                    ;
                }

                m = l;
                iexc = 1;
                goto L20;

            L70:
                ;
            }

            goto L90;

            // Search for columns isolating an eigenvalue and push them left. 

            L80:
            ++k;

        L90:
            i__1 = l;
            for (j = k; j <= i__1; ++j)
            {
                i__2 = l;
                for (i = k; i <= i__2; ++i)
                {
                    if (i == j)
                    {
                        goto L100;
                    }
                    i__3 = i + j * a_dim1;
                    if (a[i__3].r != 0.0 || d_imag(&a[i + j * a_dim1]) != 0.0)
                    {
                        goto L110;
                    }
                L100:
                    ;
                }

                m = k;
                iexc = 2;
                goto L20;
            L110:
                ;
            }

        L120:
            i__1 = l;
            for (i = k; i <= i__1; ++i)
            {
                scale[i] = 1.0;
            }

            if (lsame(job, "P"))
            {
                goto L210;
            }

            // Balance the submatrix in rows K to L. 

            // Iterative loop for norm reduction 

            sfmin1 = dlamch("S") / dlamch("P");
            sfmax1 = 1.0 / sfmin1;
            sfmin2 = sfmin1 * 2.0;
            sfmax2 = 1.0 / sfmin2;

        L140:
            noconv = false;

            i__1 = l;
            for (i = k; i <= i__1; ++i)
            {
                c = 0.0;
                r = 0.0;

                i__2 = l;
                for (j = k; j <= i__2; ++j)
                {
                    if (j == i)
                    {
                        goto L150;
                    }

                    i__3 = j + i * a_dim1;
                    c += Math.Abs(a[i__3].r) + Math.Abs(d_imag(&a[j + i * a_dim1]));
                    i__3 = i + j * a_dim1;
                    r += Math.Abs(a[i__3].r) + Math.Abs(d_imag(&a[i + j * a_dim1]));
                L150:
                    ;
                }

                ica = izamax(&l, &a[i * a_dim1 + 1], &c__1);
                ca = z_abs(&a[ica + i * a_dim1]);
                i__2 = *n - k + 1;
                ira = izamax(&i__2, &a[i + k * a_dim1], lda);
                ra = z_abs(&a[i + (ira + k - 1) * a_dim1]);

                // Guard against zero C or R due to underflow. 

                if (c == 0.0 || r == 0.0)
                {
                    goto L200;
                }

                g = r / 2.0;
                f = 1.0;
                s = c + r;

            L160:
                // Computing MAX 
                d__1 = Math.Max(f, c);
                // Computing MIN 
                d__2 = Math.Min(r, g);

                if (c >= g || Math.Max(d__1, ca) >= sfmax2 || Math.Min(d__2, ra) <= sfmin2)
                {
                    goto L170;
                }

                f *= 2.0;
                c *= 2.0;
                ca *= 2.0;
                r /= 2.0;
                g /= 2.0;
                ra /= 2.0;
                goto L160;

            L170:
                g = c / 2.0;

            L180:
                // Computing MIN 
                d__1 = Math.Min(f, c);
                d__1 = Math.Min(d__1, g);
                if (g < r || Math.Max(r, ra) >= sfmax2 || Math.Min(d__1, ca) <= sfmin2)
                {
                    goto L190;
                }

                f /= 2.0;
                c /= 2.0;
                g /= 2.0;
                ca /= 2.0;
                r *= 2.0;
                ra *= 2.0;
                goto L180;

                // Now balance. 

                L190:
                if (c + r >= s * 0.95)
                {
                    goto L200;
                }
                if (f < 1.0 && scale[i] < 1.0)
                {
                    if (f * scale[i] <= sfmin1)
                    {
                        goto L200;
                    }
                }
                if (f > 1.0 && scale[i] > 1.0)
                {
                    if (scale[i] >= sfmax1 / f)
                    {
                        goto L200;
                    }
                }
                g = 1.0 / f;
                scale[i] *= f;
                noconv = true;

                i__2 = *n - k + 1;
                zdscal(&i__2, &g, &a[i + k * a_dim1], lda);
                zdscal(&l, &f, &a[i * a_dim1 + 1], &c__1);

            L200:
                ;
            }

            if (noconv)
            {
                goto L140;
            }

        L210:
            *ilo = k;
            *ihi = l;

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zgebd2(int* m, int* n, complex16* a, int* lda,
            double* d, double* e, complex16* tauq, complex16* taup, complex16* work, int* info)
        {
            //  -- LAPACK routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     November 2006

            //  Purpose
            //  =======

            //  ZGEBD2 reduces a complex general m by n matrix A to upper or lower
            //  real bidiagonal form B by a unitary transformation: Q' * A * P = B.

            //  If m >= n, B is upper bidiagonal; if m < n, B is lower bidiagonal.

            //  Arguments
            //  =========

            //  M       (input) int
            //          The number of rows in the matrix A.  M >= 0.

            //  N       (input) int
            //          The number of columns in the matrix A.  N >= 0.

            //  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
            //          On entry, the m by n general matrix to be reduced.
            //          On exit,
            //          if m >= n, the diagonal and the first superdiagonal are
            //            overwritten with the upper bidiagonal matrix B; the
            //            elements below the diagonal, with the array TAUQ, represent
            //            the unitary matrix Q as a product of elementary
            //            reflectors, and the elements above the first superdiagonal,
            //            with the array TAUP, represent the unitary matrix P as
            //            a product of elementary reflectors;
            //          if m < n, the diagonal and the first subdiagonal are
            //            overwritten with the lower bidiagonal matrix B; the
            //            elements below the first subdiagonal, with the array TAUQ,
            //            represent the unitary matrix Q as a product of
            //            elementary reflectors, and the elements above the diagonal,
            //            with the array TAUP, represent the unitary matrix P as
            //            a product of elementary reflectors.
            //          See Further Details.

            //  LDA     (input) int
            //          The leading dimension of the array A.  LDA >= max(1,M).

            //  D       (output) DOUBLE PRECISION array, dimension (min(M,N))
            //          The diagonal elements of the bidiagonal matrix B:
            //          D(i) = A(i,i).

            //  E       (output) DOUBLE PRECISION array, dimension (min(M,N)-1)
            //          The off-diagonal elements of the bidiagonal matrix B:
            //          if m >= n, E(i) = A(i,i+1) for i = 1,2,...,n-1;
            //          if m < n, E(i) = A(i+1,i) for i = 1,2,...,m-1.

            //  TAUQ    (output) COMPLEX*16 array dimension (min(M,N))
            //          The scalar factors of the elementary reflectors which
            //          represent the unitary matrix Q. See Further Details.

            //  TAUP    (output) COMPLEX*16 array, dimension (min(M,N))
            //          The scalar factors of the elementary reflectors which
            //          represent the unitary matrix P. See Further Details.

            //  WORK    (workspace) COMPLEX*16 array, dimension (max(M,N))

            //  INFO    (output) int
            //          = 0: successful exit
            //          < 0: if INFO = -i, the i-th argument had an illegal value.

            //  Further Details
            //  ===============

            //  The matrices Q and P are represented as products of elementary
            //  reflectors:

            //  If m >= n,

            //     Q = H(1) H(2) . . . H(n)  and  P = G(1) G(2) . . . G(n-1)

            //  Each H(i) and G(i) has the form:

            //     H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'

            //  where tauq and taup are complex scalars, and v and u are complex
            //  vectors; v(1:i-1) = 0, v(i) = 1, and v(i+1:m) is stored on exit in
            //  A(i+1:m,i); u(1:i) = 0, u(i+1) = 1, and u(i+2:n) is stored on exit in
            //  A(i,i+2:n); tauq is stored in TAUQ(i) and taup in TAUP(i).

            //  If m < n,

            //     Q = H(1) H(2) . . . H(m-1)  and  P = G(1) G(2) . . . G(m)

            //  Each H(i) and G(i) has the form:

            //     H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'

            //  where tauq and taup are complex scalars, v and u are complex vectors;
            //  v(1:i) = 0, v(i+1) = 1, and v(i+2:m) is stored on exit in A(i+2:m,i);
            //  u(1:i-1) = 0, u(i) = 1, and u(i+1:n) is stored on exit in A(i,i+1:n);
            //  tauq is stored in TAUQ(i) and taup in TAUP(i).

            //  The contents of A on exit are illustrated by the following examples:

            //  m = 6 and n = 5 (m > n):          m = 5 and n = 6 (m < n):

            //    (  d   e   u1  u1  u1 )           (  d   u1  u1  u1  u1  u1 )
            //    (  v1  d   e   u2  u2 )           (  e   d   u2  u2  u2  u2 )
            //    (  v1  v2  d   e   u3 )           (  v1  e   d   u3  u3  u3 )
            //    (  v1  v2  v3  d   e  )           (  v1  v2  e   d   u4  u4 )
            //    (  v1  v2  v3  v4  d  )           (  v1  v2  v3  e   d   u5 )
            //    (  v1  v2  v3  v4  v5 )

            //  where d and e denote diagonal and off-diagonal elements of B, vi
            //  denotes an element of the vector defining H(i), and ui an element of
            //  the vector defining G(i).

            //  =====================================================================

            // System generated locals
            int a_dim1, a_offset, i__1, i__2, i__3;
            complex16 z__1;

            // Table of constant values
            int c__1 = 1;

            // Local variables
            int i;
            complex16 alpha;

            // Parameter adjustments
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;
            --d;
            --e;
            --tauq;
            --taup;
            --work;

            // Function Body
            *info = 0;
            if (*m < 0)
            {
                *info = -1;
            }
            else if (*n < 0)
            {
                *info = -2;
            }
            else if (*lda < Math.Max(1, *m))
            {
                *info = -4;
            }

            if (*info < 0)
            {
                i__1 = -(*info);
                xerbla("ZGEBD2", &i__1);
                return 0;
            }

            if (*m >= *n)
            {
                // Reduce to upper bidiagonal form

                i__1 = *n;
                for (i = 1; i <= i__1; ++i)
                {
                    // Generate elementary reflector H(i) to annihilate A(i+1:m,i)

                    i__2 = i + i * a_dim1;

                    alpha.r = a[i__2].r;
                    alpha.i = a[i__2].i;

                    i__2 = *m - i + 1;
                    // Computing MIN
                    i__3 = i + 1;
                    zlarfg(&i__2, &alpha, &a[Math.Min(i__3, *m) + i * a_dim1], &c__1, &tauq[i]);
                    i__2 = i;
                    d[i__2] = alpha.r;
                    i__2 = i + i * a_dim1;

                    a[i__2].r = 1.0;
                    a[i__2].i = 0.0;

                    // Apply H(i)' to A(i:m,i+1:n) from the left

                    if (i < *n)
                    {
                        i__2 = *m - i + 1;
                        i__3 = *n - i;
                        d_cnjg(&z__1, &tauq[i]);
                        zlarf("Left", &i__2, &i__3, &a[i + i * a_dim1],
                            &c__1, &z__1, &a[i + (i + 1) * a_dim1], lda, &work[1]);
                    }

                    i__2 = i + i * a_dim1;
                    i__3 = i;
                    a[i__2].r = d[i__3];
                    a[i__2].i = 0.0;

                    if (i < *n)
                    {
                        // Generate elementary reflector G(i) to annihilate
                        // A(i,i+2:n)

                        i__2 = *n - i;
                        zlacgv(&i__2, &a[i + (i + 1) * a_dim1], lda);
                        i__2 = i + (i + 1) * a_dim1;

                        alpha.r = a[i__2].r;
                        alpha.i = a[i__2].i;

                        i__2 = *n - i;
                        // Computing MIN
                        i__3 = i + 2;
                        zlarfg(&i__2, &alpha, &a[i + Math.Min(i__3, *n) * a_dim1], lda, &taup[i]);
                        i__2 = i;
                        e[i__2] = alpha.r;
                        i__2 = i + (i + 1) * a_dim1;

                        a[i__2].r = 1.0;
                        a[i__2].i = 0.0;

                        // Apply G(i) to A(i+1:m,i+1:n) from the right

                        i__2 = *m - i;
                        i__3 = *n - i;

                        zlarf("Right", &i__2, &i__3, &a[i + (i + 1) * a_dim1],
                            lda, &taup[i], &a[i + 1 + (i + 1) * a_dim1], lda, &work[1]);

                        i__2 = *n - i;
                        zlacgv(&i__2, &a[i + (i + 1) * a_dim1], lda);
                        i__2 = i + (i + 1) * a_dim1;
                        i__3 = i;

                        a[i__2].r = e[i__3];
                        a[i__2].i = 0.0;
                    }
                    else
                    {
                        i__2 = i;
                        taup[i__2].r = 0.0;
                        taup[i__2].i = 0.0;
                    }
                }
            }
            else
            {
                // Reduce to lower bidiagonal form

                i__1 = *m;
                for (i = 1; i <= i__1; ++i)
                {
                    // Generate elementary reflector G(i) to annihilate A(i,i+1:n)

                    i__2 = *n - i + 1;
                    zlacgv(&i__2, &a[i + i * a_dim1], lda);
                    i__2 = i + i * a_dim1;

                    alpha.r = a[i__2].r;
                    alpha.i = a[i__2].i;

                    i__2 = *n - i + 1;
                    // Computing MIN
                    i__3 = i + 1;
                    zlarfg(&i__2, &alpha, &a[i + Math.Min(i__3, *n) * a_dim1], lda, &taup[i]);
                    i__2 = i;
                    d[i__2] = alpha.r;
                    i__2 = i + i * a_dim1;

                    a[i__2].r = 1.0;
                    a[i__2].i = 0.0;

                    // Apply G(i) to A(i+1:m,i:n) from the right

                    if (i < *m)
                    {
                        i__2 = *m - i;
                        i__3 = *n - i + 1;
                        zlarf("Right", &i__2, &i__3, &a[i + i * a_dim1], lda,
                            &taup[i], &a[i + 1 + i * a_dim1], lda, &work[1]);
                    }

                    i__2 = *n - i + 1;
                    zlacgv(&i__2, &a[i + i * a_dim1], lda);
                    i__2 = i + i * a_dim1;
                    i__3 = i;
                    a[i__2].r = d[i__3];
                    a[i__2].i = 0.0;

                    if (i < *m)
                    {
                        // Generate elementary reflector H(i) to annihilate
                        // A(i+2:m,i)

                        i__2 = i + 1 + i * a_dim1;
                        alpha.r = a[i__2].r;
                        alpha.i = a[i__2].i;
                        i__2 = *m - i;

                        // Computing MIN
                        i__3 = i + 2;
                        zlarfg(&i__2, &alpha, &a[Math.Min(i__3, *m) + i * a_dim1], &c__1, &tauq[i]);
                        i__2 = i;
                        e[i__2] = alpha.r;
                        i__2 = i + 1 + i * a_dim1;
                        a[i__2].r = 1.0;
                        a[i__2].i = 0.0;

                        // Apply H(i)' to A(i+1:m,i+1:n) from the left

                        i__2 = *m - i;
                        i__3 = *n - i;
                        d_cnjg(&z__1, &tauq[i]);
                        zlarf("Left", &i__2, &i__3, &a[i + 1 + i * a_dim1],
                            &c__1, &z__1, &a[i + 1 + (i + 1) * a_dim1], lda, &work[1]);

                        i__2 = i + 1 + i * a_dim1;
                        i__3 = i;
                        a[i__2].r = e[i__3];
                        a[i__2].i = 0.0;
                    }
                    else
                    {
                        i__2 = i;
                        tauq[i__2].r = 0.0;
                        tauq[i__2].i = 0.0;
                    }
                }
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zgebrd(int* m, int* n, complex16* a, int* lda, double* d,
            double* e, complex16* tauq, complex16* taup, complex16* work, int* lwork, int* info)
        {
            //  -- LAPACK routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     November 2006

            //  Purpose
            //  =======

            //  ZGEBRD reduces a general complex M-by-N matrix A to upper or lower
            //  bidiagonal form B by a unitary transformation: Q**H * A * P = B.

            //  If m >= n, B is upper bidiagonal; if m < n, B is lower bidiagonal.

            //  Arguments
            //  =========

            //  M       (input) int
            //          The number of rows in the matrix A.  M >= 0.

            //  N       (input) int
            //          The number of columns in the matrix A.  N >= 0.

            //  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
            //          On entry, the M-by-N general matrix to be reduced.
            //          On exit,
            //          if m >= n, the diagonal and the first superdiagonal are
            //            overwritten with the upper bidiagonal matrix B; the
            //            elements below the diagonal, with the array TAUQ, represent
            //            the unitary matrix Q as a product of elementary
            //            reflectors, and the elements above the first superdiagonal,
            //            with the array TAUP, represent the unitary matrix P as
            //            a product of elementary reflectors;
            //          if m < n, the diagonal and the first subdiagonal are
            //            overwritten with the lower bidiagonal matrix B; the
            //            elements below the first subdiagonal, with the array TAUQ,
            //            represent the unitary matrix Q as a product of
            //            elementary reflectors, and the elements above the diagonal,
            //            with the array TAUP, represent the unitary matrix P as
            //            a product of elementary reflectors.
            //          See Further Details.

            //  LDA     (input) int
            //          The leading dimension of the array A.  LDA >= max(1,M).

            //  D       (output) DOUBLE PRECISION array, dimension (min(M,N))
            //          The diagonal elements of the bidiagonal matrix B:
            //          D(i) = A(i,i).

            //  E       (output) DOUBLE PRECISION array, dimension (min(M,N)-1)
            //          The off-diagonal elements of the bidiagonal matrix B:
            //          if m >= n, E(i) = A(i,i+1) for i = 1,2,...,n-1;
            //          if m < n, E(i) = A(i+1,i) for i = 1,2,...,m-1.

            //  TAUQ    (output) COMPLEX*16 array dimension (min(M,N))
            //          The scalar factors of the elementary reflectors which
            //          represent the unitary matrix Q. See Further Details.

            //  TAUP    (output) COMPLEX*16 array, dimension (min(M,N))
            //          The scalar factors of the elementary reflectors which
            //          represent the unitary matrix P. See Further Details.

            //  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))
            //          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

            //  LWORK   (input) int
            //          The length of the array WORK.  LWORK >= max(1,M,N).
            //          For optimum performance LWORK >= (M+N)*NB, where NB
            //          is the optimal blocksize.

            //          If LWORK = -1, then a workspace query is assumed; the routine
            //          only calculates the optimal size of the WORK array, returns
            //          this value as the first entry of the WORK array, and no error
            //          message related to LWORK is issued by XERBLA.

            //  INFO    (output) int
            //          = 0:  successful exit.
            //          < 0:  if INFO = -i, the i-th argument had an illegal value.

            //  Further Details
            //  ===============

            //  The matrices Q and P are represented as products of elementary
            //  reflectors:

            //  If m >= n,

            //     Q = H(1) H(2) . . . H(n)  and  P = G(1) G(2) . . . G(n-1)

            //  Each H(i) and G(i) has the form:

            //     H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'

            //  where tauq and taup are complex scalars, and v and u are complex
            //  vectors; v(1:i-1) = 0, v(i) = 1, and v(i+1:m) is stored on exit in
            //  A(i+1:m,i); u(1:i) = 0, u(i+1) = 1, and u(i+2:n) is stored on exit in
            //  A(i,i+2:n); tauq is stored in TAUQ(i) and taup in TAUP(i).

            //  If m < n,

            //     Q = H(1) H(2) . . . H(m-1)  and  P = G(1) G(2) . . . G(m)

            //  Each H(i) and G(i) has the form:

            //     H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'

            //  where tauq and taup are complex scalars, and v and u are complex
            //  vectors; v(1:i) = 0, v(i+1) = 1, and v(i+2:m) is stored on exit in
            //  A(i+2:m,i); u(1:i-1) = 0, u(i) = 1, and u(i+1:n) is stored on exit in
            //  A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).

            //  The contents of A on exit are illustrated by the following examples:

            //  m = 6 and n = 5 (m > n):          m = 5 and n = 6 (m < n):

            //    (  d   e   u1  u1  u1 )           (  d   u1  u1  u1  u1  u1 )
            //    (  v1  d   e   u2  u2 )           (  e   d   u2  u2  u2  u2 )
            //    (  v1  v2  d   e   u3 )           (  v1  e   d   u3  u3  u3 )
            //    (  v1  v2  v3  d   e  )           (  v1  v2  e   d   u4  u4 )
            //    (  v1  v2  v3  v4  d  )           (  v1  v2  v3  e   d   u5 )
            //    (  v1  v2  v3  v4  v5 )

            //  where d and e denote diagonal and off-diagonal elements of B, vi
            //  denotes an element of the vector defining H(i), and ui an element of
            //  the vector defining G(i).

            //  =====================================================================

            // System generated locals
            int a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5;
            double d__1;
            complex16 z__1;

            // Table of constant values
            complex16 c_b1 = new complex16(1.0, 0.0);
            int c__1 = 1;
            int c_n1 = -1;
            int c__3 = 3;
            int c__2 = 2;

            // Local variables
            int i, j, nb, nx;
            double ws;
            int nbmin, iinfo, minmn;
            int ldwrkx, ldwrky, lwkopt;
            bool lquery;

            // Parameter adjustments
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;
            --d;
            --e;
            --tauq;
            --taup;
            --work;

            // Function Body
            *info = 0;
            // Computing MAX
            i__1 = 1;
            i__2 = ilaenv(&c__1, "ZGEBRD", " ", m, n, &c_n1, &c_n1);
            nb = Math.Max(i__1, i__2);
            lwkopt = (*m + *n) * nb;
            d__1 = (double)lwkopt;
            work[1].r = d__1;
            work[1].i = 0.0;
            lquery = *lwork == -1;

            if (*m < 0)
            {
                *info = -1;
            }
            else if (*n < 0)
            {
                *info = -2;
            }
            else if (*lda < Math.Max(1, *m))
            {
                *info = -4;
            }
            else // if(complicated condition)
            {
                // Computing MAX
                i__1 = Math.Max(1, *m);
                if (*lwork < Math.Max(i__1, *n) && !lquery)
                {
                    *info = -10;
                }
            }

            if (*info < 0)
            {
                i__1 = -(*info);
                xerbla("ZGEBRD", &i__1);
                return 0;
            }
            else if (lquery)
            {
                return 0;
            }

            // Quick return if possible

            minmn = Math.Min(*m, *n);
            if (minmn == 0)
            {
                work[1].r = 1.0;
                work[1].i = 0.0;
                return 0;
            }

            ws = (double)Math.Max(*m, *n);
            ldwrkx = *m;
            ldwrky = *n;

            if (nb > 1 && nb < minmn)
            {
                // Set the crossover point NX.

                // Computing MAX
                i__1 = nb;
                i__2 = ilaenv(&c__3, "ZGEBRD", " ", m, n, &c_n1, &c_n1);
                nx = Math.Max(i__1, i__2);

                // Determine when to switch from blocked to unblocked code.

                if (nx < minmn)
                {
                    ws = (double)((*m + *n) * nb);
                    if ((double)(*lwork) < ws)
                    {
                        // Not enough work space for the optimal NB, consider using
                        // a smaller block size.

                        nbmin = ilaenv(&c__2, "ZGEBRD", " ", m, n, &c_n1, &c_n1);
                        if (*lwork >= (*m + *n) * nbmin)
                        {
                            nb = *lwork / (*m + *n);
                        }
                        else
                        {
                            nb = 1;
                            nx = minmn;
                        }
                    }
                }
            }
            else
            {
                nx = minmn;
            }

            i__1 = minmn - nx;
            i__2 = nb;
            for (i = 1; i__2 < 0 ? i >= i__1 : i <= i__1; i += i__2)
            {
                // Reduce rows and columns i:i+ib-1 to bidiagonal form and return
                // the matrices X and Y which are needed to update the unreduced
                // part of the matrix

                i__3 = *m - i + 1;
                i__4 = *n - i + 1;
                zlabrd(&i__3, &i__4, &nb, &a[i + i * a_dim1], lda, &d[i], &e[i],
                    &tauq[i], &taup[i], &work[1], &ldwrkx, &work[ldwrkx * nb + 1], &ldwrky);

                // Update the trailing submatrix A(i+ib:m,i+ib:n), using
                // an update of the form  A := A - V*Y' - X*U'

                i__3 = *m - i - nb + 1;
                i__4 = *n - i - nb + 1;
                z__1.r = -1.0;
                z__1.i = -0.0;
                zgemm("No transpose", "Conjugate transpose", &i__3, &i__4, &nb,
                    &z__1, &a[i + nb + i * a_dim1], lda, &work[ldwrkx * nb + nb + 1],
                    &ldwrky, &c_b1, &a[i + nb + (i + nb) * a_dim1], lda);
                i__3 = *m - i - nb + 1;
                i__4 = *n - i - nb + 1;
                z__1.r = -1.0;
                z__1.i = -0.0;
                zgemm("No transpose", "No transpose", &i__3, &i__4, &nb,
                    &z__1, &work[nb + 1], &ldwrkx, &a[i + (i + nb) * a_dim1],
                    lda, &c_b1, &a[i + nb + (i + nb) * a_dim1], lda);

                // Copy diagonal and off-diagonal elements of B back into A

                if (*m >= *n)
                {
                    i__3 = i + nb - 1;
                    for (j = i; j <= i__3; ++j)
                    {
                        i__4 = j + j * a_dim1;
                        i__5 = j;

                        a[i__4].r = d[i__5];
                        a[i__4].i = 0.0;

                        i__4 = j + (j + 1) * a_dim1;
                        i__5 = j;

                        a[i__4].r = e[i__5];
                        a[i__4].i = 0.0;
                    }
                }
                else
                {
                    i__3 = i + nb - 1;
                    for (j = i; j <= i__3; ++j)
                    {
                        i__4 = j + j * a_dim1;
                        i__5 = j;

                        a[i__4].r = d[i__5];
                        a[i__4].i = 0.0;

                        i__4 = j + 1 + j * a_dim1;
                        i__5 = j;

                        a[i__4].r = e[i__5];
                        a[i__4].i = 0.0;
                    }
                }
            }

            // Use unblocked code to reduce the remainder of the matrix

            i__2 = *m - i + 1;
            i__1 = *n - i + 1;
            zgebd2(&i__2, &i__1, &a[i + i * a_dim1], lda, &d[i], &e[i], &tauq[i], &taup[i], &work[1], &iinfo);
            work[1].r = ws;
            work[1].i = 0.0;

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zgeevx(string balanc, string jobvl, string jobvr, string sense,
            int* n, complex16* a, int* lda, complex16* w, complex16* vl, int* ldvl,
            complex16* vr, int* ldvr, int* ilo, int* ihi, double* scale, double* abnrm,
            double* rconde, double* rcondv, complex16* work, int* lwork, double* rwork, int* info)
        {
            //  -- LAPACK driver routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. 
            //     November 2006 

            //  Purpose 
            //  ======= 

            //  ZGEEVX computes for an N-by-N complex nonsymmetric matrix A, the 
            //  eigenvalues and, optionally, the left and/or right eigenvectors. 

            //  Optionally also, it computes a balancing transformation to improve 
            //  the conditioning of the eigenvalues and eigenvectors (ILO, IHI, 
            //  SCALE, and ABNRM), reciprocal condition numbers for the eigenvalues 
            //  (RCONDE), and reciprocal condition numbers for the right 
            //  eigenvectors (RCONDV). 

            //  The right eigenvector v(j) of A satisfies 
            //                   A * v(j) = lambda(j) * v(j) 
            //  where lambda(j) is its eigenvalue. 
            //  The left eigenvector u(j) of A satisfies 
            //                u(j)**H * A = lambda(j) * u(j)**H 
            //  where u(j)**H denotes the conjugate transpose of u(j). 

            //  The computed eigenvectors are normalized to have Euclidean norm 
            //  equal to 1 and largest component real. 

            //  Balancing a matrix means permuting the rows and columns to make it 
            //  more nearly upper triangular, and applying a diagonal similarity 
            //  transformation D * A * D**(-1), where D is a diagonal matrix, to 
            //  make its rows and columns closer in norm and the condition numbers 
            //  of its eigenvalues and eigenvectors smaller.  The computed 
            //  reciprocal condition numbers correspond to the balanced matrix. 
            //  Permuting rows and columns will not change the condition numbers 
            //  (in exact arithmetic) but diagonal scaling will.  For further 
            //  explanation of balancing, see section 4.10.2 of the LAPACK 
            //  Users' Guide. 

            //  Arguments 
            //  ========= 

            //  BALANC  (input) CHARACTER*1 
            //          Indicates how the input matrix should be diagonally scaled 
            //          and/or permuted to improve the conditioning of its 
            //          eigenvalues. 
            //          = 'N': Do not diagonally scale or permute; 
            //          = 'P': Perform permutations to make the matrix more nearly 
            //                 upper triangular. Do not diagonally scale; 
            //          = 'S': Diagonally scale the matrix, ie. replace A by 
            //                 D*A*D**(-1), where D is a diagonal matrix chosen 
            //                 to make the rows and columns of A more equal in 
            //                 norm. Do not permute; 
            //          = 'B': Both diagonally scale and permute A. 

            //          Computed reciprocal condition numbers will be for the matrix 
            //          after balancing and/or permuting. Permuting does not change 
            //          condition numbers (in exact arithmetic), but balancing does. 

            //  JOBVL   (input) CHARACTER*1 
            //          = 'N': left eigenvectors of A are not computed; 
            //          = 'V': left eigenvectors of A are computed. 
            //          If SENSE = 'E' or 'B', JOBVL must = 'V'. 

            //  JOBVR   (input) CHARACTER*1 
            //          = 'N': right eigenvectors of A are not computed; 
            //          = 'V': right eigenvectors of A are computed. 
            //          If SENSE = 'E' or 'B', JOBVR must = 'V'. 

            //  SENSE   (input) CHARACTER*1 
            //          Determines which reciprocal condition numbers are computed. 
            //          = 'N': None are computed; 
            //          = 'E': Computed for eigenvalues only; 
            //          = 'V': Computed for right eigenvectors only; 
            //          = 'B': Computed for eigenvalues and right eigenvectors. 

            //          If SENSE = 'E' or 'B', both left and right eigenvectors 
            //          must also be computed (JOBVL = 'V' and JOBVR = 'V'). 

            //  N       (input) INTEGER 
            //          The order of the matrix A. N >= 0. 

            //  A       (input/output) COMPLEX*16 array, dimension (LDA,N) 
            //          On entry, the N-by-N matrix A. 
            //          On exit, A has been overwritten.  If JOBVL = 'V' or 
            //          JOBVR = 'V', A contains the Schur form of the balanced 
            //          version of the matrix A. 

            //  LDA     (input) INTEGER 
            //          The leading dimension of the array A.  LDA >= max(1,N). 

            //  W       (output) COMPLEX*16 array, dimension (N) 
            //          W contains the computed eigenvalues. 

            //  VL      (output) COMPLEX*16 array, dimension (LDVL,N) 
            //          If JOBVL = 'V', the left eigenvectors u(j) are stored one 
            //          after another in the columns of VL, in the same order 
            //          as their eigenvalues. 
            //          If JOBVL = 'N', VL is not referenced. 
            //          u(j) = VL(:,j), the j-th column of VL. 

            //  LDVL    (input) INTEGER 
            //          The leading dimension of the array VL.  LDVL >= 1; if 
            //          JOBVL = 'V', LDVL >= N. 

            //  VR      (output) COMPLEX*16 array, dimension (LDVR,N) 
            //          If JOBVR = 'V', the right eigenvectors v(j) are stored one 
            //          after another in the columns of VR, in the same order 
            //          as their eigenvalues. 
            //          If JOBVR = 'N', VR is not referenced. 
            //          v(j) = VR(:,j), the j-th column of VR. 

            //  LDVR    (input) INTEGER 
            //          The leading dimension of the array VR.  LDVR >= 1; if 
            //          JOBVR = 'V', LDVR >= N. 

            //  ILO     (output) INTEGER 
            //  IHI     (output) INTEGER 
            //          ILO and IHI are int values determined when A was 
            //          balanced.  The balanced A(i,j) = 0 if I > J and 
            //          J = 1,...,ILO-1 or I = IHI+1,...,N. 

            //  SCALE   (output) DOUBLE PRECISION array, dimension (N) 
            //          Details of the permutations and scaling factors applied 
            //          when balancing A.  If P(j) is the index of the row and column 
            //          interchanged with row and column j, and D(j) is the scaling 
            //          factor applied to row and column j, then 
            //          SCALE(J) = P(J),    for J = 1,...,ILO-1 
            //                   = D(J),    for J = ILO,...,IHI 
            //                   = P(J)     for J = IHI+1,...,N. 
            //          The order in which the interchanges are made is N to IHI+1, 
            //          then 1 to ILO-1. 

            //  ABNRM   (output) DOUBLE PRECISION 
            //          The one-norm of the balanced matrix (the maximum 
            //          of the sum of absolute values of elements of any column). 

            //  RCONDE  (output) DOUBLE PRECISION array, dimension (N) 
            //          RCONDE(j) is the reciprocal condition number of the j-th 
            //          eigenvalue. 

            //  RCONDV  (output) DOUBLE PRECISION array, dimension (N) 
            //          RCONDV(j) is the reciprocal condition number of the j-th 
            //          right eigenvector. 

            //  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK)) 
            //          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. 

            //  LWORK   (input) INTEGER 
            //          The dimension of the array WORK.  If SENSE = 'N' or 'E', 
            //          LWORK >= max(1,2*N), and if SENSE = 'V' or 'B', 
            //          LWORK >= N*N+2*N. 
            //          For good performance, LWORK must generally be larger. 

            //          If LWORK = -1, then a workspace query is assumed; the routine 
            //          only calculates the optimal size of the WORK array, returns 
            //          this value as the first entry of the WORK array, and no error 
            //          message related to LWORK is issued by XERBLA. 

            //  RWORK   (workspace) DOUBLE PRECISION array, dimension (2*N) 

            //  INFO    (output) INTEGER 
            //          = 0:  successful exit 
            //          < 0:  if INFO = -i, the i-th argument had an illegal value. 
            //          > 0:  if INFO = i, the QR algorithm failed to compute all the 
            //                eigenvalues, and no eigenvectors or condition numbers 
            //                have been computed; elements 1:ILO-1 and i+1:N of W 
            //                contain eigenvalues which have converged. 

            //  ===================================================================== 

            // System generated locals 
            int a_dim1, a_offset, vl_dim1, vl_offset, vr_dim1, vr_offset, i__1, i__2, i__3;
            double d__1, d__2;
            complex16 z__1, z__2;

            // Table of constant values
            int c__1 = 1;
            int c__0 = 0;
            int c_n1 = -1;

            // Local variables 
            int i, k;
            string job;
            double scl, eps;
            double[] dum = new double[1];
            complex16 tmp;
            string side = string.Empty;
            double anrm;
            int ierr, itau, iwrk, nout, icond;
            bool scalea;
            double cscale;
            bool[] select = new bool[1];
            double bignum;
            int minwrk, maxwrk = 0;
            bool wantvl, wntsnb;
            int hswork;
            bool wntsne;
            double smlnum;
            bool lquery, wantvr;
            bool wntsnn, wntsnv;

            // Parameter adjustments 
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;
            --w;
            vl_dim1 = *ldvl;
            vl_offset = 1 + vl_dim1;
            vl -= vl_offset;
            vr_dim1 = *ldvr;
            vr_offset = 1 + vr_dim1;
            vr -= vr_offset;
            --scale;
            --rconde;
            --rcondv;
            --work;
            --rwork;

            // Function Body 
            *info = 0;
            lquery = (*lwork == -1);
            wantvl = lsame(jobvl, "V");
            wantvr = lsame(jobvr, "V");
            wntsnn = lsame(sense, "N");
            wntsne = lsame(sense, "E");
            wntsnv = lsame(sense, "V");
            wntsnb = lsame(sense, "B");

            if (!(lsame(balanc, "N") || lsame(balanc, "S") || lsame(balanc, "P") || lsame(balanc, "B")))
            {
                *info = -1;
            }
            else if (!wantvl && !lsame(jobvl, "N"))
            {
                *info = -2;
            }
            else if (!wantvr && !lsame(jobvr, "N"))
            {
                *info = -3;
            }
            else if (!(wntsnn || wntsne || wntsnb || wntsnv) || (wntsne || wntsnb) && !(wantvl && wantvr))
            {
                *info = -4;
            }
            else if (*n < 0)
            {
                *info = -5;
            }
            else if (*lda < Math.Max(1, *n))
            {
                *info = -7;
            }
            else if (*ldvl < 1 || wantvl && *ldvl < *n)
            {
                *info = -10;
            }
            else if (*ldvr < 1 || wantvr && *ldvr < *n)
            {
                *info = -12;
            }

            //     Compute workspace 
            //      (Note: Comments in the code beginning "Workspace:" describe the 
            //       minimal amount of workspace needed at that point in the code, 
            //       as well as the preferred amount for good performance. 
            //       CWorkspace refers to complex workspace, and RWorkspace to real 
            //       workspace. NB refers to the optimal block size for the 
            //       immediately following subroutine, as returned by ILAENV. 
            //       HSWORK refers to the workspace preferred by ZHSEQR, as 
            //       calculated below. HSWORK is computed assuming ILO=1 and IHI=N, 
            //       the worst case.) 

            if (*info == 0)
            {
                if (*n == 0)
                {
                    minwrk = 1;
                    maxwrk = 1;
                }
                else
                {
                    maxwrk = *n + *n * ilaenv(&c__1, "ZGEHRD", " ", n, &c__1, n, &c__0);

                    if (wantvl)
                    {
                        zhseqr("S", "V", n, &c__1, n, &a[a_offset], lda, &w[1],
                            &vl[vl_offset], ldvl, &work[1], &c_n1, info);
                    }
                    else if (wantvr)
                    {
                        zhseqr("S", "V", n, &c__1, n, &a[a_offset], lda, &w[1],
                            &vr[vr_offset], ldvr, &work[1], &c_n1, info);
                    }
                    else
                    {
                        if (wntsnn)
                        {
                            zhseqr("E", "N", n, &c__1, n, &a[a_offset], lda, &w[1],
                                &vr[vr_offset], ldvr, &work[1], &c_n1, info);
                        }
                        else
                        {
                            zhseqr("S", "N", n, &c__1, n, &a[a_offset], lda, &w[1],
                                &vr[vr_offset], ldvr, &work[1], &c_n1, info);
                        }
                    }

                    hswork = (int)work[1].r;

                    if (!wantvl && !wantvr)
                    {
                        minwrk = *n << 1;

                        if (!(wntsnn || wntsne))
                        {
                            // Computing MAX 
                            i__1 = minwrk;
                            i__2 = *n * *n + (*n << 1);
                            minwrk = Math.Max(i__1, i__2);
                        }

                        maxwrk = Math.Max(maxwrk, hswork);

                        if (!(wntsnn || wntsne))
                        {
                            // Computing MAX 
                            i__1 = maxwrk;
                            i__2 = *n * *n + (*n << 1);
                            maxwrk = Math.Max(i__1, i__2);
                        }
                    }
                    else
                    {
                        minwrk = *n << 1;

                        if (!(wntsnn || wntsne))
                        {
                            // Computing MAX 
                            i__1 = minwrk;
                            i__2 = *n * *n + (*n << 1);
                            minwrk = Math.Max(i__1, i__2);
                        }

                        maxwrk = Math.Max(maxwrk, hswork);
                        // Computing MAX 
                        i__1 = maxwrk;
                        i__2 = *n + (*n - 1) * ilaenv(&c__1, "ZUNGHR", " ", n, &c__1, n, &c_n1);
                        maxwrk = Math.Max(i__1, i__2);

                        if (!(wntsnn || wntsne))
                        {
                            // Computing MAX 
                            i__1 = maxwrk;
                            i__2 = *n * *n + (*n << 1);
                            maxwrk = Math.Max(i__1, i__2);
                        }

                        // Computing MAX 
                        i__1 = maxwrk;
                        i__2 = *n << 1;
                        maxwrk = Math.Max(i__1, i__2);
                    }
                    maxwrk = Math.Max(maxwrk, minwrk);
                }
                work[1].r = (double)maxwrk;
                work[1].i = 0.0;

                if (*lwork < minwrk && !lquery)
                {
                    *info = -20;
                }
            }

            if (*info != 0)
            {
                i__1 = -(*info);
                xerbla("ZGEEVX", &i__1);
                return 0;
            }
            else if (lquery)
            {
                return 0;
            }

            // Quick return if possible 

            if (*n == 0)
            {
                return 0;
            }

            // Get machine constants 

            eps = dlamch("P");
            smlnum = dlamch("S");
            bignum = 1.0 / smlnum;
            dlabad(&smlnum, &bignum);
            smlnum = Math.Sqrt(smlnum) / eps;
            bignum = 1.0 / smlnum;

            // Scale A if max element outside range [SMLNUM, BIGNUM] 

            icond = 0;
            anrm = zlange("M", n, n, &a[a_offset], lda, dum);
            scalea = false;

            if (anrm > 0.0 && anrm < smlnum)
            {
                scalea = true;
                cscale = smlnum;
            }
            else if (anrm > bignum)
            {
                scalea = true;
                cscale = bignum;
            }
            if (scalea)
            {
                zlascl("G", &c__0, &c__0, &anrm, &cscale, n, n, &a[a_offset], lda, &ierr);
            }

            // Balance the matrix and compute ABNRM 

            zgebal(balanc, n, &a[a_offset], lda, ilo, ihi, &scale[1], &ierr);
            *abnrm = zlange("1", n, n, &a[a_offset], lda, dum);

            if (scalea)
            {
                dum[0] = *abnrm;
                dlascl("G", &c__0, &c__0, &cscale, &anrm, &c__1, &c__1, dum, &c__1, &ierr);
                *abnrm = dum[0];
            }

            // Reduce to upper Hessenberg form 
            // (CWorkspace: need 2*N, prefer N+N*NB) 
            // (RWorkspace: none) 

            itau = 1;
            iwrk = itau + *n;
            i__1 = *lwork - iwrk + 1;
            zgehrd(n, ilo, ihi, &a[a_offset], lda, &work[itau], &work[iwrk], &i__1, &ierr);

            if (wantvl)
            {
                // Want left eigenvectors 
                // Copy Householder vectors to VL 

                side = "L";

                zlacpy("L", n, n, &a[a_offset], lda, &vl[vl_offset], ldvl);

                // Generate unitary matrix in VL 
                // (CWorkspace: need 2*N-1, prefer N+(N-1)*NB) 
                // (RWorkspace: none) 

                i__1 = *lwork - iwrk + 1;
                zunghr(n, ilo, ihi, &vl[vl_offset], ldvl, &work[itau], &work[iwrk], &i__1, &ierr);

                // Perform QR iteration, accumulating Schur vectors in VL 
                // (CWorkspace: need 1, prefer HSWORK (see comments) ) 
                // (RWorkspace: none) 

                iwrk = itau;
                i__1 = *lwork - iwrk + 1;
                zhseqr("S", "V", n, ilo, ihi, &a[a_offset], lda, &w[1], &vl[vl_offset], ldvl, &work[iwrk], &i__1, info);

                if (wantvr)
                {
                    // Want left and right eigenvectors 
                    // Copy Schur vectors to VR 

                    side = "B";
                    zlacpy("F", n, n, &vl[vl_offset], ldvl, &vr[vr_offset], ldvr);
                }
            }
            else if (wantvr)
            {
                // Want right eigenvectors 
                // Copy Householder vectors to VR 

                side = "R";
                zlacpy("L", n, n, &a[a_offset], lda, &vr[vr_offset], ldvr);

                // Generate unitary matrix in VR 
                // (CWorkspace: need 2*N-1, prefer N+(N-1)*NB) 
                // (RWorkspace: none) 

                i__1 = *lwork - iwrk + 1;
                zunghr(n, ilo, ihi, &vr[vr_offset], ldvr, &work[itau], &work[iwrk], &i__1, &ierr);

                // Perform QR iteration, accumulating Schur vectors in VR 
                // (CWorkspace: need 1, prefer HSWORK (see comments) ) 
                // (RWorkspace: none) 

                iwrk = itau;
                i__1 = *lwork - iwrk + 1;
                zhseqr("S", "V", n, ilo, ihi, &a[a_offset], lda, &w[1], &vr[vr_offset], ldvr, &work[iwrk], &i__1, info);

            }
            else
            {
                // Compute eigenvalues only 
                // If condition numbers desired, compute Schur form 

                if (wntsnn)
                {
                    job = "E";
                }
                else
                {
                    job = "S";
                }

                // (CWorkspace: need 1, prefer HSWORK (see comments) ) 
                // (RWorkspace: none) 

                iwrk = itau;
                i__1 = *lwork - iwrk + 1;
                zhseqr(job, "N", n, ilo, ihi, &a[a_offset], lda, &w[1], &vr[vr_offset], ldvr, &work[iwrk], &i__1, info);
            }

            // If INFO > 0 from ZHSEQR, then quit 

            if (*info > 0)
            {
                goto L50;
            }

            if (wantvl || wantvr)
            {
                // Compute left and/or right eigenvectors 
                // (CWorkspace: need 2*N) 
                // (RWorkspace: need N) 

                ztrevc(side, "B", select, n, &a[a_offset], lda, &vl[vl_offset], ldvl,
                     &vr[vr_offset], ldvr, n, &nout, &work[iwrk], &rwork[1], &ierr);
            }

            // Compute condition numbers if desired 
            // (CWorkspace: need N*N+2*N unless SENSE = 'E') 
            // (RWorkspace: need 2*N unless SENSE = 'E') 

            if (!wntsnn)
            {
                ztrsna(sense, "A", select, n, &a[a_offset], lda, &vl[vl_offset],
                    ldvl, &vr[vr_offset], ldvr, &rconde[1], &rcondv[1], n, &nout,
                    &work[iwrk], n, &rwork[1], &icond);
            }

            if (wantvl)
            {
                // Undo balancing of left eigenvectors 

                zgebak(balanc, "L", n, ilo, ihi, &scale[1], n, &vl[vl_offset], ldvl, &ierr);

                // Normalize left eigenvectors and make largest component real 

                i__1 = *n;
                for (i = 1; i <= i__1; ++i)
                {
                    scl = 1.0 / dznrm2(n, &vl[i * vl_dim1 + 1], &c__1);
                    zdscal(n, &scl, &vl[i * vl_dim1 + 1], &c__1);
                    i__2 = *n;

                    for (k = 1; k <= i__2; ++k)
                    {
                        i__3 = k + i * vl_dim1;
                        // Computing 2nd power 
                        d__1 = vl[i__3].r;
                        // Computing 2nd power 
                        d__2 = d_imag(&vl[k + i * vl_dim1]);
                        rwork[k] = d__1 * d__1 + d__2 * d__2;
                    }

                    k = idamax(n, &rwork[1], &c__1);
                    d_cnjg(&z__2, &vl[k + i * vl_dim1]);
                    d__1 = Math.Sqrt(rwork[k]);

                    z__1.r = z__2.r / d__1;
                    z__1.i = z__2.i / d__1;

                    tmp.r = z__1.r;
                    tmp.i = z__1.i;

                    zscal(n, &tmp, &vl[i * vl_dim1 + 1], &c__1);
                    i__2 = k + i * vl_dim1;
                    i__3 = k + i * vl_dim1;
                    d__1 = vl[i__3].r;

                    z__1.r = d__1;
                    z__1.i = 0.0;

                    vl[i__2].r = z__1.r;
                    vl[i__2].i = z__1.i;
                }
            }

            if (wantvr)
            {
                // Undo balancing of right eigenvectors 

                zgebak(balanc, "R", n, ilo, ihi, &scale[1], n, &vr[vr_offset], ldvr, &ierr);

                // Normalize right eigenvectors and make largest component real 

                i__1 = *n;
                for (i = 1; i <= i__1; ++i)
                {
                    scl = 1.0 / dznrm2(n, &vr[i * vr_dim1 + 1], &c__1);
                    zdscal(n, &scl, &vr[i * vr_dim1 + 1], &c__1);
                    i__2 = *n;

                    for (k = 1; k <= i__2; ++k)
                    {
                        i__3 = k + i * vr_dim1;
                        // Computing 2nd power 
                        d__1 = vr[i__3].r;
                        // Computing 2nd power 
                        d__2 = d_imag(&vr[k + i * vr_dim1]);
                        rwork[k] = d__1 * d__1 + d__2 * d__2;
                    }

                    k = idamax(n, &rwork[1], &c__1);
                    d_cnjg(&z__2, &vr[k + i * vr_dim1]);
                    d__1 = Math.Sqrt(rwork[k]);

                    z__1.r = z__2.r / d__1;
                    z__1.i = z__2.i / d__1;

                    tmp.r = z__1.r;
                    tmp.i = z__1.i;

                    zscal(n, &tmp, &vr[i * vr_dim1 + 1], &c__1);
                    i__2 = k + i * vr_dim1;
                    i__3 = k + i * vr_dim1;
                    d__1 = vr[i__3].r;

                    z__1.r = d__1;
                    z__1.i = 0.0;

                    vr[i__2].r = z__1.r;
                    vr[i__2].i = z__1.i;
                }
            }

            // Undo scaling if necessary 

            L50:
            if (scalea)
            {
                i__1 = *n - *info;

                // Computing MAX 
                i__3 = *n - *info;
                i__2 = Math.Max(i__3, 1);

                zlascl("G", &c__0, &c__0, &cscale, &anrm, &i__1, &c__1, &w[*info + 1], &i__2, &ierr);

                if (*info == 0)
                {
                    if ((wntsnv || wntsnb) && icond == 0)
                    {
                        dlascl("G", &c__0, &c__0, &cscale, &anrm, n, &c__1, &rcondv[1], n, &ierr);
                    }
                }
                else
                {
                    i__1 = *ilo - 1;
                    zlascl("G", &c__0, &c__0, &cscale, &anrm, &i__1, &c__1, &w[1], n, &ierr);
                }
            }

            work[1].r = (double)maxwrk;
            work[1].i = 0.0;

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zgehd2(int* n, int* ilo, int* ihi, complex16* a, int* lda,
            complex16* tau, complex16* work, int* info)
        {
            //  -- LAPACK routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. 
            //     November 2006 

            //  Purpose 
            //  ======= 

            //  ZGEHD2 reduces a complex general matrix A to upper Hessenberg form H 
            //  by a unitary similarity transformation:  Q' * A * Q = H . 

            //  Arguments 
            //  ========= 

            //  N       (input) int 
            //          The order of the matrix A.  N >= 0. 

            //  ILO     (input) int 
            //  IHI     (input) int 
            //          It is assumed that A is already upper triangular in rows 
            //          and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally 
            //          set by a previous call to ZGEBAL; otherwise they should be 
            //          set to 1 and N respectively. See Further Details. 
            //          1 <= ILO <= IHI <= max(1,N). 

            //  A       (input/output) COMPLEX*16 array, dimension (LDA,N) 
            //          On entry, the n by n general matrix to be reduced. 
            //          On exit, the upper triangle and the first subdiagonal of A 
            //          are overwritten with the upper Hessenberg matrix H, and the 
            //          elements below the first subdiagonal, with the array TAU, 
            //          represent the unitary matrix Q as a product of elementary 
            //          reflectors. See Further Details. 

            //  LDA     (input) int 
            //          The leading dimension of the array A.  LDA >= max(1,N). 

            //  TAU     (output) COMPLEX*16 array, dimension (N-1) 
            //          The scalar factors of the elementary reflectors (see Further 
            //          Details). 

            //  WORK    (workspace) COMPLEX*16 array, dimension (N) 

            //  INFO    (output) int 
            //          = 0:  successful exit 
            //          < 0:  if INFO = -i, the i-th argument had an illegal value. 

            //  Further Details 
            //  =============== 

            //  The matrix Q is represented as a product of (ihi-ilo) elementary 
            //  reflectors 

            //     Q = H(ilo) H(ilo+1) . . . H(ihi-1). 

            //  Each H(i) has the form 

            //     H(i) = I - tau * v * v' 

            //  where tau is a complex scalar, and v is a complex vector with 
            //  v(1:i) = 0, v(i+1) = 1 and v(ihi+1:n) = 0; v(i+2:ihi) is stored on 
            //  exit in A(i+2:ihi,i), and tau in TAU(i). 

            //  The contents of A are illustrated by the following example, with 
            //  n = 7, ilo = 2 and ihi = 6: 

            //  on entry,                        on exit, 

            //  ( a   a   a   a   a   a   a )    (  a   a   h   h   h   h   a ) 
            //  (     a   a   a   a   a   a )    (      a   h   h   h   h   a ) 
            //  (     a   a   a   a   a   a )    (      h   h   h   h   h   h ) 
            //  (     a   a   a   a   a   a )    (      v2  h   h   h   h   h ) 
            //  (     a   a   a   a   a   a )    (      v2  v3  h   h   h   h ) 
            //  (     a   a   a   a   a   a )    (      v2  v3  v4  h   h   h ) 
            //  (                         a )    (                          a ) 

            //  where a denotes an element of the original matrix A, h denotes a 
            //  modified element of the upper Hessenberg matrix H, and vi denotes an 
            //  element of the vector defining H(i). 

            //  ===================================================================== 

            // System generated locals 
            int a_dim1, a_offset, i__1, i__2, i__3;
            complex16 z__1;

            // Table of constant values
            int c__1 = 1;

            // Local variables
            int i;
            complex16 alpha;

            // Parameter adjustments 
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;
            --tau;
            --work;

            // Function Body 
            *info = 0;

            if (*n < 0)
            {
                *info = -1;
            }
            else if (*ilo < 1 || *ilo > Math.Max(1, *n))
            {
                *info = -2;
            }
            else if (*ihi < Math.Min(*ilo, *n) || *ihi > *n)
            {
                *info = -3;
            }
            else if (*lda < Math.Max(1, *n))
            {
                *info = -5;
            }

            if (*info != 0)
            {
                i__1 = -(*info);
                xerbla("ZGEHD2", &i__1);
                return 0;
            }

            i__1 = *ihi - 1;
            for (i = *ilo; i <= i__1; ++i)
            {
                // Compute elementary reflector H(i) to annihilate A(i+2:ihi,i) 

                i__2 = i + 1 + i * a_dim1;

                alpha.r = a[i__2].r;
                alpha.i = a[i__2].i;

                i__2 = *ihi - i;
                // Computing MIN 
                i__3 = i + 2;
                zlarfg(&i__2, &alpha, &a[Math.Min(i__3, *n) + i * a_dim1], &c__1, &tau[i]);
                i__2 = i + 1 + i * a_dim1;

                a[i__2].r = 1.0;
                a[i__2].i = 0.0;

                // Apply H(i) to A(1:ihi,i+1:ihi) from the right 

                i__2 = *ihi - i;
                zlarf("Right", ihi, &i__2, &a[i + 1 + i * a_dim1], &c__1, &tau[i], &a[(i + 1) * a_dim1 + 1], lda, &work[1]);

                // Apply H(i)' to A(i+1:ihi,i+1:n) from the left 

                i__2 = *ihi - i;
                i__3 = *n - i;
                d_cnjg(&z__1, &tau[i]);
                zlarf("Left", &i__2, &i__3, &a[i + 1 + i * a_dim1], &c__1, &z__1, &a[i + 1 + (i + 1) * a_dim1], lda, &work[1]);

                i__2 = i + 1 + i * a_dim1;

                a[i__2].r = alpha.r;
                a[i__2].i = alpha.i;
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zgehrd(int* n, int* ilo, int* ihi, complex16* a, int* lda,
            complex16* tau, complex16* work, int* lwork, int* info)
        {
            //  -- LAPACK routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. 
            //     November 2006 

            //  Purpose 
            //  ======= 

            //  ZGEHRD reduces a complex general matrix A to upper Hessenberg form H by 
            //  an unitary similarity transformation:  Q' * A * Q = H . 

            //  Arguments 
            //  ========= 

            //  N       (input) int 
            //          The order of the matrix A.  N >= 0. 

            //  ILO     (input) int 
            //  IHI     (input) int 
            //          It is assumed that A is already upper triangular in rows 
            //          and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally 
            //          set by a previous call to ZGEBAL; otherwise they should be 
            //          set to 1 and N respectively. See Further Details. 
            //          1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0. 

            //  A       (input/output) COMPLEX*16 array, dimension (LDA,N) 
            //          On entry, the N-by-N general matrix to be reduced. 
            //          On exit, the upper triangle and the first subdiagonal of A 
            //          are overwritten with the upper Hessenberg matrix H, and the 
            //          elements below the first subdiagonal, with the array TAU, 
            //          represent the unitary matrix Q as a product of elementary 
            //          reflectors. See Further Details. 

            //  LDA     (input) int 
            //          The leading dimension of the array A.  LDA >= max(1,N). 

            //  TAU     (output) COMPLEX*16 array, dimension (N-1) 
            //          The scalar factors of the elementary reflectors (see Further 
            //          Details). Elements 1:ILO-1 and IHI:N-1 of TAU are set to 
            //          zero. 

            //  WORK    (workspace/output) COMPLEX*16 array, dimension (LWORK) 
            //          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. 

            //  LWORK   (input) int 
            //          The length of the array WORK.  LWORK >= max(1,N). 
            //          For optimum performance LWORK >= N*NB, where NB is the 
            //          optimal blocksize. 

            //          If LWORK = -1, then a workspace query is assumed; the routine 
            //          only calculates the optimal size of the WORK array, returns 
            //          this value as the first entry of the WORK array, and no error 
            //          message related to LWORK is issued by XERBLA. 

            //  INFO    (output) int 
            //          = 0:  successful exit 
            //          < 0:  if INFO = -i, the i-th argument had an illegal value. 

            //  Further Details 
            //  =============== 

            //  The matrix Q is represented as a product of (ihi-ilo) elementary 
            //  reflectors 

            //     Q = H(ilo) H(ilo+1) . . . H(ihi-1). 

            //  Each H(i) has the form 

            //     H(i) = I - tau * v * v' 

            //  where tau is a complex scalar, and v is a complex vector with 
            //  v(1:i) = 0, v(i+1) = 1 and v(ihi+1:n) = 0; v(i+2:ihi) is stored on 
            //  exit in A(i+2:ihi,i), and tau in TAU(i). 

            //  The contents of A are illustrated by the following example, with 
            //  n = 7, ilo = 2 and ihi = 6: 

            //  on entry,                        on exit, 

            //  ( a   a   a   a   a   a   a )    (  a   a   h   h   h   h   a ) 
            //  (     a   a   a   a   a   a )    (      a   h   h   h   h   a ) 
            //  (     a   a   a   a   a   a )    (      h   h   h   h   h   h ) 
            //  (     a   a   a   a   a   a )    (      v2  h   h   h   h   h ) 
            //  (     a   a   a   a   a   a )    (      v2  v3  h   h   h   h ) 
            //  (     a   a   a   a   a   a )    (      v2  v3  v4  h   h   h ) 
            //  (                         a )    (                          a ) 

            //  where a denotes an element of the original matrix A, h denotes a 
            //  modified element of the upper Hessenberg matrix H, and vi denotes an 
            //  element of the vector defining H(i). 

            //  This file is a slight modification of LAPACK-3.0's ZGEHRD 
            //  subroutine incorporating improvements proposed by Quintana-Orti and 
            //  Van de Geijn (2005). 

            //  ===================================================================== 

            // System generated locals 
            int a_dim1, a_offset, i__1, i__2, i__3, i__4;
            complex16 z__1;

            // Table of constant values
            complex16 c_b2 = new complex16(1.0, 0.0);
            int c__1 = 1;
            int c_n1 = -1;
            int c__3 = 3;
            int c__2 = 2;
            int c__65 = 65;

            // Local variables 
            int i, j;
            complex16[] t = new complex16[4160]; // was [65][64] 
            int ib;
            complex16 ei;
            int nb, nh, nx = 0, iws, nbmin, iinfo;
            int ldwork, lwkopt;
            bool lquery;

            // Parameter adjustments 
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;
            --tau;
            --work;

            // Function Body 
            *info = 0;
            // Computing MIN 
            i__1 = 64;
            i__2 = ilaenv(&c__1, "ZGEHRD", " ", n, ilo, ihi, &c_n1);
            nb = Math.Min(i__1, i__2);
            lwkopt = *n * nb;

            work[1].r = (double)lwkopt;
            work[1].i = 0.0;
            lquery = *lwork == -1;

            if (*n < 0)
            {
                *info = -1;
            }
            else if (*ilo < 1 || *ilo > Math.Max(1, *n))
            {
                *info = -2;
            }
            else if (*ihi < Math.Min(*ilo, *n) || *ihi > *n)
            {
                *info = -3;
            }
            else if (*lda < Math.Max(1, *n))
            {
                *info = -5;
            }
            else if (*lwork < Math.Max(1, *n) && !lquery)
            {
                *info = -8;
            }

            if (*info != 0)
            {
                i__1 = -(*info);
                xerbla("ZGEHRD", &i__1);
                return 0;
            }
            else if (lquery)
            {
                return 0;
            }

            // Set elements 1:ILO-1 and IHI:N-1 of TAU to zero 

            i__1 = *ilo - 1;
            for (i = 1; i <= i__1; ++i)
            {
                i__2 = i;
                tau[i__2].r = 0.0;
                tau[i__2].i = 0.0;
            }

            i__1 = *n - 1;

            for (i = Math.Max(1, *ihi); i <= i__1; ++i)
            {
                i__2 = i;
                tau[i__2].r = 0.0;
                tau[i__2].i = 0.0;
            }

            // Quick return if possible 

            nh = *ihi - *ilo + 1;
            if (nh <= 1)
            {
                work[1].r = 1.0;
                work[1].i = 0.0;
                return 0;
            }

            // Determine the block size 

            // Computing MIN 
            i__1 = 64;
            i__2 = ilaenv(&c__1, "ZGEHRD", " ", n, ilo, ihi, &c_n1);
            nb = Math.Min(i__1, i__2);
            nbmin = 2;
            iws = 1;

            if (nb > 1 && nb < nh)
            {
                // Determine when to cross over from blocked to unblocked code 
                // (last block is always handled by unblocked code) 

                // Computing MAX 
                i__1 = nb;
                i__2 = ilaenv(&c__3, "ZGEHRD", " ", n, ilo, ihi, &c_n1);
                nx = Math.Max(i__1, i__2);

                if (nx < nh)
                {
                    // Determine if workspace is large enough for blocked code 

                    iws = *n * nb;
                    if (*lwork < iws)
                    {
                        // Not enough workspace to use optimal NB:  determine the 
                        // minimum value of NB, and reduce NB or force use of 
                        // unblocked code 

                        // Computing MAX 
                        i__1 = 2;
                        i__2 = ilaenv(&c__2, "ZGEHRD", " ", n, ilo, ihi, &c_n1);
                        nbmin = Math.Max(i__1, i__2);
                        if (*lwork >= *n * nbmin)
                        {
                            nb = *lwork / *n;
                        }
                        else
                        {
                            nb = 1;
                        }
                    }
                }
            }

            ldwork = *n;

            if (nb < nbmin || nb >= nh)
            {
                // Use unblocked code below 
                i = *ilo;
            }
            else
            {
                // Use blocked code 

                i__1 = *ihi - 1 - nx;
                i__2 = nb;
                for (i = *ilo; i__2 < 0 ? i >= i__1 : i <= i__1; i += i__2)
                {
                    // Computing MIN 
                    i__3 = nb;
                    i__4 = *ihi - i;
                    ib = Math.Min(i__3, i__4);

                    // Reduce columns i:i+ib-1 to Hessenberg form, returning the 
                    // matrices V and T of the block reflector H = I - V*T*V' 
                    // which performs the reduction, and also the matrix Y = A*V*T 

                    zlahr2(ihi, &i, &ib, &a[i * a_dim1 + 1], lda, &tau[i], t,
                        &c__65, &work[1], &ldwork);

                    // Apply the block reflector H to A(1:ihi,i+ib:ihi) from the 
                    // right, computing  A := A - Y * V'. V(i+ib,ib-1) must be set 
                    // to 1 

                    i__3 = i + ib + (i + ib - 1) * a_dim1;

                    ei.r = a[i__3].r;
                    ei.i = a[i__3].i;

                    i__3 = i + ib + (i + ib - 1) * a_dim1;

                    a[i__3].r = 1.0;
                    a[i__3].i = 0.0;

                    i__3 = *ihi - i - ib + 1;

                    z__1.r = -1.0;
                    z__1.i = -0.0;

                    zgemm("No transpose", "Conjugate transpose", ihi, &i__3, &ib, &z__1, &work[1],
                        &ldwork, &a[i + ib + i * a_dim1], lda, &c_b2, &a[(i + ib) * a_dim1 + 1], lda);

                    i__3 = i + ib + (i + ib - 1) * a_dim1;

                    a[i__3].r = ei.r;
                    a[i__3].i = ei.i;

                    // Apply the block reflector H to A(1:i,i+1:i+ib-1) from the 
                    // right 

                    i__3 = ib - 1;

                    ztrmm("Right", "Lower", "Conjugate transpose", "Unit", &i,
                        &i__3, &c_b2, &a[i + 1 + i * a_dim1], lda, &work[1], &ldwork);

                    i__3 = ib - 2;

                    for (j = 0; j <= i__3; ++j)
                    {
                        z__1.r = -1.0;
                        z__1.i = -0.0;
                        zaxpy(&i, &z__1, &work[ldwork * j + 1], &c__1, &a[(i + j + 1) * a_dim1 + 1], &c__1);
                    }

                    // Apply the block reflector H to A(i+1:ihi,i+ib:n) from the 
                    // left 

                    i__3 = *ihi - i;
                    i__4 = *n - i - ib + 1;

                    zlarfb("Left", "Conjugate transpose", "Forward", "Columnwise",
                        &i__3, &i__4, &ib, &a[i + 1 + i * a_dim1], lda, t, &c__65,
                        &a[i + 1 + (i + ib) * a_dim1], lda, &work[1], &ldwork);
                }
            }

            // Use unblocked code to reduce the rest of the matrix 

            zgehd2(n, &i, ihi, &a[a_offset], lda, &tau[1], &work[1], &iinfo);
            work[1].r = (double)iws;
            work[1].i = 0.0;

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zgelq2(int* m, int* n, complex16* a, int* lda, complex16* tau, complex16* work, int* info)
        {
            //  -- LAPACK routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     November 2006

            //  Purpose
            //  =======

            //  ZGELQ2 computes an LQ factorization of a complex m by n matrix A:
            //  A = L * Q.

            //  Arguments
            //  =========

            //  M       (input) int
            //          The number of rows of the matrix A.  M >= 0.

            //  N       (input) int
            //          The number of columns of the matrix A.  N >= 0.

            //  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
            //          On entry, the m by n matrix A.
            //          On exit, the elements on and below the diagonal of the array
            //          contain the m by min(m,n) lower trapezoidal matrix L (L is
            //          lower triangular if m <= n); the elements above the diagonal,
            //          with the array TAU, represent the unitary matrix Q as a
            //          product of elementary reflectors (see Further Details).

            //  LDA     (input) int
            //          The leading dimension of the array A.  LDA >= max(1,M).

            //  TAU     (output) COMPLEX*16 array, dimension (min(M,N))
            //          The scalar factors of the elementary reflectors (see Further
            //          Details).

            //  WORK    (workspace) COMPLEX*16 array, dimension (M)

            //  INFO    (output) int
            //          = 0: successful exit
            //          < 0: if INFO = -i, the i-th argument had an illegal value

            //  Further Details
            //  ===============

            //  The matrix Q is represented as a product of elementary reflectors

            //     Q = H(k)' . . . H(2)' H(1)', where k = min(m,n).

            //  Each H(i) has the form

            //     H(i) = I - tau * v * v'

            //  where tau is a complex scalar, and v is a complex vector with
            //  v(1:i-1) = 0 and v(i) = 1; conjg(v(i+1:n)) is stored on exit in
            //  A(i,i+1:n), and tau in TAU(i).

            //  =====================================================================

            // System generated locals
            int a_dim1, a_offset, i__1, i__2, i__3;

            // Local variables
            int i, k;
            complex16 alpha;

            // Parameter adjustments
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;
            --tau;
            --work;

            // Function Body
            *info = 0;
            if (*m < 0)
            {
                *info = -1;
            }
            else if (*n < 0)
            {
                *info = -2;
            }
            else if (*lda < Math.Max(1, *m))
            {
                *info = -4;
            }

            if (*info != 0)
            {
                i__1 = -(*info);
                xerbla("ZGELQ2", &i__1);
                return 0;
            }

            k = Math.Min(*m, *n);

            i__1 = k;
            for (i = 1; i <= i__1; ++i)
            {
                // Generate elementary reflector H(i) to annihilate A(i,i+1:n)

                i__2 = *n - i + 1;
                zlacgv(&i__2, &a[i + i * a_dim1], lda);
                i__2 = i + i * a_dim1;

                alpha.r = a[i__2].r;
                alpha.i = a[i__2].i;

                i__2 = *n - i + 1;
                // Computing MIN
                i__3 = i + 1;
                zlarfp(&i__2, &alpha, &a[i + Math.Min(i__3, *n) * a_dim1], lda, &tau[i]);

                if (i < *m)
                {
                    // Apply H(i) to A(i+1:m,i:n) from the right

                    i__2 = i + i * a_dim1;

                    a[i__2].r = 1.0;
                    a[i__2].i = 0.0;

                    i__2 = *m - i;
                    i__3 = *n - i + 1;
                    zlarf("Right", &i__2, &i__3, &a[i + i * a_dim1], lda, &tau[i], &a[i + 1 + i * a_dim1], lda, &work[1]);
                }

                i__2 = i + i * a_dim1;
                a[i__2].r = alpha.r;
                a[i__2].i = alpha.i;
                i__2 = *n - i + 1;
                zlacgv(&i__2, &a[i + i * a_dim1], lda);
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zgelqf(int* m, int* n, complex16* a, int* lda, complex16* tau, complex16* work, int* lwork, int* info)
        {
            //  -- LAPACK routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     November 2006

            //  Purpose
            //  =======

            //  ZGELQF computes an LQ factorization of a complex M-by-N matrix A:
            //  A = L * Q.

            //  Arguments
            //  =========

            //  M       (input) int
            //          The number of rows of the matrix A.  M >= 0.

            //  N       (input) int
            //          The number of columns of the matrix A.  N >= 0.

            //  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
            //          On entry, the M-by-N matrix A.
            //          On exit, the elements on and below the diagonal of the array
            //          contain the m-by-min(m,n) lower trapezoidal matrix L (L is
            //          lower triangular if m <= n); the elements above the diagonal,
            //          with the array TAU, represent the unitary matrix Q as a
            //          product of elementary reflectors (see Further Details).

            //  LDA     (input) int
            //          The leading dimension of the array A.  LDA >= max(1,M).

            //  TAU     (output) COMPLEX*16 array, dimension (min(M,N))
            //          The scalar factors of the elementary reflectors (see Further
            //          Details).

            //  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))
            //          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

            //  LWORK   (input) int
            //          The dimension of the array WORK.  LWORK >= max(1,M).
            //          For optimum performance LWORK >= M*NB, where NB is the
            //          optimal blocksize.

            //          If LWORK = -1, then a workspace query is assumed; the routine
            //          only calculates the optimal size of the WORK array, returns
            //          this value as the first entry of the WORK array, and no error
            //          message related to LWORK is issued by XERBLA.

            //  INFO    (output) int
            //          = 0:  successful exit
            //          < 0:  if INFO = -i, the i-th argument had an illegal value

            //  Further Details
            //  ===============

            //  The matrix Q is represented as a product of elementary reflectors

            //     Q = H(k)' . . . H(2)' H(1)', where k = min(m,n).

            //  Each H(i) has the form

            //     H(i) = I - tau * v * v'

            //  where tau is a complex scalar, and v is a complex vector with
            //  v(1:i-1) = 0 and v(i) = 1; conjg(v(i+1:n)) is stored on exit in
            //  A(i,i+1:n), and tau in TAU(i).

            //  =====================================================================

            // System generated locals
            int a_dim1, a_offset, i__1, i__2, i__3, i__4;

            // Table of constant values
            int c__1 = 1;
            int c_n1 = -1;
            int c__3 = 3;
            int c__2 = 2;

            // Local variables
            int i, k, ib, nb, nx, iws, nbmin, iinfo;
            int ldwork;
            int lwkopt;
            bool lquery;

            // Parameter adjustments
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;
            --tau;
            --work;

            // Function Body
            *info = 0;
            nb = ilaenv(&c__1, "ZGELQF", " ", m, n, &c_n1, &c_n1);
            lwkopt = *m * nb;
            work[1].r = (double)lwkopt;
            work[1].i = 0.0;
            lquery = *lwork == -1;

            if (*m < 0)
            {
                *info = -1;
            }
            else if (*n < 0)
            {
                *info = -2;
            }
            else if (*lda < Math.Max(1, *m))
            {
                *info = -4;
            }
            else if (*lwork < Math.Max(1, *m) && !lquery)
            {
                *info = -7;
            }

            if (*info != 0)
            {
                i__1 = -(*info);
                xerbla("ZGELQF", &i__1);
                return 0;
            }
            else if (lquery)
            {
                return 0;
            }

            // Quick return if possible

            k = Math.Min(*m, *n);
            if (k == 0)
            {
                work[1].r = 1.0;
                work[1].i = 0.0;
                return 0;
            }

            nbmin = 2;
            nx = 0;
            iws = *m;
            if (nb > 1 && nb < k)
            {
                // Determine when to cross over from blocked to unblocked code.

                // Computing MAX
                i__1 = 0;
                i__2 = ilaenv(&c__3, "ZGELQF", " ", m, n, &c_n1, &c_n1);
                nx = Math.Max(i__1, i__2);
                if (nx < k)
                {
                    // Determine if workspace is large enough for blocked code.

                    ldwork = *m;
                    iws = ldwork * nb;
                    if (*lwork < iws)
                    {
                        // Not enough workspace to use optimal NB:  reduce NB and
                        // determine the minimum value of NB.

                        nb = *lwork / ldwork;
                        // Computing MAX
                        i__1 = 2;
                        i__2 = ilaenv(&c__2, "ZGELQF", " ", m, n, &c_n1, &
                        c_n1);
                        nbmin = Math.Max(i__1, i__2);
                    }
                }
            }

            if (nb >= nbmin && nb < k && nx < k)
            {
                // Use blocked code initially

                i__1 = k - nx;
                i__2 = nb;
                for (i = 1; i__2 < 0 ? i >= i__1 : i <= i__1; i += i__2)
                {
                    // Computing MIN
                    i__3 = k - i + 1;
                    ib = Math.Min(i__3, nb);

                    // Compute the LQ factorization of the current block
                    // A(i:i+ib-1,i:n)

                    i__3 = *n - i + 1;
                    zgelq2(&ib, &i__3, &a[i + i * a_dim1], lda, &tau[i], &work[1], &iinfo);
                    if (i + ib <= *m)
                    {
                        // Form the triangular factor of the block reflector
                        // H = H(i) H(i+1) . . . H(i+ib-1)

                        i__3 = *n - i + 1;
                        zlarft("Forward", "Rowwise", &i__3, &ib, &a[i + i * a_dim1], lda, &tau[i], &work[1], &ldwork);

                        // Apply H to A(i+ib:m,i:n) from the right

                        i__3 = *m - i - ib + 1;
                        i__4 = *n - i + 1;
                        zlarfb("Right", "No transpose", "Forward", "Rowwise", &i__3,
                            &i__4, &ib, &a[i + i * a_dim1], lda, &work[1], &ldwork,
                            &a[i + ib + i * a_dim1], lda, &work[ib + 1], &ldwork);
                    }
                }
            }
            else
            {
                i = 1;
            }

            // Use unblocked code to factor the last or only block.

            if (i <= k)
            {
                i__2 = *m - i + 1;
                i__1 = *n - i + 1;
                zgelq2(&i__2, &i__1, &a[i + i * a_dim1], lda, &tau[i], &work[1], &iinfo);
            }

            work[1].r = (double)iws;
            work[1].i = 0.0;

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zgeqr2(int* m, int* n, complex16* a, int* lda, complex16* tau, complex16* work, int* info)
        {
            //  -- LAPACK routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     November 2006

            //  Purpose
            //  =======

            //  ZGEQR2 computes a QR factorization of a complex m by n matrix A:
            //  A = Q * R.

            //  Arguments
            //  =========

            //  M       (input) int
            //          The number of rows of the matrix A.  M >= 0.

            //  N       (input) int
            //          The number of columns of the matrix A.  N >= 0.

            //  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
            //          On entry, the m by n matrix A.
            //          On exit, the elements on and above the diagonal of the array
            //          contain the min(m,n) by n upper trapezoidal matrix R (R is
            //          upper triangular if m >= n); the elements below the diagonal,
            //          with the array TAU, represent the unitary matrix Q as a
            //          product of elementary reflectors (see Further Details).

            //  LDA     (input) int
            //          The leading dimension of the array A.  LDA >= max(1,M).

            //  TAU     (output) COMPLEX*16 array, dimension (min(M,N))
            //          The scalar factors of the elementary reflectors (see Further
            //          Details).

            //  WORK    (workspace) COMPLEX*16 array, dimension (N)

            //  INFO    (output) int
            //          = 0: successful exit
            //          < 0: if INFO = -i, the i-th argument had an illegal value

            //  Further Details
            //  ===============

            //  The matrix Q is represented as a product of elementary reflectors

            //     Q = H(1) H(2) . . . H(k), where k = min(m,n).

            //  Each H(i) has the form

            //     H(i) = I - tau * v * v'

            //  where tau is a complex scalar, and v is a complex vector with
            //  v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i),
            //  and tau in TAU(i).

            //  =====================================================================

            // System generated locals
            int a_dim1, a_offset, i__1, i__2, i__3;
            complex16 z__1;

            // Table of constant values
            int c__1 = 1;

            // Local variables
            int i, k;
            complex16 alpha;

            // Parameter adjustments
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;
            --tau;
            --work;

            // Function Body
            *info = 0;
            if (*m < 0)
            {
                *info = -1;
            }
            else if (*n < 0)
            {
                *info = -2;
            }
            else if (*lda < Math.Max(1, *m))
            {
                *info = -4;
            }
            if (*info != 0)
            {
                i__1 = -(*info);
                xerbla("ZGEQR2", &i__1);
                return 0;
            }

            k = Math.Min(*m, *n);

            i__1 = k;
            for (i = 1; i <= i__1; ++i)
            {
                // Generate elementary reflector H(i) to annihilate A(i+1:m,i)

                i__2 = *m - i + 1;
                // Computing MIN
                i__3 = i + 1;
                zlarfp(&i__2, &a[i + i * a_dim1], &a[Math.Min(i__3, *m) + i * a_dim1], &c__1, &tau[i]);

                if (i < *n)
                {
                    // Apply H(i)' to A(i:m,i+1:n) from the left

                    i__2 = i + i * a_dim1;

                    alpha.r = a[i__2].r;
                    alpha.i = a[i__2].i;

                    i__2 = i + i * a_dim1;

                    a[i__2].r = 1.0;
                    a[i__2].i = 0.0;

                    i__2 = *m - i + 1;
                    i__3 = *n - i;

                    d_cnjg(&z__1, &tau[i]);

                    zlarf("Left", &i__2, &i__3, &a[i + i * a_dim1], &c__1, &z__1,
                         &a[i + (i + 1) * a_dim1], lda, &work[1]);

                    i__2 = i + i * a_dim1;

                    a[i__2].r = alpha.r;
                    a[i__2].i = alpha.i;
                }
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zgeqrf(int* m, int* n, complex16* a, int* lda, complex16* tau, complex16* work, int* lwork, int* info)
        {
            //  -- LAPACK routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     November 2006

            //  Purpose
            //  =======

            //  ZGEQRF computes a QR factorization of a complex M-by-N matrix A:
            //  A = Q * R.

            //  Arguments
            //  =========

            //  M       (input) int
            //          The number of rows of the matrix A.  M >= 0.

            //  N       (input) int
            //          The number of columns of the matrix A.  N >= 0.

            //  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
            //          On entry, the M-by-N matrix A.
            //          On exit, the elements on and above the diagonal of the array
            //          contain the min(M,N)-by-N upper trapezoidal matrix R (R is
            //          upper triangular if m >= n); the elements below the diagonal,
            //          with the array TAU, represent the unitary matrix Q as a
            //          product of min(m,n) elementary reflectors (see Further
            //          Details).

            //  LDA     (input) int
            //          The leading dimension of the array A.  LDA >= max(1,M).

            //  TAU     (output) COMPLEX*16 array, dimension (min(M,N))
            //          The scalar factors of the elementary reflectors (see Further
            //          Details).

            //  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))
            //          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

            //  LWORK   (input) int
            //          The dimension of the array WORK.  LWORK >= max(1,N).
            //          For optimum performance LWORK >= N*NB, where NB is
            //          the optimal blocksize.

            //          If LWORK = -1, then a workspace query is assumed; the routine
            //          only calculates the optimal size of the WORK array, returns
            //          this value as the first entry of the WORK array, and no error
            //          message related to LWORK is issued by XERBLA.

            //  INFO    (output) int
            //          = 0:  successful exit
            //          < 0:  if INFO = -i, the i-th argument had an illegal value

            //  Further Details
            //  ===============

            //  The matrix Q is represented as a product of elementary reflectors

            //     Q = H(1) H(2) . . . H(k), where k = min(m,n).

            //  Each H(i) has the form

            //     H(i) = I - tau * v * v'

            //  where tau is a complex scalar, and v is a complex vector with
            //  v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i),
            //  and tau in TAU(i).

            //  =====================================================================

            // System generated locals
            int a_dim1, a_offset, i__1, i__2, i__3, i__4;

            // Table of constant values
            int c__1 = 1;
            int c_n1 = -1;
            int c__3 = 3;
            int c__2 = 2;

            // Local variables
            int i, k, ib, nb, nx, iws, nbmin, iinfo;
            int ldwork;
            int lwkopt;
            bool lquery;

            // Parameter adjustments
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;
            --tau;
            --work;

            // Function Body
            *info = 0;
            nb = ilaenv(&c__1, "ZGEQRF", " ", m, n, &c_n1, &c_n1);
            lwkopt = *n * nb;
            work[1].r = (double)lwkopt;
            work[1].i = 0.0;
            lquery = *lwork == -1;

            if (*m < 0)
            {
                *info = -1;
            }
            else if (*n < 0)
            {
                *info = -2;
            }
            else if (*lda < Math.Max(1, *m))
            {
                *info = -4;
            }
            else if (*lwork < Math.Max(1, *n) && !lquery)
            {
                *info = -7;
            }

            if (*info != 0)
            {
                i__1 = -(*info);
                xerbla("ZGEQRF", &i__1);
                return 0;
            }
            else if (lquery)
            {
                return 0;
            }

            // Quick return if possible

            k = Math.Min(*m, *n);
            if (k == 0)
            {
                work[1].r = 1.0;
                work[1].i = 0.0;
                return 0;
            }

            nbmin = 2;
            nx = 0;
            iws = *n;
            if (nb > 1 && nb < k)
            {
                // Determine when to cross over from blocked to unblocked code.

                // Computing MAX
                i__1 = 0;
                i__2 = ilaenv(&c__3, "ZGEQRF", " ", m, n, &c_n1, &c_n1);
                nx = Math.Max(i__1, i__2);
                if (nx < k)
                {
                    // Determine if workspace is large enough for blocked code.

                    ldwork = *n;
                    iws = ldwork * nb;
                    if (*lwork < iws)
                    {
                        // Not enough workspace to use optimal NB:  reduce NB and
                        // determine the minimum value of NB.

                        nb = *lwork / ldwork;
                        // Computing MAX
                        i__1 = 2;
                        i__2 = ilaenv(&c__2, "ZGEQRF", " ", m, n, &c_n1, &c_n1);
                        nbmin = Math.Max(i__1, i__2);
                    }
                }
            }

            if (nb >= nbmin && nb < k && nx < k)
            {
                // Use blocked code initially

                i__1 = k - nx;
                i__2 = nb;
                for (i = 1; i__2 < 0 ? i >= i__1 : i <= i__1; i += i__2)
                {
                    // Computing MIN
                    i__3 = k - i + 1;
                    ib = Math.Min(i__3, nb);

                    // Compute the QR factorization of the current block
                    // A(i:m,i:i+ib-1)

                    i__3 = *m - i + 1;
                    zgeqr2(&i__3, &ib, &a[i + i * a_dim1], lda, &tau[i], &work[
                        1], &iinfo);
                    if (i + ib <= *n)
                    {
                        // Form the triangular factor of the block reflector
                        // H = H(i) H(i+1) . . . H(i+ib-1)

                        i__3 = *m - i + 1;
                        zlarft("Forward", "Columnwise", &i__3, &ib, &a[i + i *
                            a_dim1], lda, &tau[i], &work[1], &ldwork);

                        // Apply H' to A(i:m,i+ib:n) from the left

                        i__3 = *m - i + 1;
                        i__4 = *n - i - ib + 1;
                        zlarfb("Left", "Conjugate transpose", "Forward", "Columnwise", &i__3, &i__4, &ib,
                            &a[i + i * a_dim1], lda, &work[1], &ldwork, &a[i + (i + ib) * a_dim1], lda, &work[ib + 1], &ldwork);
                    }
                }
            }
            else
            {
                i = 1;
            }

            // Use unblocked code to factor the last or only block.

            if (i <= k)
            {
                i__2 = *m - i + 1;
                i__1 = *n - i + 1;
                zgeqr2(&i__2, &i__1, &a[i + i * a_dim1], lda, &tau[i], &work[1], &iinfo);
            }

            work[1].r = (double)iws;
            work[1].i = 0.0;

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zgesdd(string jobz, int* m, int* n, complex16* a, int* lda, double* s, complex16* u,
            int* ldu, complex16* vt, int* ldvt, complex16* work, int* lwork, double* rwork, int* iwork, int* info)
        {
            //  -- LAPACK driver routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     November 2006
            //     8-15-00:  Improve consistency of WS calculations (eca)

            //  Purpose
            //  =======

            //  ZGESDD computes the singular value decomposition (SVD) of a complex
            //  M-by-N matrix A, optionally computing the left and/or right singular
            //  vectors, by using divide-and-conquer method. The SVD is written

            //       A = U * SIGMA * conjugate-transpose(V)

            //  where SIGMA is an M-by-N matrix which is zero except for its
            //  min(m,n) diagonal elements, U is an M-by-M unitary matrix, and
            //  V is an N-by-N unitary matrix.  The diagonal elements of SIGMA
            //  are the singular values of A; they are real and non-negative, and
            //  are returned in descending order.  The first min(m,n) columns of
            //  U and V are the left and right singular vectors of A.

            //  Note that the routine returns VT = V**H, not V.

            //  The divide and conquer algorithm makes very mild assumptions about
            //  floating point arithmetic. It will work on machines with a guard
            //  digit in add/subtract, or on those binary machines without guard
            //  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            //  Cray-2. It could conceivably fail on hexadecimal or decimal machines
            //  without guard digits, but we know of none.

            //  Arguments
            //  =========

            //  JOBZ    (input) CHARACTER*1
            //          Specifies options for computing all or part of the matrix U:
            //          = 'A':  all M columns of U and all N rows of V**H are
            //                  returned in the arrays U and VT;
            //          = 'S':  the first min(M,N) columns of U and the first
            //                  min(M,N) rows of V**H are returned in the arrays U
            //                  and VT;
            //          = 'O':  If M >= N, the first N columns of U are overwritten
            //                  in the array A and all rows of V**H are returned in
            //                  the array VT;
            //                  otherwise, all columns of U are returned in the
            //                  array U and the first M rows of V**H are overwritten
            //                  in the array A;
            //          = 'N':  no columns of U or rows of V**H are computed.

            //  M       (input) int
            //          The number of rows of the input matrix A.  M >= 0.

            //  N       (input) int
            //          The number of columns of the input matrix A.  N >= 0.

            //  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
            //          On entry, the M-by-N matrix A.
            //          On exit,
            //          if JOBZ = 'O',  A is overwritten with the first N columns
            //                          of U (the left singular vectors, stored
            //                          columnwise) if M >= N;
            //                          A is overwritten with the first M rows
            //                          of V**H (the right singular vectors, stored
            //                          rowwise) otherwise.
            //          if JOBZ .ne. 'O', the contents of A are destroyed.

            //  LDA     (input) int
            //          The leading dimension of the array A.  LDA >= max(1,M).

            //  S       (output) DOUBLE PRECISION array, dimension (min(M,N))
            //          The singular values of A, sorted so that S(i) >= S(i+1).

            //  U       (output) COMPLEX*16 array, dimension (LDU,UCOL)
            //          UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M < N;
            //          UCOL = min(M,N) if JOBZ = 'S'.
            //          If JOBZ = 'A' or JOBZ = 'O' and M < N, U contains the M-by-M
            //          unitary matrix U;
            //          if JOBZ = 'S', U contains the first min(M,N) columns of U
            //          (the left singular vectors, stored columnwise);
            //          if JOBZ = 'O' and M >= N, or JOBZ = 'N', U is not referenced.

            //  LDU     (input) int
            //          The leading dimension of the array U.  LDU >= 1; if
            //          JOBZ = 'S' or 'A' or JOBZ = 'O' and M < N, LDU >= M.

            //  VT      (output) COMPLEX*16 array, dimension (LDVT,N)
            //          If JOBZ = 'A' or JOBZ = 'O' and M >= N, VT contains the
            //          N-by-N unitary matrix V**H;
            //          if JOBZ = 'S', VT contains the first min(M,N) rows of
            //          V**H (the right singular vectors, stored rowwise);
            //          if JOBZ = 'O' and M < N, or JOBZ = 'N', VT is not referenced.

            //  LDVT    (input) int
            //          The leading dimension of the array VT.  LDVT >= 1; if
            //          JOBZ = 'A' or JOBZ = 'O' and M >= N, LDVT >= N;
            //          if JOBZ = 'S', LDVT >= min(M,N).

            //  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))
            //          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

            //  LWORK   (input) int
            //          The dimension of the array WORK. LWORK >= 1.
            //          if JOBZ = 'N', LWORK >= 2*min(M,N)+max(M,N).
            //          if JOBZ = 'O',
            //                LWORK >= 2*min(M,N)*min(M,N)+2*min(M,N)+max(M,N).
            //          if JOBZ = 'S' or 'A',
            //                LWORK >= min(M,N)*min(M,N)+2*min(M,N)+max(M,N).
            //          For good performance, LWORK should generally be larger.

            //          If LWORK = -1, a workspace query is assumed.  The optimal
            //          size for the WORK array is calculated and stored in WORK(1),
            //          and no other work except argument checking is performed.

            //  RWORK   (workspace) DOUBLE PRECISION array, dimension (MAX(1,LRWORK))
            //          If JOBZ = 'N', LRWORK >= 5*min(M,N).
            //          Otherwise, LRWORK >= 5*min(M,N)*min(M,N) + 7*min(M,N)

            //  IWORK   (workspace) int array, dimension (8*min(M,N))

            //  INFO    (output) int
            //          = 0:  successful exit.
            //          < 0:  if INFO = -i, the i-th argument had an illegal value.
            //          > 0:  The updating process of DBDSDC did not converge.

            //  Further Details
            //  ===============

            //  Based on contributions by
            //     Ming Gu and Huan Ren, Computer Science Division, University of
            //     California at Berkeley, USA

            //  =====================================================================

            // System generated locals
            int a_dim1, a_offset, u_dim1, u_offset, vt_dim1, vt_offset, i__1, i__2, i__3;

            // Table of constant values
            complex16 c_b1 = new complex16(0.0, 0.0);
            complex16 c_b2 = new complex16(1.0, 0.0);
            int c__1 = 1;
            int c_n1 = -1;
            int c__0 = 0;

            // Local variables
            int i, ie = 0, il, ir, iu, blk;
            double[] dum = new double[1];
            double eps;
            int iru, ivt, iscl;
            double anrm;
            int[] idum = new int[1];
            int ierr, itau, irvt;
            int chunk = 0, minmn;
            int wrkbl, itaup, itauq;
            bool wntqa;
            int nwork;
            bool wntqn, wntqo, wntqs;
            int mnthr1, mnthr2;
            double bignum;
            int ldwrkl;
            int ldwrkr, minwrk, ldwrku, maxwrk;
            int ldwkvt;
            double smlnum;
            bool wntqas;
            int nrwork;

            // Parameter adjustments
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;
            --s;
            u_dim1 = *ldu;
            u_offset = 1 + u_dim1;
            u -= u_offset;
            vt_dim1 = *ldvt;
            vt_offset = 1 + vt_dim1;
            vt -= vt_offset;
            --work;
            --rwork;
            --iwork;

            // Function Body
            *info = 0;
            minmn = Math.Min(*m, *n);
            mnthr1 = (int)(minmn * 17.0 / 9.0);
            mnthr2 = (int)(minmn * 5.0 / 3.0);
            wntqa = lsame(jobz, "A");
            wntqs = lsame(jobz, "S");
            wntqas = wntqa || wntqs;
            wntqo = lsame(jobz, "O");
            wntqn = lsame(jobz, "N");
            minwrk = 1;
            maxwrk = 1;

            if (!(wntqa || wntqs || wntqo || wntqn))
            {
                *info = -1;
            }
            else if (*m < 0)
            {
                *info = -2;
            }
            else if (*n < 0)
            {
                *info = -3;
            }
            else if (*lda < Math.Max(1, *m))
            {
                *info = -5;
            }
            else if (*ldu < 1 || wntqas && *ldu < *m || wntqo && *m < *n && *ldu < *
              m)
            {
                *info = -8;
            }
            else if (*ldvt < 1 || wntqa && *ldvt < *n || wntqs && *ldvt < minmn ||
              wntqo && *m >= *n && *ldvt < *n)
            {
                *info = -10;
            }

            // Compute workspace
            //  (Note: Comments in the code beginning "Workspace:" describe the
            //   minimal amount of workspace needed at that point in the code,
            //   as well as the preferred amount for good performance.
            //   CWorkspace refers to complex workspace, and RWorkspace to
            //   real workspace. NB refers to the optimal block size for the
            //   immediately following subroutine, as returned by ILAENV.)

            if (*info == 0 && *m > 0 && *n > 0)
            {
                if (*m >= *n)
                {
                    // There is no complex work space needed for bidiagonal SVD
                    // The real work space needed for bidiagonal SVD is BDSPAC
                    // for computing singular values and singular vectors; BDSPAN
                    // for computing singular values only.
                    // BDSPAC = 5*N*N + 7*N
                    // BDSPAN = MAX(7*N+4, 3*N+2+SMLSIZ*(SMLSIZ+8))

                    if (*m >= mnthr1)
                    {
                        if (wntqn)
                        {
                            // Path 1 (M much larger than N, JOBZ='N')

                            maxwrk = *n + *n * ilaenv(&c__1, "ZGEQRF", " ", m, n, &
                                c_n1, &c_n1);
                            // Computing MAX
                            i__1 = maxwrk;
                            i__2 = (*n << 1) + (*n << 1) * ilaenv(&c__1, "ZGEBRD", " ", n, n, &c_n1, &c_n1);
                            maxwrk = Math.Max(i__1, i__2);
                            minwrk = *n * 3;
                        }
                        else if (wntqo)
                        {
                            // Path 2 (M much larger than N, JOBZ='O')

                            wrkbl = *n + *n * ilaenv(&c__1, "ZGEQRF", " ", m, n, &c_n1, &c_n1);
                            // Computing MAX
                            i__1 = wrkbl;
                            i__2 = *n + *n * ilaenv(&c__1, "ZUNGQR", " ", m, n, n, &c_n1);
                            wrkbl = Math.Max(i__1, i__2);
                            // Computing MAX
                            i__1 = wrkbl;
                            i__2 = (*n << 1) + (*n << 1) * ilaenv(&c__1, "ZGEBRD", " ", n, n, &c_n1, &c_n1);
                            wrkbl = Math.Max(i__1, i__2);
                            // Computing MAX
                            i__1 = wrkbl;
                            i__2 = (*n << 1) + *n * ilaenv(&c__1, "ZUNMBR", "QLN", n, n, n, &c_n1);
                            wrkbl = Math.Max(i__1, i__2);
                            // Computing MAX
                            i__1 = wrkbl;
                            i__2 = (*n << 1) + *n * ilaenv(&c__1, "ZUNMBR", "PRC", n, n, n, &c_n1);
                            wrkbl = Math.Max(i__1, i__2);
                            maxwrk = *m * *n + *n * *n + wrkbl;
                            minwrk = (*n << 1) * *n + *n * 3;
                        }
                        else if (wntqs)
                        {
                            // Path 3 (M much larger than N, JOBZ='S')

                            wrkbl = *n + *n * ilaenv(&c__1, "ZGEQRF", " ", m, n, &c_n1, &c_n1);
                            // Computing MAX
                            i__1 = wrkbl;
                            i__2 = *n + *n * ilaenv(&c__1, "ZUNGQR", " ", m, n, n, &c_n1);
                            wrkbl = Math.Max(i__1, i__2);
                            // Computing MAX
                            i__1 = wrkbl;
                            i__2 = (*n << 1) + (*n << 1) * ilaenv(&c__1, "ZGEBRD", " ", n, n, &c_n1, &c_n1);
                            wrkbl = Math.Max(i__1, i__2);
                            // Computing MAX
                            i__1 = wrkbl;
                            i__2 = (*n << 1) + *n * ilaenv(&c__1, "ZUNMBR", "QLN", n, n, n, &c_n1);
                            wrkbl = Math.Max(i__1, i__2);
                            // Computing MAX
                            i__1 = wrkbl;
                            i__2 = (*n << 1) + *n * ilaenv(&c__1, "ZUNMBR", "PRC", n, n, n, &c_n1);
                            wrkbl = Math.Max(i__1, i__2);
                            maxwrk = *n * *n + wrkbl;
                            minwrk = *n * *n + *n * 3;
                        }
                        else if (wntqa)
                        {
                            // Path 4 (M much larger than N, JOBZ='A')

                            wrkbl = *n + *n * ilaenv(&c__1, "ZGEQRF", " ", m, n, &c_n1, &c_n1);
                            // Computing MAX
                            i__1 = wrkbl;
                            i__2 = *n + *m * ilaenv(&c__1, "ZUNGQR", " ", m, m, n, &c_n1);
                            wrkbl = Math.Max(i__1, i__2);
                            // Computing MAX
                            i__1 = wrkbl;
                            i__2 = (*n << 1) + (*n << 1) * ilaenv(&c__1, "ZGEBRD", " ", n, n, &c_n1, &c_n1);
                            wrkbl = Math.Max(i__1, i__2);
                            // Computing MAX
                            i__1 = wrkbl;
                            i__2 = (*n << 1) + *n * ilaenv(&c__1, "ZUNMBR", "QLN", n, n, n, &c_n1);
                            wrkbl = Math.Max(i__1, i__2);
                            // Computing MAX
                            i__1 = wrkbl;
                            i__2 = (*n << 1) + *n * ilaenv(&c__1, "ZUNMBR", "PRC", n, n, n, &c_n1);
                            wrkbl = Math.Max(i__1, i__2);
                            maxwrk = *n * *n + wrkbl;
                            minwrk = *n * *n + (*n << 1) + *m;
                        }
                    }
                    else if (*m >= mnthr2)
                    {
                        // Path 5 (M much larger than N, but not as much as MNTHR1)

                        maxwrk = (*n << 1) + (*m + *n) * ilaenv(&c__1, "ZGEBRD", " ", m, n, &c_n1, &c_n1);
                        minwrk = (*n << 1) + *m;
                        if (wntqo)
                        {
                            // Computing MAX
                            i__1 = maxwrk;
                            i__2 = (*n << 1) + *n * ilaenv(&c__1, "ZUNGBR", "P", n, n, n, &c_n1);
                            maxwrk = Math.Max(i__1, i__2);
                            // Computing MAX
                            i__1 = maxwrk;
                            i__2 = (*n << 1) + *n * ilaenv(&c__1, "ZUNGBR", "Q", m, n, n, &c_n1);
                            maxwrk = Math.Max(i__1, i__2);
                            maxwrk += *m * *n;
                            minwrk += *n * *n;
                        }
                        else if (wntqs)
                        {
                            // Computing MAX
                            i__1 = maxwrk;
                            i__2 = (*n << 1) + *n * ilaenv(&c__1, "ZUNGBR", "P", n, n, n, &c_n1);
                            maxwrk = Math.Max(i__1, i__2);
                            // Computing MAX
                            i__1 = maxwrk;
                            i__2 = (*n << 1) + *n * ilaenv(&c__1, "ZUNGBR", "Q", m, n, n, &c_n1);
                            maxwrk = Math.Max(i__1, i__2);
                        }
                        else if (wntqa)
                        {
                            // Computing MAX
                            i__1 = maxwrk;
                            i__2 = (*n << 1) + *n * ilaenv(&c__1, "ZUNGBR", "P", n, n, n, &c_n1);
                            maxwrk = Math.Max(i__1, i__2);
                            // Computing MAX
                            i__1 = maxwrk;
                            i__2 = (*n << 1) + *m * ilaenv(&c__1, "ZUNGBR", "Q", m, m, n, &c_n1);
                            maxwrk = Math.Max(i__1, i__2);
                        }
                    }
                    else
                    {
                        // Path 6 (M at least N, but not much larger)

                        maxwrk = (*n << 1) + (*m + *n) * ilaenv(&c__1, "ZGEBRD", " ", m, n, &c_n1, &c_n1);
                        minwrk = (*n << 1) + *m;
                        if (wntqo)
                        {
                            // Computing MAX
                            i__1 = maxwrk;
                            i__2 = (*n << 1) + *n * ilaenv(&c__1, "ZUNMBR", "PRC", n, n, n, &c_n1);
                            maxwrk = Math.Max(i__1, i__2);
                            // Computing MAX
                            i__1 = maxwrk;
                            i__2 = (*n << 1) + *n * ilaenv(&c__1, "ZUNMBR", "QLN", m, n, n, &c_n1);
                            maxwrk = Math.Max(i__1, i__2);
                            maxwrk += *m * *n;
                            minwrk += *n * *n;
                        }
                        else if (wntqs)
                        {
                            // Computing MAX
                            i__1 = maxwrk;
                            i__2 = (*n << 1) + *n * ilaenv(&c__1, "ZUNMBR", "PRC", n, n, n, &c_n1);
                            maxwrk = Math.Max(i__1, i__2);
                            // Computing MAX
                            i__1 = maxwrk;
                            i__2 = (*n << 1) + *n * ilaenv(&c__1, "ZUNMBR", "QLN", m, n, n, &c_n1);
                            maxwrk = Math.Max(i__1, i__2);
                        }
                        else if (wntqa)
                        {
                            // Computing MAX
                            i__1 = maxwrk;
                            i__2 = (*n << 1) + *n * ilaenv(&c__1, "ZUNGBR", "PRC", n, n, n, &c_n1);
                            maxwrk = Math.Max(i__1, i__2);
                            // Computing MAX
                            i__1 = maxwrk;
                            i__2 = (*n << 1) + *m * ilaenv(&c__1, "ZUNGBR", "QLN", m, m, n, &c_n1);
                            maxwrk = Math.Max(i__1, i__2);
                        }
                    }
                }
                else
                {
                    // There is no complex work space needed for bidiagonal SVD
                    // The real work space needed for bidiagonal SVD is BDSPAC
                    // for computing singular values and singular vectors; BDSPAN
                    // for computing singular values only.
                    // BDSPAC = 5*M*M + 7*M
                    // BDSPAN = MAX(7*M+4, 3*M+2+SMLSIZ*(SMLSIZ+8))

                    if (*n >= mnthr1)
                    {
                        if (wntqn)
                        {
                            // Path 1t (N much larger than M, JOBZ='N')

                            maxwrk = *m + *m * ilaenv(&c__1, "ZGELQF", " ", m, n, &c_n1, &c_n1);
                            // Computing MAX
                            i__1 = maxwrk;
                            i__2 = (*m << 1) + (*m << 1) * ilaenv(&c__1, "ZGEBRD", " ", m, m, &c_n1, &c_n1);
                            maxwrk = Math.Max(i__1, i__2);
                            minwrk = *m * 3;
                        }
                        else if (wntqo)
                        {
                            // Path 2t (N much larger than M, JOBZ='O')

                            wrkbl = *m + *m * ilaenv(&c__1, "ZGELQF", " ", m, n, &c_n1, &c_n1);
                            // Computing MAX
                            i__1 = wrkbl;
                            i__2 = *m + *m * ilaenv(&c__1, "ZUNGLQ", " ", m, n, m, &c_n1);
                            wrkbl = Math.Max(i__1, i__2);
                            // Computing MAX
                            i__1 = wrkbl;
                            i__2 = (*m << 1) + (*m << 1) * ilaenv(&c__1, "ZGEBRD", " ", m, m, &c_n1, &c_n1);
                            wrkbl = Math.Max(i__1, i__2);
                            // Computing MAX
                            i__1 = wrkbl;
                            i__2 = (*m << 1) + *m * ilaenv(&c__1, "ZUNMBR", "PRC", m, m, m, &c_n1);
                            wrkbl = Math.Max(i__1, i__2);
                            // Computing MAX
                            i__1 = wrkbl;
                            i__2 = (*m << 1) + *m * ilaenv(&c__1, "ZUNMBR", "QLN", m, m, m, &c_n1);
                            wrkbl = Math.Max(i__1, i__2);
                            maxwrk = *m * *n + *m * *m + wrkbl;
                            minwrk = (*m << 1) * *m + *m * 3;
                        }
                        else if (wntqs)
                        {
                            // Path 3t (N much larger than M, JOBZ='S')

                            wrkbl = *m + *m * ilaenv(&c__1, "ZGELQF", " ", m, n, &c_n1, &c_n1);
                            // Computing MAX
                            i__1 = wrkbl;
                            i__2 = *m + *m * ilaenv(&c__1, "ZUNGLQ", " ", m, n, m, &c_n1);
                            wrkbl = Math.Max(i__1, i__2);
                            // Computing MAX
                            i__1 = wrkbl;
                            i__2 = (*m << 1) + (*m << 1) * ilaenv(&c__1, "ZGEBRD", " ", m, m, &c_n1, &c_n1);
                            wrkbl = Math.Max(i__1, i__2);
                            // Computing MAX
                            i__1 = wrkbl;
                            i__2 = (*m << 1) + *m * ilaenv(&c__1, "ZUNMBR", "PRC", m, m, m, &c_n1);
                            wrkbl = Math.Max(i__1, i__2);
                            // Computing MAX
                            i__1 = wrkbl;
                            i__2 = (*m << 1) + *m * ilaenv(&c__1, "ZUNMBR", "QLN", m, m, m, &c_n1);
                            wrkbl = Math.Max(i__1, i__2);
                            maxwrk = *m * *m + wrkbl;
                            minwrk = *m * *m + *m * 3;
                        }
                        else if (wntqa)
                        {
                            // Path 4t (N much larger than M, JOBZ='A')

                            wrkbl = *m + *m * ilaenv(&c__1, "ZGELQF", " ", m, n, &c_n1, &c_n1);
                            // Computing MAX
                            i__1 = wrkbl;
                            i__2 = *m + *n * ilaenv(&c__1, "ZUNGLQ", " ", n, n, m, &c_n1);
                            wrkbl = Math.Max(i__1, i__2);
                            // Computing MAX
                            i__1 = wrkbl;
                            i__2 = (*m << 1) + (*m << 1) * ilaenv(&c__1, "ZGEBRD", " ", m, m, &c_n1, &c_n1);
                            wrkbl = Math.Max(i__1, i__2);
                            // Computing MAX
                            i__1 = wrkbl;
                            i__2 = (*m << 1) + *m * ilaenv(&c__1, "ZUNMBR", "PRC", m, m, m, &c_n1);
                            wrkbl = Math.Max(i__1, i__2);
                            // Computing MAX
                            i__1 = wrkbl;
                            i__2 = (*m << 1) + *m * ilaenv(&c__1, "ZUNMBR", "QLN", m, m, m, &c_n1);
                            wrkbl = Math.Max(i__1, i__2);
                            maxwrk = *m * *m + wrkbl;
                            minwrk = *m * *m + (*m << 1) + *n;
                        }
                    }
                    else if (*n >= mnthr2)
                    {
                        // Path 5t (N much larger than M, but not as much as MNTHR1)

                        maxwrk = (*m << 1) + (*m + *n) * ilaenv(&c__1, "ZGEBRD", " ", m, n, &c_n1, &c_n1);
                        minwrk = (*m << 1) + *n;
                        if (wntqo)
                        {
                            // Computing MAX
                            i__1 = maxwrk;
                            i__2 = (*m << 1) + *m * ilaenv(&c__1, "ZUNGBR", "P", m, n, m, &c_n1);
                            maxwrk = Math.Max(i__1, i__2);
                            // Computing MAX
                            i__1 = maxwrk;
                            i__2 = (*m << 1) + *m * ilaenv(&c__1, "ZUNGBR", "Q", m, m, n, &c_n1);
                            maxwrk = Math.Max(i__1, i__2);
                            maxwrk += *m * *n;
                            minwrk += *m * *m;
                        }
                        else if (wntqs)
                        {
                            // Computing MAX
                            i__1 = maxwrk;
                            i__2 = (*m << 1) + *m * ilaenv(&c__1, "ZUNGBR", "P", m, n, m, &c_n1);
                            maxwrk = Math.Max(i__1, i__2);
                            // Computing MAX
                            i__1 = maxwrk;
                            i__2 = (*m << 1) + *m * ilaenv(&c__1, "ZUNGBR", "Q", m, m, n, &c_n1);
                            maxwrk = Math.Max(i__1, i__2);
                        }
                        else if (wntqa)
                        {
                            // Computing MAX
                            i__1 = maxwrk;
                            i__2 = (*m << 1) + *n * ilaenv(&c__1, "ZUNGBR", "P", n, n, m, &c_n1);
                            maxwrk = Math.Max(i__1, i__2);
                            // Computing MAX
                            i__1 = maxwrk;
                            i__2 = (*m << 1) + *m * ilaenv(&c__1, "ZUNGBR", "Q", m, m, n, &c_n1);
                            maxwrk = Math.Max(i__1, i__2);
                        }
                    }
                    else
                    {
                        // Path 6t (N greater than M, but not much larger)

                        maxwrk = (*m << 1) + (*m + *n) * ilaenv(&c__1, "ZGEBRD", " ", m, n, &c_n1, &c_n1);
                        minwrk = (*m << 1) + *n;
                        if (wntqo)
                        {
                            // Computing MAX
                            i__1 = maxwrk;
                            i__2 = (*m << 1) + *m * ilaenv(&c__1, "ZUNMBR", "PRC", m, n, m, &c_n1);
                            maxwrk = Math.Max(i__1, i__2);
                            // Computing MAX
                            i__1 = maxwrk;
                            i__2 = (*m << 1) + *m * ilaenv(&c__1, "ZUNMBR", "QLN", m, m, n, &c_n1);
                            maxwrk = Math.Max(i__1, i__2);
                            maxwrk += *m * *n;
                            minwrk += *m * *m;
                        }
                        else if (wntqs)
                        {
                            // Computing MAX
                            i__1 = maxwrk;
                            i__2 = (*m << 1) + *m * ilaenv(&c__1, "ZUNGBR", "PRC", m, n, m, &c_n1);
                            maxwrk = Math.Max(i__1, i__2);
                            // Computing MAX
                            i__1 = maxwrk;
                            i__2 = (*m << 1) + *m * ilaenv(&c__1, "ZUNGBR", "QLN", m, m, n, &c_n1);
                            maxwrk = Math.Max(i__1, i__2);
                        }
                        else if (wntqa)
                        {
                            // Computing MAX
                            i__1 = maxwrk;
                            i__2 = (*m << 1) + *n * ilaenv(&c__1, "ZUNGBR", "PRC", n, n, m, &c_n1);
                            maxwrk = Math.Max(i__1, i__2);
                            // Computing MAX
                            i__1 = maxwrk;
                            i__2 = (*m << 1) + *m * ilaenv(&c__1, "ZUNGBR", "QLN", m, m, n, &c_n1);
                            maxwrk = Math.Max(i__1, i__2);
                        }
                    }
                }
                maxwrk = Math.Max(maxwrk, minwrk);
            }

            if (*info == 0)
            {
                work[1].r = (double)maxwrk;
                work[1].i = 0.0;
                if (*lwork < minwrk && *lwork != -1)
                {
                    *info = -13;
                }
            }

            // Quick returns

            if (*info != 0)
            {
                i__1 = -(*info);
                xerbla("ZGESDD", &i__1);
                return 0;
            }

            if (*lwork == -1)
            {
                return 0;
            }
            if (*m == 0 || *n == 0)
            {
                return 0;
            }

            // Get machine constants

            eps = dlamch("P");
            smlnum = Math.Sqrt(dlamch("S")) / eps;
            bignum = 1.0 / smlnum;

            // Scale A if max element outside range [SMLNUM,BIGNUM]

            anrm = zlange("M", m, n, &a[a_offset], lda, dum);
            iscl = 0;
            if (anrm > 0.0 && anrm < smlnum)
            {
                iscl = 1;
                zlascl("G", &c__0, &c__0, &anrm, &smlnum, m, n, &a[a_offset], lda, &ierr);
            }
            else if (anrm > bignum)
            {
                iscl = 1;
                zlascl("G", &c__0, &c__0, &anrm, &bignum, m, n, &a[a_offset], lda, &ierr);
            }

            if (*m >= *n)
            {
                // A has at least as many rows as columns. If A has sufficiently
                // more rows than columns, first reduce using the QR
                // decomposition (if sufficient workspace available)

                if (*m >= mnthr1)
                {
                    if (wntqn)
                    {
                        // Path 1 (M much larger than N, JOBZ='N')
                        // No singular vectors to be computed

                        itau = 1;
                        nwork = itau + *n;

                        // Compute A=Q*R
                        // (CWorkspace: need 2*N, prefer N+N*NB)
                        // (RWorkspace: need 0)

                        i__1 = *lwork - nwork + 1;
                        zgeqrf(m, n, &a[a_offset], lda, &work[itau], &work[nwork], &i__1, &ierr);

                        // Zero out below R

                        i__1 = *n - 1;
                        i__2 = *n - 1;
                        zlaset("L", &i__1, &i__2, &c_b1, &c_b1, &a[a_dim1 + 2], lda);
                        ie = 1;
                        itauq = 1;
                        itaup = itauq + *n;
                        nwork = itaup + *n;

                        // Bidiagonalize R in A
                        // (CWorkspace: need 3*N, prefer 2*N+2*N*NB)
                        // (RWorkspace: need N)

                        i__1 = *lwork - nwork + 1;
                        zgebrd(n, n, &a[a_offset], lda, &s[1], &rwork[ie],
                            &work[itauq], &work[itaup], &work[nwork], &i__1, &ierr);
                        nrwork = ie + *n;

                        // Perform bidiagonal SVD, compute singular values only
                        // (CWorkspace: 0)
                        // (RWorkspace: need BDSPAN)

                        dbdsdc("U", "N", n, &s[1], &rwork[ie], dum, &c__1, dum,
                            &c__1, dum, idum, &rwork[nrwork], &iwork[1], info);

                    }
                    else if (wntqo)
                    {
                        // Path 2 (M much larger than N, JOBZ='O')
                        // N left singular vectors to be overwritten on A and
                        // N right singular vectors to be computed in VT

                        iu = 1;

                        // WORK(IU) is N by N

                        ldwrku = *n;
                        ir = iu + ldwrku * *n;
                        if (*lwork >= *m * *n + *n * *n + *n * 3)
                        {
                            // WORK(IR) is M by N

                            ldwrkr = *m;
                        }
                        else
                        {
                            ldwrkr = (*lwork - *n * *n - *n * 3) / *n;
                        }
                        itau = ir + ldwrkr * *n;
                        nwork = itau + *n;

                        // Compute A=Q*R
                        // (CWorkspace: need N*N+2*N, prefer M*N+N+N*NB)
                        // (RWorkspace: 0)

                        i__1 = *lwork - nwork + 1;
                        zgeqrf(m, n, &a[a_offset], lda, &work[itau], &work[nwork], &i__1, &ierr);

                        // Copy R to WORK( IR ), zeroing out below it

                        zlacpy("U", n, n, &a[a_offset], lda, &work[ir], &ldwrkr);
                        i__1 = *n - 1;
                        i__2 = *n - 1;
                        zlaset("L", &i__1, &i__2, &c_b1, &c_b1, &work[ir + 1], &ldwrkr);

                        // Generate Q in A
                        // (CWorkspace: need 2*N, prefer N+N*NB)
                        // (RWorkspace: 0)

                        i__1 = *lwork - nwork + 1;
                        zungqr(m, n, n, &a[a_offset], lda, &work[itau], &work[nwork], &i__1, &ierr);
                        ie = 1;
                        itauq = itau;
                        itaup = itauq + *n;
                        nwork = itaup + *n;

                        // Bidiagonalize R in WORK(IR)
                        // (CWorkspace: need N*N+3*N, prefer M*N+2*N+2*N*NB)
                        // (RWorkspace: need N)

                        i__1 = *lwork - nwork + 1;
                        zgebrd(n, n, &work[ir], &ldwrkr, &s[1], &rwork[ie],
                            &work[itauq], &work[itaup], &work[nwork], &i__1, &ierr);

                        // Perform bidiagonal SVD, computing left singular vectors
                        // of R in WORK(IRU) and computing right singular vectors
                        // of R in WORK(IRVT)
                        // (CWorkspace: need 0)
                        // (RWorkspace: need BDSPAC)

                        iru = ie + *n;
                        irvt = iru + *n * *n;
                        nrwork = irvt + *n * *n;
                        dbdsdc("U", "I", n, &s[1], &rwork[ie], &rwork[iru], n,
                            &rwork[irvt], n, dum, idum, &rwork[nrwork], &iwork[1], info);

                        // Copy real matrix RWORK(IRU) to complex matrix WORK(IU)
                        // Overwrite WORK(IU) by the left singular vectors of R
                        // (CWorkspace: need 2*N*N+3*N, prefer M*N+N*N+2*N+N*NB)
                        // (RWorkspace: 0)

                        zlacp2("F", n, n, &rwork[iru], n, &work[iu], &ldwrku);
                        i__1 = *lwork - nwork + 1;
                        zunmbr("Q", "L", "N", n, n, n, &work[ir], &ldwrkr, &work[itauq],
                            &work[iu], &ldwrku, &work[nwork], &i__1, &ierr);

                        // Copy real matrix RWORK(IRVT) to complex matrix VT
                        // Overwrite VT by the right singular vectors of R
                        // (CWorkspace: need N*N+3*N, prefer M*N+2*N+N*NB)
                        // (RWorkspace: 0)

                        zlacp2("F", n, n, &rwork[irvt], n, &vt[vt_offset], ldvt);
                        i__1 = *lwork - nwork + 1;
                        zunmbr("P", "R", "C", n, n, n, &work[ir], &ldwrkr, &work[itaup],
                            &vt[vt_offset], ldvt, &work[nwork], &i__1, &ierr);

                        // Multiply Q in A by left singular vectors of R in
                        // WORK(IU), storing result in WORK(IR) and copying to A
                        // (CWorkspace: need 2*N*N, prefer N*N+M*N)
                        // (RWorkspace: 0)

                        i__1 = *m;
                        i__2 = ldwrkr;
                        for (i = 1; i__2 < 0 ? i >= i__1 : i <= i__1; i += i__2)
                        {
                            // Computing MIN
                            i__3 = *m - i + 1;
                            chunk = Math.Min(i__3, ldwrkr);

                            zgemm("N", "N", &chunk, n, n, &c_b2, &a[i + a_dim1],
                                lda, &work[iu], &ldwrku, &c_b1, &work[ir], &ldwrkr);

                            zlacpy("F", &chunk, n, &work[ir], &ldwrkr, &a[i + a_dim1], lda);
                        }

                    }
                    else if (wntqs)
                    {
                        // Path 3 (M much larger than N, JOBZ='S')
                        // N left singular vectors to be computed in U and
                        // N right singular vectors to be computed in VT

                        ir = 1;

                        // WORK(IR) is N by N

                        ldwrkr = *n;
                        itau = ir + ldwrkr * *n;
                        nwork = itau + *n;

                        // Compute A=Q*R
                        // (CWorkspace: need N*N+2*N, prefer N*N+N+N*NB)
                        // (RWorkspace: 0)

                        i__2 = *lwork - nwork + 1;
                        zgeqrf(m, n, &a[a_offset], lda, &work[itau], &work[nwork], &i__2, &ierr);

                        // Copy R to WORK(IR), zeroing out below it

                        zlacpy("U", n, n, &a[a_offset], lda, &work[ir], &ldwrkr);
                        i__2 = *n - 1;
                        i__1 = *n - 1;
                        zlaset("L", &i__2, &i__1, &c_b1, &c_b1, &work[ir + 1], &ldwrkr);

                        // Generate Q in A
                        // (CWorkspace: need 2*N, prefer N+N*NB)
                        // (RWorkspace: 0)

                        i__2 = *lwork - nwork + 1;
                        zungqr(m, n, n, &a[a_offset], lda, &work[itau], &work[nwork], &i__2, &ierr);
                        ie = 1;
                        itauq = itau;
                        itaup = itauq + *n;
                        nwork = itaup + *n;

                        // Bidiagonalize R in WORK(IR)
                        // (CWorkspace: need N*N+3*N, prefer N*N+2*N+2*N*NB)
                        // (RWorkspace: need N)

                        i__2 = *lwork - nwork + 1;
                        zgebrd(n, n, &work[ir], &ldwrkr, &s[1], &rwork[ie],
                            &work[itauq], &work[itaup], &work[nwork], &i__2, &ierr);

                        // Perform bidiagonal SVD, computing left singular vectors
                        // of bidiagonal matrix in RWORK(IRU) and computing right
                        // singular vectors of bidiagonal matrix in RWORK(IRVT)
                        // (CWorkspace: need 0)
                        // (RWorkspace: need BDSPAC)

                        iru = ie + *n;
                        irvt = iru + *n * *n;
                        nrwork = irvt + *n * *n;
                        dbdsdc("U", "I", n, &s[1], &rwork[ie], &rwork[iru], n,
                            &rwork[irvt], n, dum, idum, &rwork[nrwork], &iwork[1], info);

                        // Copy real matrix RWORK(IRU) to complex matrix U
                        // Overwrite U by left singular vectors of R
                        // (CWorkspace: need N*N+3*N, prefer N*N+2*N+N*NB)
                        // (RWorkspace: 0)

                        zlacp2("F", n, n, &rwork[iru], n, &u[u_offset], ldu);
                        i__2 = *lwork - nwork + 1;
                        zunmbr("Q", "L", "N", n, n, n, &work[ir], &ldwrkr, &work[itauq],
                            &u[u_offset], ldu, &work[nwork], &i__2, &ierr);

                        // Copy real matrix RWORK(IRVT) to complex matrix VT
                        // Overwrite VT by right singular vectors of R
                        // (CWorkspace: need N*N+3*N, prefer N*N+2*N+N*NB)
                        // (RWorkspace: 0)

                        zlacp2("F", n, n, &rwork[irvt], n, &vt[vt_offset], ldvt);
                        i__2 = *lwork - nwork + 1;
                        zunmbr("P", "R", "C", n, n, n, &work[ir], &ldwrkr,
                            &work[itaup], &vt[vt_offset], ldvt, &work[nwork], &i__2, &ierr);

                        // Multiply Q in A by left singular vectors of R in
                        // WORK(IR), storing result in U
                        // (CWorkspace: need N*N)
                        // (RWorkspace: 0)

                        zlacpy("F", n, n, &u[u_offset], ldu, &work[ir], &ldwrkr);
                        zgemm("N", "N", m, n, n, &c_b2, &a[a_offset], lda, &work[ir],
                             &ldwrkr, &c_b1, &u[u_offset], ldu);

                    }
                    else if (wntqa)
                    {
                        // Path 4 (M much larger than N, JOBZ='A')
                        // M left singular vectors to be computed in U and
                        // N right singular vectors to be computed in VT

                        iu = 1;

                        // WORK(IU) is N by N

                        ldwrku = *n;
                        itau = iu + ldwrku * *n;
                        nwork = itau + *n;

                        // Compute A=Q*R, copying result to U
                        // (CWorkspace: need 2*N, prefer N+N*NB)
                        // (RWorkspace: 0)

                        i__2 = *lwork - nwork + 1;
                        zgeqrf(m, n, &a[a_offset], lda, &work[itau], &work[nwork], &i__2, &ierr);
                        zlacpy("L", m, n, &a[a_offset], lda, &u[u_offset], ldu);

                        // Generate Q in U
                        // (CWorkspace: need N+M, prefer N+M*NB)
                        // (RWorkspace: 0)

                        i__2 = *lwork - nwork + 1;
                        zungqr(m, m, n, &u[u_offset], ldu, &work[itau], &work[nwork], &i__2, &ierr);

                        // Produce R in A, zeroing out below it

                        i__2 = *n - 1;
                        i__1 = *n - 1;
                        zlaset("L", &i__2, &i__1, &c_b1, &c_b1, &a[a_dim1 + 2], lda);
                        ie = 1;
                        itauq = itau;
                        itaup = itauq + *n;
                        nwork = itaup + *n;

                        // Bidiagonalize R in A
                        // (CWorkspace: need 3*N, prefer 2*N+2*N*NB)
                        // (RWorkspace: need N)

                        i__2 = *lwork - nwork + 1;
                        zgebrd(n, n, &a[a_offset], lda, &s[1], &rwork[ie],
                            &work[itauq], &work[itaup], &work[nwork], &i__2, &ierr);
                        iru = ie + *n;
                        irvt = iru + *n * *n;
                        nrwork = irvt + *n * *n;

                        // Perform bidiagonal SVD, computing left singular vectors
                        // of bidiagonal matrix in RWORK(IRU) and computing right
                        // singular vectors of bidiagonal matrix in RWORK(IRVT)
                        // (CWorkspace: need 0)
                        // (RWorkspace: need BDSPAC)

                        dbdsdc("U", "I", n, &s[1], &rwork[ie], &rwork[iru], n,
                            &rwork[irvt], n, dum, idum, &rwork[nrwork], &iwork[1], info);

                        // Copy real matrix RWORK(IRU) to complex matrix WORK(IU)
                        // Overwrite WORK(IU) by left singular vectors of R
                        // (CWorkspace: need N*N+3*N, prefer N*N+2*N+N*NB)
                        // (RWorkspace: 0)

                        zlacp2("F", n, n, &rwork[iru], n, &work[iu], &ldwrku);
                        i__2 = *lwork - nwork + 1;
                        zunmbr("Q", "L", "N", n, n, n, &a[a_offset], lda,
                            &work[itauq], &work[iu], &ldwrku, &work[nwork], &i__2, &ierr);

                        // Copy real matrix RWORK(IRVT) to complex matrix VT
                        // Overwrite VT by right singular vectors of R
                        // (CWorkspace: need 3*N, prefer 2*N+N*NB)
                        // (RWorkspace: 0)

                        zlacp2("F", n, n, &rwork[irvt], n, &vt[vt_offset], ldvt);
                        i__2 = *lwork - nwork + 1;
                        zunmbr("P", "R", "C", n, n, n, &a[a_offset], lda, &work[itaup],
                            &vt[vt_offset], ldvt, &work[nwork], &i__2, &ierr);

                        // Multiply Q in U by left singular vectors of R in
                        // WORK(IU), storing result in A
                        // (CWorkspace: need N*N)
                        // (RWorkspace: 0)

                        zgemm("N", "N", m, n, n, &c_b2, &u[u_offset], ldu, &work[iu],
                             &ldwrku, &c_b1, &a[a_offset], lda);

                        // Copy left singular vectors of A from A to U

                        zlacpy("F", m, n, &a[a_offset], lda, &u[u_offset], ldu);
                    }
                }
                else if (*m >= mnthr2)
                {
                    // MNTHR2 <= M < MNTHR1

                    // Path 5 (M much larger than N, but not as much as MNTHR1)
                    // Reduce to bidiagonal form without QR decomposition, use
                    // ZUNGBR and matrix multiplication to compute singular vectors

                    ie = 1;
                    nrwork = ie + *n;
                    itauq = 1;
                    itaup = itauq + *n;
                    nwork = itaup + *n;

                    // Bidiagonalize A
                    // (CWorkspace: need 2*N+M, prefer 2*N+(M+N)*NB)
                    // (RWorkspace: need N)

                    i__2 = *lwork - nwork + 1;
                    zgebrd(m, n, &a[a_offset], lda, &s[1], &rwork[ie],
                        &work[itauq], &work[itaup], &work[nwork], &i__2, &ierr);

                    if (wntqn)
                    {
                        // Compute singular values only
                        // (Cworkspace: 0)
                        // (Rworkspace: need BDSPAN)

                        dbdsdc("U", "N", n, &s[1], &rwork[ie], dum, &c__1, dum,
                            &c__1, dum, idum, &rwork[nrwork], &iwork[1], info);
                    }
                    else if (wntqo)
                    {
                        iu = nwork;
                        iru = nrwork;
                        irvt = iru + *n * *n;
                        nrwork = irvt + *n * *n;

                        // Copy A to VT, generate P**H
                        // (Cworkspace: need 2*N, prefer N+N*NB)
                        // (Rworkspace: 0)

                        zlacpy("U", n, n, &a[a_offset], lda, &vt[vt_offset], ldvt);
                        i__2 = *lwork - nwork + 1;
                        zungbr("P", n, n, n, &vt[vt_offset], ldvt,
                            &work[itaup], &work[nwork], &i__2, &ierr);

                        // Generate Q in A
                        // (CWorkspace: need 2*N, prefer N+N*NB)
                        // (RWorkspace: 0)

                        i__2 = *lwork - nwork + 1;
                        zungbr("Q", m, n, n, &a[a_offset], lda, &work[itauq], &work[nwork], &i__2, &ierr);

                        if (*lwork >= *m * *n + *n * 3)
                        {
                            // WORK( IU ) is M by N

                            ldwrku = *m;
                        }
                        else
                        {
                            // WORK(IU) is LDWRKU by N

                            ldwrku = (*lwork - *n * 3) / *n;
                        }
                        nwork = iu + ldwrku * *n;

                        // Perform bidiagonal SVD, computing left singular vectors
                        // of bidiagonal matrix in RWORK(IRU) and computing right
                        // singular vectors of bidiagonal matrix in RWORK(IRVT)
                        // (CWorkspace: need 0)
                        // (RWorkspace: need BDSPAC)

                        dbdsdc("U", "I", n, &s[1], &rwork[ie], &rwork[iru], n,
                            &rwork[irvt], n, dum, idum, &rwork[nrwork], &iwork[1], info);

                        // Multiply real matrix RWORK(IRVT) by P**H in VT,
                        // storing the result in WORK(IU), copying to VT
                        // (Cworkspace: need 0)
                        // (Rworkspace: need 3*N*N)

                        zlarcm(n, n, &rwork[irvt], n, &vt[vt_offset], ldvt, &work[iu], &ldwrku, &rwork[nrwork]);
                        zlacpy("F", n, n, &work[iu], &ldwrku, &vt[vt_offset], ldvt);

                        // Multiply Q in A by real matrix RWORK(IRU), storing the
                        // result in WORK(IU), copying to A
                        // (CWorkspace: need N*N, prefer M*N)
                        // (Rworkspace: need 3*N*N, prefer N*N+2*M*N)

                        nrwork = irvt;
                        i__2 = *m;
                        i__1 = ldwrku;
                        for (i = 1; i__1 < 0 ? i >= i__2 : i <= i__2; i += i__1)
                        {
                            // Computing MIN
                            i__3 = *m - i + 1;
                            chunk = Math.Min(i__3, ldwrku);
                            zlacrm(&chunk, n, &a[i + a_dim1], lda, &rwork[iru], n, &work[iu], &ldwrku, &rwork[nrwork]);
                            zlacpy("F", &chunk, n, &work[iu], &ldwrku, &a[i + a_dim1], lda);
                        }

                    }
                    else if (wntqs)
                    {
                        // Copy A to VT, generate P**H
                        // (Cworkspace: need 2*N, prefer N+N*NB)
                        // (Rworkspace: 0)

                        zlacpy("U", n, n, &a[a_offset], lda, &vt[vt_offset], ldvt);
                        i__1 = *lwork - nwork + 1;
                        zungbr("P", n, n, n, &vt[vt_offset], ldvt,
                            &work[itaup], &work[nwork], &i__1, &ierr);

                        // Copy A to U, generate Q
                        // (Cworkspace: need 2*N, prefer N+N*NB)
                        // (Rworkspace: 0)

                        zlacpy("L", m, n, &a[a_offset], lda, &u[u_offset], ldu);
                        i__1 = *lwork - nwork + 1;
                        zungbr("Q", m, n, n, &u[u_offset], ldu, &work[itauq], &work[nwork], &i__1, &ierr);

                        // Perform bidiagonal SVD, computing left singular vectors
                        // of bidiagonal matrix in RWORK(IRU) and computing right
                        // singular vectors of bidiagonal matrix in RWORK(IRVT)
                        // (CWorkspace: need 0)
                        // (RWorkspace: need BDSPAC)

                        iru = nrwork;
                        irvt = iru + *n * *n;
                        nrwork = irvt + *n * *n;
                        dbdsdc("U", "I", n, &s[1], &rwork[ie], &rwork[iru], n,
                            &rwork[irvt], n, dum, idum, &rwork[nrwork], &iwork[1], info);

                        // Multiply real matrix RWORK(IRVT) by P**H in VT,
                        // storing the result in A, copying to VT
                        // (Cworkspace: need 0)
                        // (Rworkspace: need 3*N*N)

                        zlarcm(n, n, &rwork[irvt], n, &vt[vt_offset], ldvt, &a[a_offset], lda, &rwork[nrwork]);
                        zlacpy("F", n, n, &a[a_offset], lda, &vt[vt_offset], ldvt);

                        // Multiply Q in U by real matrix RWORK(IRU), storing the
                        // result in A, copying to U
                        // (CWorkspace: need 0)
                        // (Rworkspace: need N*N+2*M*N)

                        nrwork = irvt;
                        zlacrm(m, n, &u[u_offset], ldu, &rwork[iru], n, &a[a_offset], lda, &rwork[nrwork]);
                        zlacpy("F", m, n, &a[a_offset], lda, &u[u_offset], ldu);
                    }
                    else
                    {
                        // Copy A to VT, generate P**H
                        // (Cworkspace: need 2*N, prefer N+N*NB)
                        // (Rworkspace: 0)

                        zlacpy("U", n, n, &a[a_offset], lda, &vt[vt_offset], ldvt);
                        i__1 = *lwork - nwork + 1;
                        zungbr("P", n, n, n, &vt[vt_offset], ldvt, &work[itaup], &work[nwork], &i__1, &ierr);

                        // Copy A to U, generate Q
                        // (Cworkspace: need 2*N, prefer N+N*NB)
                        // (Rworkspace: 0)

                        zlacpy("L", m, n, &a[a_offset], lda, &u[u_offset], ldu);
                        i__1 = *lwork - nwork + 1;
                        zungbr("Q", m, m, n, &u[u_offset], ldu, &work[itauq], &work[nwork], &i__1, &ierr);

                        // Perform bidiagonal SVD, computing left singular vectors
                        // of bidiagonal matrix in RWORK(IRU) and computing right
                        // singular vectors of bidiagonal matrix in RWORK(IRVT)
                        // (CWorkspace: need 0)
                        // (RWorkspace: need BDSPAC)

                        iru = nrwork;
                        irvt = iru + *n * *n;
                        nrwork = irvt + *n * *n;
                        dbdsdc("U", "I", n, &s[1], &rwork[ie], &rwork[iru], n,
                            &rwork[irvt], n, dum, idum, &rwork[nrwork], &iwork[1], info);

                        // Multiply real matrix RWORK(IRVT) by P**H in VT,
                        // storing the result in A, copying to VT
                        // (Cworkspace: need 0)
                        // (Rworkspace: need 3*N*N)

                        zlarcm(n, n, &rwork[irvt], n, &vt[vt_offset], ldvt, &a[a_offset], lda, &rwork[nrwork]);
                        zlacpy("F", n, n, &a[a_offset], lda, &vt[vt_offset], ldvt);

                        // Multiply Q in U by real matrix RWORK(IRU), storing the
                        // result in A, copying to U
                        // (CWorkspace: 0)
                        // (Rworkspace: need 3*N*N)

                        nrwork = irvt;
                        zlacrm(m, n, &u[u_offset], ldu, &rwork[iru], n, &a[a_offset], lda, &rwork[nrwork]);
                        zlacpy("F", m, n, &a[a_offset], lda, &u[u_offset], ldu);
                    }
                }
                else
                {
                    // M .LT. MNTHR2

                    // Path 6 (M at least N, but not much larger)
                    // Reduce to bidiagonal form without QR decomposition
                    // Use ZUNMBR to compute singular vectors

                    ie = 1;
                    nrwork = ie + *n;
                    itauq = 1;
                    itaup = itauq + *n;
                    nwork = itaup + *n;

                    // Bidiagonalize A
                    // (CWorkspace: need 2*N+M, prefer 2*N+(M+N)*NB)
                    // (RWorkspace: need N)

                    i__1 = *lwork - nwork + 1;
                    zgebrd(m, n, &a[a_offset], lda, &s[1], &rwork[ie],
                        &work[itauq], &work[itaup], &work[nwork], &i__1, &ierr);

                    if (wntqn)
                    {
                        // Compute singular values only
                        // (Cworkspace: 0)
                        // (Rworkspace: need BDSPAN)

                        dbdsdc("U", "N", n, &s[1], &rwork[ie], dum, &c__1, dum,
                            &c__1, dum, idum, &rwork[nrwork], &iwork[1], info);
                    }
                    else if (wntqo)
                    {
                        iu = nwork;
                        iru = nrwork;
                        irvt = iru + *n * *n;
                        nrwork = irvt + *n * *n;

                        if (*lwork >= *m * *n + *n * 3)
                        {
                            // WORK( IU ) is M by N

                            ldwrku = *m;
                        }
                        else
                        {
                            // WORK( IU ) is LDWRKU by N

                            ldwrku = (*lwork - *n * 3) / *n;
                        }
                        nwork = iu + ldwrku * *n;

                        // Perform bidiagonal SVD, computing left singular vectors
                        // of bidiagonal matrix in RWORK(IRU) and computing right
                        // singular vectors of bidiagonal matrix in RWORK(IRVT)
                        // (CWorkspace: need 0)
                        // (RWorkspace: need BDSPAC)

                        dbdsdc("U", "I", n, &s[1], &rwork[ie], &rwork[iru], n,
                            &rwork[irvt], n, dum, idum, &rwork[nrwork], &iwork[1], info);

                        // Copy real matrix RWORK(IRVT) to complex matrix VT
                        // Overwrite VT by right singular vectors of A
                        // (Cworkspace: need 2*N, prefer N+N*NB)
                        // (Rworkspace: need 0)

                        zlacp2("F", n, n, &rwork[irvt], n, &vt[vt_offset], ldvt);
                        i__1 = *lwork - nwork + 1;
                        zunmbr("P", "R", "C", n, n, n, &a[a_offset], lda, &work[itaup],
                            &vt[vt_offset], ldvt, &work[nwork], &i__1, &ierr);

                        if (*lwork >= *m * *n + *n * 3)
                        {
                            // Copy real matrix RWORK(IRU) to complex matrix WORK(IU)
                            // Overwrite WORK(IU) by left singular vectors of A, copying
                            // to A
                            // (Cworkspace: need M*N+2*N, prefer M*N+N+N*NB)
                            // (Rworkspace: need 0)

                            zlaset("F", m, n, &c_b1, &c_b1, &work[iu], &ldwrku);
                            zlacp2("F", n, n, &rwork[iru], n, &work[iu], &ldwrku);
                            i__1 = *lwork - nwork + 1;
                            zunmbr("Q", "L", "N", m, n, n, &a[a_offset], lda, &work[itauq],
                                &work[iu], &ldwrku, &work[nwork], &i__1, &ierr);
                            zlacpy("F", m, n, &work[iu], &ldwrku, &a[a_offset], lda);
                        }
                        else
                        {
                            // Generate Q in A
                            // (Cworkspace: need 2*N, prefer N+N*NB)
                            // (Rworkspace: need 0)

                            i__1 = *lwork - nwork + 1;
                            zungbr("Q", m, n, n, &a[a_offset], lda,
                                &work[itauq], &work[nwork], &i__1, &ierr);

                            // Multiply Q in A by real matrix RWORK(IRU), storing the
                            // result in WORK(IU), copying to A
                            // (CWorkspace: need N*N, prefer M*N)
                            // (Rworkspace: need 3*N*N, prefer N*N+2*M*N)

                            nrwork = irvt;
                            i__1 = *m;
                            i__2 = ldwrku;
                            for (i = 1; i__2 < 0 ? i >= i__1 : i <= i__1; i += i__2)
                            {
                                // Computing MIN
                                i__3 = *m - i + 1;
                                chunk = Math.Min(i__3, ldwrku);
                                zlacrm(&chunk, n, &a[i + a_dim1], lda, &rwork[iru],
                                    n, &work[iu], &ldwrku, &rwork[nrwork]);
                                zlacpy("F", &chunk, n, &work[iu], &ldwrku, &a[i + a_dim1], lda);
                            }
                        }
                    }
                    else if (wntqs)
                    {
                        // Perform bidiagonal SVD, computing left singular vectors
                        // of bidiagonal matrix in RWORK(IRU) and computing right
                        // singular vectors of bidiagonal matrix in RWORK(IRVT)
                        // (CWorkspace: need 0)
                        // (RWorkspace: need BDSPAC)

                        iru = nrwork;
                        irvt = iru + *n * *n;
                        nrwork = irvt + *n * *n;
                        dbdsdc("U", "I", n, &s[1], &rwork[ie], &rwork[iru], n,
                            &rwork[irvt], n, dum, idum, &rwork[nrwork], &iwork[1], info);

                        // Copy real matrix RWORK(IRU) to complex matrix U
                        // Overwrite U by left singular vectors of A
                        // (CWorkspace: need 3*N, prefer 2*N+N*NB)
                        // (RWorkspace: 0)

                        zlaset("F", m, n, &c_b1, &c_b1, &u[u_offset], ldu);
                        zlacp2("F", n, n, &rwork[iru], n, &u[u_offset], ldu);
                        i__2 = *lwork - nwork + 1;
                        zunmbr("Q", "L", "N", m, n, n, &a[a_offset], lda, &work[itauq],
                            &u[u_offset], ldu, &work[nwork], &i__2, &ierr);

                        // Copy real matrix RWORK(IRVT) to complex matrix VT
                        // Overwrite VT by right singular vectors of A
                        // (CWorkspace: need 3*N, prefer 2*N+N*NB)
                        // (RWorkspace: 0)

                        zlacp2("F", n, n, &rwork[irvt], n, &vt[vt_offset], ldvt);
                        i__2 = *lwork - nwork + 1;
                        zunmbr("P", "R", "C", n, n, n, &a[a_offset], lda, &work[itaup],
                            &vt[vt_offset], ldvt, &work[nwork], &i__2, &ierr);
                    }
                    else
                    {
                        // Perform bidiagonal SVD, computing left singular vectors
                        // of bidiagonal matrix in RWORK(IRU) and computing right
                        // singular vectors of bidiagonal matrix in RWORK(IRVT)
                        // (CWorkspace: need 0)
                        // (RWorkspace: need BDSPAC)

                        iru = nrwork;
                        irvt = iru + *n * *n;
                        nrwork = irvt + *n * *n;
                        dbdsdc("U", "I", n, &s[1], &rwork[ie], &rwork[iru], n,
                            &rwork[irvt], n, dum, idum, &rwork[nrwork], &iwork[1], info);

                        // Set the right corner of U to identity matrix

                        zlaset("F", m, m, &c_b1, &c_b1, &u[u_offset], ldu);

                        if (*m > *n)
                        {
                            i__2 = *m - *n;
                            i__1 = *m - *n;
                            zlaset("F", &i__2, &i__1, &c_b1, &c_b2, &u[*n + 1 + (*n + 1) * u_dim1], ldu);
                        }

                        // Copy real matrix RWORK(IRU) to complex matrix U
                        // Overwrite U by left singular vectors of A
                        // (CWorkspace: need 2*N+M, prefer 2*N+M*NB)
                        // (RWorkspace: 0)

                        zlacp2("F", n, n, &rwork[iru], n, &u[u_offset], ldu);
                        i__2 = *lwork - nwork + 1;
                        zunmbr("Q", "L", "N", m, m, n, &a[a_offset], lda,
                            &work[itauq], &u[u_offset], ldu, &work[nwork], &i__2, &ierr);

                        // Copy real matrix RWORK(IRVT) to complex matrix VT
                        // Overwrite VT by right singular vectors of A
                        // (CWorkspace: need 3*N, prefer 2*N+N*NB)
                        // (RWorkspace: 0)

                        zlacp2("F", n, n, &rwork[irvt], n, &vt[vt_offset], ldvt);
                        i__2 = *lwork - nwork + 1;
                        zunmbr("P", "R", "C", n, n, n, &a[a_offset], lda, &work[itaup],
                            &vt[vt_offset], ldvt, &work[nwork], &i__2, &ierr);
                    }
                }
            }
            else
            {
                // A has more columns than rows. If A has sufficiently more
                // columns than rows, first reduce using the LQ decomposition (if
                // sufficient workspace available)

                if (*n >= mnthr1)
                {
                    if (wntqn)
                    {
                        // Path 1t (N much larger than M, JOBZ='N')
                        // No singular vectors to be computed

                        itau = 1;
                        nwork = itau + *m;

                        // Compute A=L*Q
                        // (CWorkspace: need 2*M, prefer M+M*NB)
                        // (RWorkspace: 0)

                        i__2 = *lwork - nwork + 1;
                        zgelqf(m, n, &a[a_offset], lda, &work[itau], &work[nwork], &i__2, &ierr);

                        // Zero out above L

                        i__2 = *m - 1;
                        i__1 = *m - 1;
                        zlaset("U", &i__2, &i__1, &c_b1, &c_b1, &a[(a_dim1 << 1) + 1], lda);
                        ie = 1;
                        itauq = 1;
                        itaup = itauq + *m;
                        nwork = itaup + *m;

                        // Bidiagonalize L in A
                        // (CWorkspace: need 3*M, prefer 2*M+2*M*NB)
                        // (RWorkspace: need M)

                        i__2 = *lwork - nwork + 1;
                        zgebrd(m, m, &a[a_offset], lda, &s[1], &rwork[ie],
                            &work[itauq], &work[itaup], &work[nwork], &i__2, &ierr);
                        nrwork = ie + *m;

                        // Perform bidiagonal SVD, compute singular values only
                        // (CWorkspace: 0)
                        // (RWorkspace: need BDSPAN)

                        dbdsdc("U", "N", m, &s[1], &rwork[ie], dum, &c__1, dum,
                            &c__1, dum, idum, &rwork[nrwork], &iwork[1], info);
                    }
                    else if (wntqo)
                    {
                        // Path 2t (N much larger than M, JOBZ='O')
                        // M right singular vectors to be overwritten on A and
                        // M left singular vectors to be computed in U

                        ivt = 1;
                        ldwkvt = *m;

                        // WORK(IVT) is M by M

                        il = ivt + ldwkvt * *m;
                        if (*lwork >= *m * *n + *m * *m + *m * 3)
                        {
                            // WORK(IL) M by N

                            ldwrkl = *m;
                            chunk = *n;
                        }
                        else
                        {
                            // WORK(IL) is M by CHUNK

                            ldwrkl = *m;
                            chunk = (*lwork - *m * *m - *m * 3) / *m;
                        }
                        itau = il + ldwrkl * chunk;
                        nwork = itau + *m;

                        // Compute A=L*Q
                        // (CWorkspace: need 2*M, prefer M+M*NB)
                        // (RWorkspace: 0)

                        i__2 = *lwork - nwork + 1;
                        zgelqf(m, n, &a[a_offset], lda, &work[itau], &work[nwork], &i__2, &ierr);

                        // Copy L to WORK(IL), zeroing about above it

                        zlacpy("L", m, m, &a[a_offset], lda, &work[il], &ldwrkl);
                        i__2 = *m - 1;
                        i__1 = *m - 1;
                        zlaset("U", &i__2, &i__1, &c_b1, &c_b1, &work[il + ldwrkl], &ldwrkl);

                        // Generate Q in A
                        // (CWorkspace: need M*M+2*M, prefer M*M+M+M*NB)
                        // (RWorkspace: 0)

                        i__2 = *lwork - nwork + 1;
                        zunglq(m, n, m, &a[a_offset], lda, &work[itau], &work[nwork], &i__2, &ierr);
                        ie = 1;
                        itauq = itau;
                        itaup = itauq + *m;
                        nwork = itaup + *m;

                        // Bidiagonalize L in WORK(IL)
                        // (CWorkspace: need M*M+3*M, prefer M*M+2*M+2*M*NB)
                        // (RWorkspace: need M)

                        i__2 = *lwork - nwork + 1;
                        zgebrd(m, m, &work[il], &ldwrkl, &s[1], &rwork[ie],
                            &work[itauq], &work[itaup], &work[nwork], &i__2, &ierr);

                        // Perform bidiagonal SVD, computing left singular vectors
                        // of bidiagonal matrix in RWORK(IRU) and computing right
                        // singular vectors of bidiagonal matrix in RWORK(IRVT)
                        // (CWorkspace: need 0)
                        // (RWorkspace: need BDSPAC)

                        iru = ie + *m;
                        irvt = iru + *m * *m;
                        nrwork = irvt + *m * *m;
                        dbdsdc("U", "I", m, &s[1], &rwork[ie], &rwork[iru], m,
                            &rwork[irvt], m, dum, idum, &rwork[nrwork], &iwork[1], info);

                        // Copy real matrix RWORK(IRU) to complex matrix WORK(IU)
                        // Overwrite WORK(IU) by the left singular vectors of L
                        // (CWorkspace: need N*N+3*N, prefer M*N+2*N+N*NB)
                        // (RWorkspace: 0)

                        zlacp2("F", m, m, &rwork[iru], m, &u[u_offset], ldu);
                        i__2 = *lwork - nwork + 1;
                        zunmbr("Q", "L", "N", m, m, m, &work[il], &ldwrkl,
                            &work[itauq], &u[u_offset], ldu, &work[nwork], &i__2, &ierr);

                        // Copy real matrix RWORK(IRVT) to complex matrix WORK(IVT)
                        // Overwrite WORK(IVT) by the right singular vectors of L
                        // (CWorkspace: need N*N+3*N, prefer M*N+2*N+N*NB)
                        // (RWorkspace: 0)

                        zlacp2("F", m, m, &rwork[irvt], m, &work[ivt], &ldwkvt);
                        i__2 = *lwork - nwork + 1;
                        zunmbr("P", "R", "C", m, m, m, &work[il], &ldwrkl,
                            &work[itaup], &work[ivt], &ldwkvt, &work[nwork], &i__2, &ierr);

                        // Multiply right singular vectors of L in WORK(IL) by Q
                        // in A, storing result in WORK(IL) and copying to A
                        // (CWorkspace: need 2*M*M, prefer M*M+M*N))
                        // (RWorkspace: 0)

                        i__2 = *n;
                        i__1 = chunk;
                        for (i = 1; i__1 < 0 ? i >= i__2 : i <= i__2; i += i__1)
                        {
                            // Computing MIN
                            i__3 = *n - i + 1;
                            blk = Math.Min(i__3, chunk);
                            zgemm("N", "N", m, &blk, m, &c_b2, &work[ivt], m,
                                &a[i * a_dim1 + 1], lda, &c_b1, &work[il], &ldwrkl);
                            zlacpy("F", m, &blk, &work[il], &ldwrkl, &a[i * a_dim1 + 1], lda);
                        }
                    }
                    else if (wntqs)
                    {
                        // Path 3t (N much larger than M, JOBZ='S')
                        // M right singular vectors to be computed in VT and
                        // M left singular vectors to be computed in U

                        il = 1;

                        // WORK(IL) is M by M

                        ldwrkl = *m;
                        itau = il + ldwrkl * *m;
                        nwork = itau + *m;

                        // Compute A=L*Q
                        // (CWorkspace: need 2*M, prefer M+M*NB)
                        // (RWorkspace: 0)

                        i__1 = *lwork - nwork + 1;
                        zgelqf(m, n, &a[a_offset], lda, &work[itau], &work[nwork], &i__1, &ierr);

                        // Copy L to WORK(IL), zeroing out above it

                        zlacpy("L", m, m, &a[a_offset], lda, &work[il], &ldwrkl);
                        i__1 = *m - 1;
                        i__2 = *m - 1;
                        zlaset("U", &i__1, &i__2, &c_b1, &c_b1, &work[il + ldwrkl], &ldwrkl);

                        // Generate Q in A
                        // (CWorkspace: need M*M+2*M, prefer M*M+M+M*NB)
                        // (RWorkspace: 0)

                        i__1 = *lwork - nwork + 1;
                        zunglq(m, n, m, &a[a_offset], lda, &work[itau], &work[nwork], &i__1, &ierr);
                        ie = 1;
                        itauq = itau;
                        itaup = itauq + *m;
                        nwork = itaup + *m;

                        // Bidiagonalize L in WORK(IL)
                        // (CWorkspace: need M*M+3*M, prefer M*M+2*M+2*M*NB)
                        // (RWorkspace: need M)

                        i__1 = *lwork - nwork + 1;
                        zgebrd(m, m, &work[il], &ldwrkl, &s[1], &rwork[ie],
                            &work[itauq], &work[itaup], &work[nwork], &i__1, &ierr);

                        // Perform bidiagonal SVD, computing left singular vectors
                        // of bidiagonal matrix in RWORK(IRU) and computing right
                        // singular vectors of bidiagonal matrix in RWORK(IRVT)
                        // (CWorkspace: need 0)
                        // (RWorkspace: need BDSPAC)

                        iru = ie + *m;
                        irvt = iru + *m * *m;
                        nrwork = irvt + *m * *m;
                        dbdsdc("U", "I", m, &s[1], &rwork[ie], &rwork[iru], m,
                            &rwork[irvt], m, dum, idum, &rwork[nrwork], &iwork[1], info);

                        // Copy real matrix RWORK(IRU) to complex matrix U
                        // Overwrite U by left singular vectors of L
                        // (CWorkspace: need M*M+3*M, prefer M*M+2*M+M*NB)
                        // (RWorkspace: 0)

                        zlacp2("F", m, m, &rwork[iru], m, &u[u_offset], ldu);
                        i__1 = *lwork - nwork + 1;
                        zunmbr("Q", "L", "N", m, m, m, &work[il], &ldwrkl,
                            &work[itauq], &u[u_offset], ldu, &work[nwork], &i__1, &ierr);

                        // Copy real matrix RWORK(IRVT) to complex matrix VT
                        // Overwrite VT by left singular vectors of L
                        // (CWorkspace: need M*M+3*M, prefer M*M+2*M+M*NB)
                        // (RWorkspace: 0)

                        zlacp2("F", m, m, &rwork[irvt], m, &vt[vt_offset], ldvt);
                        i__1 = *lwork - nwork + 1;
                        zunmbr("P", "R", "C", m, m, m, &work[il], &ldwrkl,
                            &work[itaup], &vt[vt_offset], ldvt, &work[nwork], &i__1, &ierr);

                        // Copy VT to WORK(IL), multiply right singular vectors of L
                        // in WORK(IL) by Q in A, storing result in VT
                        // (CWorkspace: need M*M)
                        // (RWorkspace: 0)

                        zlacpy("F", m, m, &vt[vt_offset], ldvt, &work[il], &ldwrkl);
                        zgemm("N", "N", m, n, m, &c_b2, &work[il], &ldwrkl,
                            &a[a_offset], lda, &c_b1, &vt[vt_offset], ldvt);
                    }
                    else if (wntqa)
                    {
                        // Path 9t (N much larger than M, JOBZ='A')
                        // N right singular vectors to be computed in VT and
                        // M left singular vectors to be computed in U

                        ivt = 1;

                        // WORK(IVT) is M by M

                        ldwkvt = *m;
                        itau = ivt + ldwkvt * *m;
                        nwork = itau + *m;

                        // Compute A=L*Q, copying result to VT
                        // (CWorkspace: need 2*M, prefer M+M*NB)
                        // (RWorkspace: 0)

                        i__1 = *lwork - nwork + 1;
                        zgelqf(m, n, &a[a_offset], lda, &work[itau], &work[nwork], &i__1, &ierr);
                        zlacpy("U", m, n, &a[a_offset], lda, &vt[vt_offset], ldvt);

                        // Generate Q in VT
                        // (CWorkspace: need M+N, prefer M+N*NB)
                        // (RWorkspace: 0)

                        i__1 = *lwork - nwork + 1;
                        zunglq(n, n, m, &vt[vt_offset], ldvt, &work[itau], &work[nwork], &i__1, &ierr);

                        // Produce L in A, zeroing out above it

                        i__1 = *m - 1;
                        i__2 = *m - 1;
                        zlaset("U", &i__1, &i__2, &c_b1, &c_b1, &a[(a_dim1 << 1) + 1], lda);
                        ie = 1;
                        itauq = itau;
                        itaup = itauq + *m;
                        nwork = itaup + *m;

                        // Bidiagonalize L in A
                        // (CWorkspace: need M*M+3*M, prefer M*M+2*M+2*M*NB)
                        // (RWorkspace: need M)

                        i__1 = *lwork - nwork + 1;
                        zgebrd(m, m, &a[a_offset], lda, &s[1], &rwork[ie],
                            &work[itauq], &work[itaup], &work[nwork], &i__1, &ierr);

                        // Perform bidiagonal SVD, computing left singular vectors
                        // of bidiagonal matrix in RWORK(IRU) and computing right
                        // singular vectors of bidiagonal matrix in RWORK(IRVT)
                        // (CWorkspace: need 0)
                        // (RWorkspace: need BDSPAC)

                        iru = ie + *m;
                        irvt = iru + *m * *m;
                        nrwork = irvt + *m * *m;
                        dbdsdc("U", "I", m, &s[1], &rwork[ie], &rwork[iru], m,
                            &rwork[irvt], m, dum, idum, &rwork[nrwork], &iwork[1], info);

                        // Copy real matrix RWORK(IRU) to complex matrix U
                        // Overwrite U by left singular vectors of L
                        // (CWorkspace: need 3*M, prefer 2*M+M*NB)
                        // (RWorkspace: 0)

                        zlacp2("F", m, m, &rwork[iru], m, &u[u_offset], ldu);
                        i__1 = *lwork - nwork + 1;
                        zunmbr("Q", "L", "N", m, m, m, &a[a_offset], lda,
                            &work[itauq], &u[u_offset], ldu, &work[nwork], &i__1, &ierr);

                        // Copy real matrix RWORK(IRVT) to complex matrix WORK(IVT)
                        // Overwrite WORK(IVT) by right singular vectors of L
                        // (CWorkspace: need M*M+3*M, prefer M*M+2*M+M*NB)
                        // (RWorkspace: 0)

                        zlacp2("F", m, m, &rwork[irvt], m, &work[ivt], &ldwkvt);
                        i__1 = *lwork - nwork + 1;
                        zunmbr("P", "R", "C", m, m, m, &a[a_offset], lda,
                            &work[itaup], &work[ivt], &ldwkvt, &work[nwork], &i__1, &ierr);

                        // Multiply right singular vectors of L in WORK(IVT) by
                        // Q in VT, storing result in A
                        // (CWorkspace: need M*M)
                        // (RWorkspace: 0)

                        zgemm("N", "N", m, n, m, &c_b2, &work[ivt], &ldwkvt,
                            &vt[vt_offset], ldvt, &c_b1, &a[a_offset], lda);

                        // Copy right singular vectors of A from A to VT

                        zlacpy("F", m, n, &a[a_offset], lda, &vt[vt_offset], ldvt);
                    }
                }
                else if (*n >= mnthr2)
                {
                    // MNTHR2 <= N < MNTHR1

                    // Path 5t (N much larger than M, but not as much as MNTHR1)
                    // Reduce to bidiagonal form without QR decomposition, use
                    // ZUNGBR and matrix multiplication to compute singular vectors

                    ie = 1;
                    nrwork = ie + *m;
                    itauq = 1;
                    itaup = itauq + *m;
                    nwork = itaup + *m;

                    // Bidiagonalize A
                    // (CWorkspace: need 2*M+N, prefer 2*M+(M+N)*NB)
                    // (RWorkspace: M)

                    i__1 = *lwork - nwork + 1;
                    zgebrd(m, n, &a[a_offset], lda, &s[1], &rwork[ie],
                        &work[itauq], &work[itaup], &work[nwork], &i__1, &ierr);

                    if (wntqn)
                    {
                        // Compute singular values only
                        // (Cworkspace: 0)
                        // (Rworkspace: need BDSPAN)

                        dbdsdc("L", "N", m, &s[1], &rwork[ie], dum, &c__1, dum,
                            &c__1, dum, idum, &rwork[nrwork], &iwork[1], info);
                    }
                    else if (wntqo)
                    {
                        irvt = nrwork;
                        iru = irvt + *m * *m;
                        nrwork = iru + *m * *m;
                        ivt = nwork;

                        // Copy A to U, generate Q
                        // (Cworkspace: need 2*M, prefer M+M*NB)
                        // (Rworkspace: 0)

                        zlacpy("L", m, m, &a[a_offset], lda, &u[u_offset], ldu);
                        i__1 = *lwork - nwork + 1;
                        zungbr("Q", m, m, n, &u[u_offset], ldu, &work[itauq], &work[nwork], &i__1, &ierr);

                        // Generate P**H in A
                        // (Cworkspace: need 2*M, prefer M+M*NB)
                        // (Rworkspace: 0)

                        i__1 = *lwork - nwork + 1;
                        zungbr("P", m, n, m, &a[a_offset], lda, &work[itaup], &work[nwork], &i__1, &ierr);

                        ldwkvt = *m;
                        if (*lwork >= *m * *n + *m * 3)
                        {
                            // WORK( IVT ) is M by N

                            nwork = ivt + ldwkvt * *n;
                            chunk = *n;
                        }
                        else
                        {
                            // WORK( IVT ) is M by CHUNK

                            chunk = (*lwork - *m * 3) / *m;
                            nwork = ivt + ldwkvt * chunk;
                        }

                        // Perform bidiagonal SVD, computing left singular vectors
                        // of bidiagonal matrix in RWORK(IRU) and computing right
                        // singular vectors of bidiagonal matrix in RWORK(IRVT)
                        // (CWorkspace: need 0)
                        // (RWorkspace: need BDSPAC)

                        dbdsdc("L", "I", m, &s[1], &rwork[ie], &rwork[iru], m,
                            &rwork[irvt], m, dum, idum, &rwork[nrwork], &iwork[1], info);

                        // Multiply Q in U by real matrix RWORK(IRVT)
                        // storing the result in WORK(IVT), copying to U
                        // (Cworkspace: need 0)
                        // (Rworkspace: need 2*M*M)

                        zlacrm(m, m, &u[u_offset], ldu, &rwork[iru], m, &work[ivt], &ldwkvt, &rwork[nrwork]);
                        zlacpy("F", m, m, &work[ivt], &ldwkvt, &u[u_offset], ldu);

                        // Multiply RWORK(IRVT) by P**H in A, storing the
                        // result in WORK(IVT), copying to A
                        // (CWorkspace: need M*M, prefer M*N)
                        // (Rworkspace: need 2*M*M, prefer 2*M*N)

                        nrwork = iru;
                        i__1 = *n;
                        i__2 = chunk;
                        for (i = 1; i__2 < 0 ? i >= i__1 : i <= i__1; i += i__2)
                        {
                            // Computing MIN
                            i__3 = *n - i + 1;
                            blk = Math.Min(i__3, chunk);
                            zlarcm(m, &blk, &rwork[irvt], m, &a[i * a_dim1 + 1],
                                lda, &work[ivt], &ldwkvt, &rwork[nrwork]);
                            zlacpy("F", m, &blk, &work[ivt], &ldwkvt, &a[i * a_dim1 + 1], lda);
                        }
                    }
                    else if (wntqs)
                    {
                        // Copy A to U, generate Q
                        // (Cworkspace: need 2*M, prefer M+M*NB)
                        // (Rworkspace: 0)

                        zlacpy("L", m, m, &a[a_offset], lda, &u[u_offset], ldu);
                        i__2 = *lwork - nwork + 1;
                        zungbr("Q", m, m, n, &u[u_offset], ldu, &work[itauq], &work[nwork], &i__2, &ierr);

                        // Copy A to VT, generate P**H
                        // (Cworkspace: need 2*M, prefer M+M*NB)
                        // (Rworkspace: 0)

                        zlacpy("U", m, n, &a[a_offset], lda, &vt[vt_offset], ldvt);
                        i__2 = *lwork - nwork + 1;
                        zungbr("P", m, n, m, &vt[vt_offset], ldvt, &work[itaup], &work[nwork], &i__2, &ierr);

                        // Perform bidiagonal SVD, computing left singular vectors
                        // of bidiagonal matrix in RWORK(IRU) and computing right
                        // singular vectors of bidiagonal matrix in RWORK(IRVT)
                        // (CWorkspace: need 0)
                        // (RWorkspace: need BDSPAC)

                        irvt = nrwork;
                        iru = irvt + *m * *m;
                        nrwork = iru + *m * *m;
                        dbdsdc("L", "I", m, &s[1], &rwork[ie], &rwork[iru], m,
                            &rwork[irvt], m, dum, idum, &rwork[nrwork], &iwork[1], info);

                        // Multiply Q in U by real matrix RWORK(IRU), storing the
                        // result in A, copying to U
                        // (CWorkspace: need 0)
                        // (Rworkspace: need 3*M*M)

                        zlacrm(m, m, &u[u_offset], ldu, &rwork[iru], m, &a[a_offset], lda, &rwork[nrwork]);
                        zlacpy("F", m, m, &a[a_offset], lda, &u[u_offset], ldu);

                        // Multiply real matrix RWORK(IRVT) by P**H in VT,
                        // storing the result in A, copying to VT
                        // (Cworkspace: need 0)
                        // (Rworkspace: need M*M+2*M*N)

                        nrwork = iru;
                        zlarcm(m, n, &rwork[irvt], m, &vt[vt_offset], ldvt, &a[a_offset], lda, &rwork[nrwork]);
                        zlacpy("F", m, n, &a[a_offset], lda, &vt[vt_offset], ldvt);
                    }
                    else
                    {
                        // Copy A to U, generate Q
                        // (Cworkspace: need 2*M, prefer M+M*NB)
                        // (Rworkspace: 0)

                        zlacpy("L", m, m, &a[a_offset], lda, &u[u_offset], ldu);
                        i__2 = *lwork - nwork + 1;
                        zungbr("Q", m, m, n, &u[u_offset], ldu, &work[itauq], &work[nwork], &i__2, &ierr);

                        // Copy A to VT, generate P**H
                        // (Cworkspace: need 2*M, prefer M+M*NB)
                        // (Rworkspace: 0)

                        zlacpy("U", m, n, &a[a_offset], lda, &vt[vt_offset], ldvt);
                        i__2 = *lwork - nwork + 1;
                        zungbr("P", n, n, m, &vt[vt_offset], ldvt, &work[itaup], &work[nwork], &i__2, &ierr);

                        // Perform bidiagonal SVD, computing left singular vectors
                        // of bidiagonal matrix in RWORK(IRU) and computing right
                        // singular vectors of bidiagonal matrix in RWORK(IRVT)
                        // (CWorkspace: need 0)
                        // (RWorkspace: need BDSPAC)

                        irvt = nrwork;
                        iru = irvt + *m * *m;
                        nrwork = iru + *m * *m;
                        dbdsdc("L", "I", m, &s[1], &rwork[ie], &rwork[iru], m,
                            &rwork[irvt], m, dum, idum, &rwork[nrwork], &iwork[1], info);

                        // Multiply Q in U by real matrix RWORK(IRU), storing the
                        // result in A, copying to U
                        // (CWorkspace: need 0)
                        // (Rworkspace: need 3*M*M)

                        zlacrm(m, m, &u[u_offset], ldu, &rwork[iru], m, &a[a_offset], lda, &rwork[nrwork]);
                        zlacpy("F", m, m, &a[a_offset], lda, &u[u_offset], ldu);

                        // Multiply real matrix RWORK(IRVT) by P**H in VT,
                        // storing the result in A, copying to VT
                        // (Cworkspace: need 0)
                        // (Rworkspace: need M*M+2*M*N)

                        zlarcm(m, n, &rwork[irvt], m, &vt[vt_offset], ldvt, &a[a_offset], lda, &rwork[nrwork]);
                        zlacpy("F", m, n, &a[a_offset], lda, &vt[vt_offset], ldvt);
                    }
                }
                else
                {
                    // N .LT. MNTHR2

                    // Path 6t (N greater than M, but not much larger)
                    // Reduce to bidiagonal form without LQ decomposition
                    // Use ZUNMBR to compute singular vectors

                    ie = 1;
                    nrwork = ie + *m;
                    itauq = 1;
                    itaup = itauq + *m;
                    nwork = itaup + *m;

                    // Bidiagonalize A
                    // (CWorkspace: need 2*M+N, prefer 2*M+(M+N)*NB)
                    // (RWorkspace: M)

                    i__2 = *lwork - nwork + 1;
                    zgebrd(m, n, &a[a_offset], lda, &s[1], &rwork[ie],
                        &work[itauq], &work[itaup], &work[nwork], &i__2, &ierr);

                    if (wntqn)
                    {
                        // Compute singular values only
                        // (Cworkspace: 0)
                        // (Rworkspace: need BDSPAN)

                        dbdsdc("L", "N", m, &s[1], &rwork[ie], dum, &c__1, dum,
                            &c__1, dum, idum, &rwork[nrwork], &iwork[1], info);
                    }
                    else if (wntqo)
                    {
                        ldwkvt = *m;
                        ivt = nwork;
                        if (*lwork >= *m * *n + *m * 3)
                        {
                            // WORK( IVT ) is M by N

                            zlaset("F", m, n, &c_b1, &c_b1, &work[ivt], &ldwkvt);
                            nwork = ivt + ldwkvt * *n;
                        }
                        else
                        {
                            // WORK( IVT ) is M by CHUNK

                            chunk = (*lwork - *m * 3) / *m;
                            nwork = ivt + ldwkvt * chunk;
                        }

                        // Perform bidiagonal SVD, computing left singular vectors
                        // of bidiagonal matrix in RWORK(IRU) and computing right
                        // singular vectors of bidiagonal matrix in RWORK(IRVT)
                        // (CWorkspace: need 0)
                        // (RWorkspace: need BDSPAC)

                        irvt = nrwork;
                        iru = irvt + *m * *m;
                        nrwork = iru + *m * *m;
                        dbdsdc("L", "I", m, &s[1], &rwork[ie], &rwork[iru], m,
                            &rwork[irvt], m, dum, idum, &rwork[nrwork], &iwork[1], info);

                        // Copy real matrix RWORK(IRU) to complex matrix U
                        // Overwrite U by left singular vectors of A
                        // (Cworkspace: need 2*M, prefer M+M*NB)
                        // (Rworkspace: need 0)

                        zlacp2("F", m, m, &rwork[iru], m, &u[u_offset], ldu);
                        i__2 = *lwork - nwork + 1;
                        zunmbr("Q", "L", "N", m, m, n, &a[a_offset], lda,
                            &work[itauq], &u[u_offset], ldu, &work[nwork], &i__2, &ierr);

                        if (*lwork >= *m * *n + *m * 3)
                        {
                            // Copy real matrix RWORK(IRVT) to complex matrix WORK(IVT)
                            // Overwrite WORK(IVT) by right singular vectors of A,
                            // copying to A
                            // (Cworkspace: need M*N+2*M, prefer M*N+M+M*NB)
                            // (Rworkspace: need 0)

                            zlacp2("F", m, m, &rwork[irvt], m, &work[ivt], &ldwkvt);
                            i__2 = *lwork - nwork + 1;
                            zunmbr("P", "R", "C", m, n, m, &a[a_offset], lda,
                                &work[itaup], &work[ivt], &ldwkvt, &work[nwork], &i__2, &ierr);
                            zlacpy("F", m, n, &work[ivt], &ldwkvt, &a[a_offset], lda);
                        }
                        else
                        {
                            // Generate P**H in A
                            // (Cworkspace: need 2*M, prefer M+M*NB)
                            // (Rworkspace: need 0)

                            i__2 = *lwork - nwork + 1;
                            zungbr("P", m, n, m, &a[a_offset], lda, &work[itaup], &work[nwork], &i__2, &ierr);

                            // Multiply Q in A by real matrix RWORK(IRU), storing the
                            // result in WORK(IU), copying to A
                            // (CWorkspace: need M*M, prefer M*N)
                            // (Rworkspace: need 3*M*M, prefer M*M+2*M*N)

                            nrwork = iru;
                            i__2 = *n;
                            i__1 = chunk;
                            for (i = 1; i__1 < 0 ? i >= i__2 : i <= i__2; i += i__1)
                            {
                                // Computing MIN
                                i__3 = *n - i + 1;
                                blk = Math.Min(i__3, chunk);
                                zlarcm(m, &blk, &rwork[irvt], m, &a[i * a_dim1 + 1],
                                    lda, &work[ivt], &ldwkvt, &rwork[nrwork]);
                                zlacpy("F", m, &blk, &work[ivt], &ldwkvt, &a[i * a_dim1 + 1], lda);
                            }
                        }
                    }
                    else if (wntqs)
                    {
                        // Perform bidiagonal SVD, computing left singular vectors
                        // of bidiagonal matrix in RWORK(IRU) and computing right
                        // singular vectors of bidiagonal matrix in RWORK(IRVT)
                        // (CWorkspace: need 0)
                        // (RWorkspace: need BDSPAC)

                        irvt = nrwork;
                        iru = irvt + *m * *m;
                        nrwork = iru + *m * *m;
                        dbdsdc("L", "I", m, &s[1], &rwork[ie], &rwork[iru], m,
                            &rwork[irvt], m, dum, idum, &rwork[nrwork], &iwork[1], info);

                        // Copy real matrix RWORK(IRU) to complex matrix U
                        // Overwrite U by left singular vectors of A
                        // (CWorkspace: need 3*M, prefer 2*M+M*NB)
                        // (RWorkspace: M*M)

                        zlacp2("F", m, m, &rwork[iru], m, &u[u_offset], ldu);
                        i__1 = *lwork - nwork + 1;
                        zunmbr("Q", "L", "N", m, m, n, &a[a_offset], lda, &work[itauq],
                            &u[u_offset], ldu, &work[nwork], &i__1, &ierr);

                        // Copy real matrix RWORK(IRVT) to complex matrix VT
                        // Overwrite VT by right singular vectors of A
                        // (CWorkspace: need 3*M, prefer 2*M+M*NB)
                        // (RWorkspace: M*M)

                        zlaset("F", m, n, &c_b1, &c_b1, &vt[vt_offset], ldvt);
                        zlacp2("F", m, m, &rwork[irvt], m, &vt[vt_offset], ldvt);
                        i__1 = *lwork - nwork + 1;
                        zunmbr("P", "R", "C", m, n, m, &a[a_offset], lda, &work[itaup],
                            &vt[vt_offset], ldvt, &work[nwork], &i__1, &ierr);
                    }
                    else
                    {
                        // Perform bidiagonal SVD, computing left singular vectors
                        // of bidiagonal matrix in RWORK(IRU) and computing right
                        // singular vectors of bidiagonal matrix in RWORK(IRVT)
                        // (CWorkspace: need 0)
                        // (RWorkspace: need BDSPAC)

                        irvt = nrwork;
                        iru = irvt + *m * *m;
                        nrwork = iru + *m * *m;

                        dbdsdc("L", "I", m, &s[1], &rwork[ie], &rwork[iru], m,
                            &rwork[irvt], m, dum, idum, &rwork[nrwork], &iwork[1], info);

                        // Copy real matrix RWORK(IRU) to complex matrix U
                        // Overwrite U by left singular vectors of A
                        // (CWorkspace: need 3*M, prefer 2*M+M*NB)
                        // (RWorkspace: M*M)

                        zlacp2("F", m, m, &rwork[iru], m, &u[u_offset], ldu);
                        i__1 = *lwork - nwork + 1;
                        zunmbr("Q", "L", "N", m, m, n, &a[a_offset], lda,
                            &work[itauq], &u[u_offset], ldu, &work[nwork], &i__1, &ierr);

                        // Set all of VT to identity matrix

                        zlaset("F", n, n, &c_b1, &c_b2, &vt[vt_offset], ldvt);

                        // Copy real matrix RWORK(IRVT) to complex matrix VT
                        // Overwrite VT by right singular vectors of A
                        // (CWorkspace: need 2*M+N, prefer 2*M+N*NB)
                        // (RWorkspace: M*M)

                        zlacp2("F", m, m, &rwork[irvt], m, &vt[vt_offset], ldvt);
                        i__1 = *lwork - nwork + 1;
                        zunmbr("P", "R", "C", n, n, m, &a[a_offset], lda, &work[itaup],
                            &vt[vt_offset], ldvt, &work[nwork], &i__1, &ierr);
                    }

                }

            }

            // Undo scaling if necessary

            if (iscl == 1)
            {
                if (anrm > bignum)
                {
                    dlascl("G", &c__0, &c__0, &bignum, &anrm, &minmn, &c__1, &s[1], &minmn, &ierr);
                }
                if (*info != 0 && anrm > bignum)
                {
                    i__1 = minmn - 1;
                    dlascl("G", &c__0, &c__0, &bignum, &anrm, &i__1, &c__1, &rwork[ie], &minmn, &ierr);
                }
                if (anrm < smlnum)
                {
                    dlascl("G", &c__0, &c__0, &smlnum, &anrm, &minmn, &c__1, &s[1], &minmn, &ierr);
                }
                if (*info != 0 && anrm < smlnum)
                {
                    i__1 = minmn - 1;
                    dlascl("G", &c__0, &c__0, &smlnum, &anrm, &i__1, &c__1, &rwork[ie], &minmn, &ierr);
                }
            }

            // Return optimal workspace in WORK(1)

            work[1].r = (double)maxwrk;
            work[1].i = 0.0;

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zhseqr(string job, string compz, int* n, int* ilo,
             int* ihi, complex16* h, int* ldh, complex16* w,
            complex16* z, int* ldz, complex16* work, int* lwork, int* info)
        {
            //  -- LAPACK driver routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd.. 
            //     November 2006 

            //     Purpose 
            //     ======= 

            //     ZHSEQR computes the eigenvalues of a Hessenberg matrix H 
            //     and, optionally, the matrices T and Z from the Schur decomposition 
            //     H = Z T Z**H, where T is an upper triangular matrix (the 
            //     Schur form), and Z is the unitary matrix of Schur vectors. 

            //     Optionally Z may be postmultiplied into an input unitary 
            //     matrix Q so that this routine can give the Schur factorization 
            //     of a matrix A which has been reduced to the Hessenberg form H 
            //     by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*H*(QZ)**H. 

            //     Arguments 
            //     ========= 

            //     JOB   (input) CHARACTER*1 
            //           = 'E':  compute eigenvalues only; 
            //           = 'S':  compute eigenvalues and the Schur form T. 

            //     COMPZ (input) CHARACTER*1 
            //           = 'N':  no Schur vectors are computed; 
            //           = 'I':  Z is initialized to the unit matrix and the matrix Z 
            //                   of Schur vectors of H is returned; 
            //           = 'V':  Z must contain an unitary matrix Q on entry, and 
            //                   the product Q*Z is returned. 

            //     N     (input) int 
            //           The order of the matrix H.  N .GE. 0. 

            //     ILO   (input) int 
            //     IHI   (input) int 
            //           It is assumed that H is already upper triangular in rows 
            //           and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally 
            //           set by a previous call to ZGEBAL, and then passed to ZGEHRD 
            //           when the matrix output by ZGEBAL is reduced to Hessenberg 
            //           form. Otherwise ILO and IHI should be set to 1 and N 
            //           respectively.  If N.GT.0, then 1.LE.ILO.LE.IHI.LE.N. 
            //           If N = 0, then ILO = 1 and IHI = 0. 

            //     H     (input/output) COMPLEX*16 array, dimension (LDH,N) 
            //           On entry, the upper Hessenberg matrix H. 
            //           On exit, if INFO = 0 and JOB = 'S', H contains the upper 
            //           triangular matrix T from the Schur decomposition (the 
            //           Schur form). If INFO = 0 and JOB = 'E', the contents of 
            //           H are unspecified on exit.  (The output value of H when 
            //           INFO.GT.0 is given under the description of INFO below.) 

            //           Unlike earlier versions of ZHSEQR, this subroutine may 
            //           explicitly H(i,j) = 0 for i.GT.j and j = 1, 2, ... ILO-1 
            //           or j = IHI+1, IHI+2, ... N. 

            //     LDH   (input) int 
            //           The leading dimension of the array H. LDH .GE. max(1,N). 

            //     W        (output) COMPLEX*16 array, dimension (N) 
            //           The computed eigenvalues. If JOB = 'S', the eigenvalues are 
            //           stored in the same order as on the diagonal of the Schur 
            //           form returned in H, with W(i) = H(i,i). 

            //     Z     (input/output) COMPLEX*16 array, dimension (LDZ,N) 
            //           If COMPZ = 'N', Z is not referenced. 
            //           If COMPZ = 'I', on entry Z need not be set and on exit, 
            //           if INFO = 0, Z contains the unitary matrix Z of the Schur 
            //           vectors of H.  If COMPZ = 'V', on entry Z must contain an 
            //           N-by-N matrix Q, which is assumed to be equal to the unit 
            //           matrix except for the submatrix Z(ILO:IHI,ILO:IHI). On exit, 
            //           if INFO = 0, Z contains Q*Z. 
            //           Normally Q is the unitary matrix generated by ZUNGHR 
            //           after the call to ZGEHRD which formed the Hessenberg matrix 
            //           H. (The output value of Z when INFO.GT.0 is given under 
            //           the description of INFO below.) 

            //     LDZ   (input) int 
            //           The leading dimension of the array Z.  if COMPZ = 'I' or 
            //           COMPZ = 'V', then LDZ.GE.MAX(1,N).  Otherwize, LDZ.GE.1. 

            //     WORK  (workspace/output) COMPLEX*16 array, dimension (LWORK) 
            //           On exit, if INFO = 0, WORK(1) returns an estimate of 
            //           the optimal value for LWORK. 

            //     LWORK (input) int 
            //           The dimension of the array WORK.  LWORK .GE. max(1,N) 
            //           is sufficient and delivers very good and sometimes 
            //           optimal performance.  However, LWORK as large as 11*N 
            //           may be required for optimal performance.  A workspace 
            //           query is recommended to determine the optimal workspace 
            //           size. 

            //           If LWORK = -1, then ZHSEQR does a workspace query. 
            //           In this case, ZHSEQR checks the input parameters and 
            //           estimates the optimal workspace size for the given 
            //           values of N, ILO and IHI.  The estimate is returned 
            //           in WORK(1).  No error message related to LWORK is 
            //           issued by XERBLA.  Neither H nor Z are accessed. 


            //     INFO  (output) int 
            //             =  0:  successful exit 
            //           .LT. 0:  if INFO = -i, the i-th argument had an illegal 
            //                    value 
            //           .GT. 0:  if INFO = i, ZHSEQR failed to compute all of 
            //                the eigenvalues.  Elements 1:ilo-1 and i+1:n of WR 
            //                and WI contain those eigenvalues which have been 
            //                successfully computed.  (Failures are rare.) 

            //                If INFO .GT. 0 and JOB = 'E', then on exit, the 
            //                remaining unconverged eigenvalues are the eigen- 
            //                values of the upper Hessenberg matrix rows and 
            //                columns ILO through INFO of the final, output 
            //                value of H. 

            //                If INFO .GT. 0 and JOB   = 'S', then on exit 

            //           (*)  (initial value of H)*U  = U*(final value of H) 

            //                where U is a unitary matrix.  The final 
            //                value of  H is upper Hessenberg and triangular in 
            //                rows and columns INFO+1 through IHI. 

            //                If INFO .GT. 0 and COMPZ = 'V', then on exit 

            //                  (final value of Z)  =  (initial value of Z)*U 

            //                where U is the unitary matrix in (*) (regard- 
            //                less of the value of JOB.) 

            //                If INFO .GT. 0 and COMPZ = 'I', then on exit 
            //                      (final value of Z)  = U 
            //                where U is the unitary matrix in (*) (regard- 
            //                less of the value of JOB.) 

            //                If INFO .GT. 0 and COMPZ = 'N', then Z is not 
            //                accessed. 

            //     ================================================================ 
            //             Default values supplied by 
            //             ILAENV(ISPEC,'ZHSEQR',JOB(:1)//COMPZ(:1),N,ILO,IHI,LWORK). 
            //             It is suggested that these defaults be adjusted in order 
            //             to attain best performance in each particular 
            //             computational environment. 

            //            ISPEC=12: The ZLAHQR vs ZLAQR0 crossover point. 
            //                      Default: 75. (Must be at least 11.) 

            //            ISPEC=13: Recommended deflation window size. 
            //                      This depends on ILO, IHI and NS.  NS is the 
            //                      number of simultaneous shifts returned 
            //                      by ILAENV(ISPEC=15).  (See ISPEC=15 below.) 
            //                      The default for (IHI-ILO+1).LE.500 is NS. 
            //                      The default for (IHI-ILO+1).GT.500 is 3*NS/2. 

            //            ISPEC=14: Nibble crossover point. (See IPARMQ for 
            //                      details.)  Default: 14% of deflation window 
            //                      size. 

            //            ISPEC=15: Number of simultaneous shifts in a multishift 
            //                      QR iteration. 

            //                      If IHI-ILO+1 is ... 

            //                      greater than      ...but less    ... the 
            //                      or equal to ...      than        default is 

            //                           1               30          NS =   2(+) 
            //                          30               60          NS =   4(+) 
            //                          60              150          NS =  10(+) 
            //                         150              590          NS =  ** 
            //                         590             3000          NS =  64 
            //                        3000             6000          NS = 128 
            //                        6000             infinity      NS = 256 

            //                  (+)  By default some or all matrices of this order 
            //                       are passed to the implicit double shift routine 
            //                       ZLAHQR and this parameter is ignored.  See 
            //                       ISPEC=12 above and comments in IPARMQ for 
            //                       details. 

            //                 (**)  The asterisks (**) indicate an ad-hoc 
            //                       function of N increasing from 10 to 64. 

            //            ISPEC=16: Select structured matrix multiply. 
            //                      If the number of simultaneous shifts (specified 
            //                      by ISPEC=15) is less than 14, then the default 
            //                      for ISPEC=16 is 0.  Otherwise the default for 
            //                      ISPEC=16 is 2. 

            //     ================================================================ 
            //     Based on contributions by 
            //        Karen Braman and Ralph Byers, Department of Mathematics, 
            //        University of Kansas, USA 

            //     ================================================================ 
            //     References: 
            //       K. Braman, R. Byers and R. Mathias, The Multi-Shift QR 
            //       Algorithm Part I: Maintaining Well Focused Shifts, and Level 3 
            //       Performance, SIAM Journal of Matrix Analysis, volume 23, pages 
            //       929--947, 2002. 

            //       K. Braman, R. Byers and R. Mathias, The Multi-Shift QR 
            //       Algorithm Part II: Aggressive Early Deflation, SIAM Journal 
            //       of Matrix Analysis, volume 23, pages 948--973, 2002. 

            //     ================================================================ 
            //     .. Parameters .. 

            //     ==== Matrices of order NTINY or smaller must be processed by 
            //     .    ZLAHQR because of insufficient subdiagonal scratch space. 
            //     .    (This is a hard limit.) ==== 

            //     ==== NL allocates some local workspace to help small matrices 
            //     .    through a rare ZLAHQR failure.  NL .GT. NTINY = 11 is 
            //     .    required and NL .LE. NMIN = ILAENV(ISPEC=12,...) is recom- 
            //     .    mended.  (The default value of NMIN is 75.)  Using NL = 49 
            //     .    allows up to six simultaneous shifts and a 16-by-16 
            //     .    deflation window.  ==== 
            //     .. 

            //     ==== Decode and check the input parameters. ==== 

            // System generated locals 
            int h_dim1, h_offset, z_dim1, z_offset, i__1, i__2;
            double d__1, d__2, d__3;
            complex16 z__1;

            // Table of constant values
            complex16 c_b1 = new complex16(0.0, 0.0);
            complex16 c_b2 = new complex16(1.0, 0.0);
            int c__1 = 1;
            int c__12 = 12;
            int c__49 = 49;

            // Local variables 
            complex16[] hl = new complex16[2401]; // was [49][49] 
            int kbot, nmin;
            bool initz;
            complex16[] workl = new complex16[49];
            bool wantt, wantz;
            bool lquery;

            // Parameter adjustments 
            h_dim1 = *ldh;
            h_offset = 1 + h_dim1;
            h -= h_offset;
            --w;
            z_dim1 = *ldz;
            z_offset = 1 + z_dim1;
            z -= z_offset;
            --work;

            // Function Body 
            wantt = lsame(job, "S");
            initz = lsame(compz, "I");
            wantz = initz || lsame(compz, "V");
            d__1 = (double)Math.Max(1, *n);

            z__1.r = d__1;
            z__1.i = 0.0;

            work[1].r = z__1.r;
            work[1].i = z__1.i;

            lquery = *lwork == -1;

            *info = 0;
            if (!lsame(job, "E") && !wantt)
            {
                *info = -1;
            }
            else if (!lsame(compz, "N") && !wantz)
            {
                *info = -2;
            }
            else if (*n < 0)
            {
                *info = -3;
            }
            else if (*ilo < 1 || *ilo > Math.Max(1, *n))
            {
                *info = -4;
            }
            else if (*ihi < Math.Min(*ilo, *n) || *ihi > *n)
            {
                *info = -5;
            }
            else if (*ldh < Math.Max(1, *n))
            {
                *info = -7;
            }
            else if (*ldz < 1 || wantz && *ldz < Math.Max(1, *n))
            {
                *info = -10;
            }
            else if (*lwork < Math.Max(1, *n) && !lquery)
            {
                *info = -12;
            }

            if (*info != 0)
            {

                // ==== Quick return in case of invalid argument. ==== 

                i__1 = -(*info);
                xerbla("ZHSEQR", &i__1);
                return 0;

            }
            else if (*n == 0)
            {

                // ==== Quick return in case N = 0; nothing to do. ==== 

                return 0;

            }
            else if (lquery)
            {
                // ==== Quick return in case of a workspace query ==== 

                zlaqr0(&wantt, &wantz, n, ilo, ihi, &h[h_offset], ldh, &w[1], ilo,
                    ihi, &z[z_offset], ldz, &work[1], lwork, info);

                // ==== Ensure reported workspace size is backward-compatible with 
                // .    previous LAPACK versions. ==== 
                // Computing MAX 
                d__2 = work[1].r;
                d__3 = (double)Math.Max(1, *n);
                d__1 = Math.Max(d__2, d__3);

                z__1.r = d__1;
                z__1.i = 0.0;

                work[1].r = z__1.r;
                work[1].i = z__1.i;
                return 0;
            }
            else
            {
                // ==== copy eigenvalues isolated by ZGEBAL ==== 

                if (*ilo > 1)
                {
                    i__1 = *ilo - 1;
                    i__2 = *ldh + 1;
                    zcopy(&i__1, &h[h_offset], &i__2, &w[1], &c__1);
                }
                if (*ihi < *n)
                {
                    i__1 = *n - *ihi;
                    i__2 = *ldh + 1;
                    zcopy(&i__1, &h[*ihi + 1 + (*ihi + 1) * h_dim1], &i__2, &w[*ihi + 1], &c__1);
                }

                // ==== Initialize Z, if requested ==== 

                if (initz)
                {
                    zlaset("A", n, n, &c_b1, &c_b2, &z[z_offset], ldz);
                }

                // ==== Quick return if possible ==== 

                if (*ilo == *ihi)
                {
                    i__1 = *ilo;
                    i__2 = *ilo + *ilo * h_dim1;
                    w[i__1].r = h[i__2].r;
                    w[i__1].i = h[i__2].i;
                    return 0;
                }

                // ==== ZLAHQR/ZLAQR0 crossover point ==== 

                nmin = ilaenv(&c__12, "ZHSEQR", job + compz, n, ilo, ihi, lwork);
                nmin = Math.Max(11, nmin);

                // ==== ZLAQR0 for big matrices; ZLAHQR for small ones ==== 

                if (*n > nmin)
                {
                    zlaqr0(&wantt, &wantz, n, ilo, ihi, &h[h_offset], ldh, &w[1],
                        ilo, ihi, &z[z_offset], ldz, &work[1], lwork, info);
                }
                else
                {
                    // ==== Small matrix ==== 

                    zlahqr(&wantt, &wantz, n, ilo, ihi, &h[h_offset], ldh, &w[1], ilo, ihi, &z[z_offset], ldz, info);

                    if (*info > 0)
                    {
                        // ==== A rare ZLAHQR failure!  ZLAQR0 sometimes succeeds 
                        // .    when ZLAHQR fails. ==== 

                        kbot = *info;

                        if (*n >= 49)
                        {
                            // ==== Larger matrices have enough subdiagonal scratch 
                            // .    space to call ZLAQR0 directly. ==== 

                            zlaqr0(&wantt, &wantz, n, ilo, &kbot, &h[h_offset], ldh, &w[1],
                                ilo, ihi, &z[z_offset], ldz, &work[1], lwork, info);
                        }
                        else
                        {
                            // ==== Tiny matrices don't have enough subdiagonal 
                            // .    scratch space to benefit from ZLAQR0.  Hence, 
                            // .    tiny matrices must be copied into a larger 
                            // .    array before calling ZLAQR0. ==== 

                            zlacpy("A", n, n, &h[h_offset], ldh, hl, &c__49);
                            i__1 = *n + 1 + *n * 49 - 50;

                            hl[i__1].r = 0.0;
                            hl[i__1].i = 0.0;

                            i__1 = 49 - *n;
                            zlaset("A", &c__49, &i__1, &c_b1, &c_b1, &hl[(*n + 1) *
                                49 - 49], &c__49);
                            zlaqr0(&wantt, &wantz, &c__49, ilo, &kbot, hl, &c__49,
                                &w[1], ilo, ihi, &z[z_offset], ldz, workl, &c__49, info);
                            if (wantt || *info != 0)
                            {
                                zlacpy("A", n, n, hl, &c__49, &h[h_offset], ldh);
                            }
                        }
                    }
                }

                // ==== Clear out the trash, if necessary. ==== 

                if ((wantt || *info != 0) && *n > 2)
                {
                    i__1 = *n - 2;
                    i__2 = *n - 2;
                    zlaset("L", &i__1, &i__2, &c_b1, &c_b1, &h[h_dim1 + 3], ldh);
                }

                // ==== Ensure reported workspace size is backward-compatible with 
                // .    previous LAPACK versions. ==== 

                // Computing MAX 
                d__2 = (double)Math.Max(1, *n);
                d__3 = work[1].r;

                d__1 = Math.Max(d__2, d__3);

                z__1.r = d__1;
                z__1.i = 0.0;

                work[1].r = z__1.r;
                work[1].i = z__1.i;
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zlabrd(int* m, int* n, int* nb, complex16* a, int* lda, double* d,
            double* e, complex16* tauq, complex16* taup, complex16* x, int* ldx, complex16* y, int* ldy)
        {
            //  -- LAPACK auxiliary routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     November 2006

            //  Purpose
            //  =======

            //  ZLABRD reduces the first NB rows and columns of a complex general
            //  m by n matrix A to upper or lower real bidiagonal form by a unitary
            //  transformation Q' * A * P, and returns the matrices X and Y which
            //  are needed to apply the transformation to the unreduced part of A.

            //  If m >= n, A is reduced to upper bidiagonal form; if m < n, to lower
            //  bidiagonal form.

            //  This is an auxiliary routine called by ZGEBRD

            //  Arguments
            //  =========

            //  M       (input) int
            //          The number of rows in the matrix A.

            //  N       (input) int
            //          The number of columns in the matrix A.

            //  NB      (input) int
            //          The number of leading rows and columns of A to be reduced.

            //  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
            //          On entry, the m by n general matrix to be reduced.
            //          On exit, the first NB rows and columns of the matrix are
            //          overwritten; the rest of the array is unchanged.
            //          If m >= n, elements on and below the diagonal in the first NB
            //            columns, with the array TAUQ, represent the unitary
            //            matrix Q as a product of elementary reflectors; and
            //            elements above the diagonal in the first NB rows, with the
            //            array TAUP, represent the unitary matrix P as a product
            //            of elementary reflectors.
            //          If m < n, elements below the diagonal in the first NB
            //            columns, with the array TAUQ, represent the unitary
            //            matrix Q as a product of elementary reflectors, and
            //            elements on and above the diagonal in the first NB rows,
            //            with the array TAUP, represent the unitary matrix P as
            //            a product of elementary reflectors.
            //          See Further Details.

            //  LDA     (input) int
            //          The leading dimension of the array A.  LDA >= max(1,M).

            //  D       (output) DOUBLE PRECISION array, dimension (NB)
            //          The diagonal elements of the first NB rows and columns of
            //          the reduced matrix.  D(i) = A(i,i).

            //  E       (output) DOUBLE PRECISION array, dimension (NB)
            //          The off-diagonal elements of the first NB rows and columns of
            //          the reduced matrix.

            //  TAUQ    (output) COMPLEX*16 array dimension (NB)
            //          The scalar factors of the elementary reflectors which
            //          represent the unitary matrix Q. See Further Details.

            //  TAUP    (output) COMPLEX*16 array, dimension (NB)
            //          The scalar factors of the elementary reflectors which
            //          represent the unitary matrix P. See Further Details.

            //  X       (output) COMPLEX*16 array, dimension (LDX,NB)
            //          The m-by-nb matrix X required to update the unreduced part
            //          of A.

            //  LDX     (input) int
            //          The leading dimension of the array X. LDX >= max(1,M).

            //  Y       (output) COMPLEX*16 array, dimension (LDY,NB)
            //          The n-by-nb matrix Y required to update the unreduced part
            //          of A.

            //  LDY     (input) int
            //          The leading dimension of the array Y. LDY >= max(1,N).

            //  Further Details
            //  ===============

            //  The matrices Q and P are represented as products of elementary
            //  reflectors:

            //     Q = H(1) H(2) . . . H(nb)  and  P = G(1) G(2) . . . G(nb)

            //  Each H(i) and G(i) has the form:

            //     H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'

            //  where tauq and taup are complex scalars, and v and u are complex
            //  vectors.

            //  If m >= n, v(1:i-1) = 0, v(i) = 1, and v(i:m) is stored on exit in
            //  A(i:m,i); u(1:i) = 0, u(i+1) = 1, and u(i+1:n) is stored on exit in
            //  A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).

            //  If m < n, v(1:i) = 0, v(i+1) = 1, and v(i+1:m) is stored on exit in
            //  A(i+2:m,i); u(1:i-1) = 0, u(i) = 1, and u(i:n) is stored on exit in
            //  A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).

            //  The elements of the vectors v and u together form the m-by-nb matrix
            //  V and the nb-by-n matrix U' which are needed, with X and Y, to apply
            //  the transformation to the unreduced part of the matrix, using a block
            //  update of the form:  A := A - V*Y' - X*U'.

            //  The contents of A on exit are illustrated by the following examples
            //  with nb = 2:

            //  m = 6 and n = 5 (m > n):          m = 5 and n = 6 (m < n):

            //    (  1   1   u1  u1  u1 )           (  1   u1  u1  u1  u1  u1 )
            //    (  v1  1   1   u2  u2 )           (  1   1   u2  u2  u2  u2 )
            //    (  v1  v2  a   a   a  )           (  v1  1   a   a   a   a  )
            //    (  v1  v2  a   a   a  )           (  v1  v2  a   a   a   a  )
            //    (  v1  v2  a   a   a  )           (  v1  v2  a   a   a   a  )
            //    (  v1  v2  a   a   a  )

            //  where a denotes an element of the original matrix which is unchanged,
            //  vi denotes an element of the vector defining H(i), and ui an element
            //  of the vector defining G(i).

            //  =====================================================================

            // System generated locals
            int a_dim1, a_offset, x_dim1, x_offset, y_dim1, y_offset, i__1, i__2, i__3;
            complex16 z__1;

            // Table of constant values
            complex16 c_b1 = new complex16(0.0, 0.0);
            complex16 c_b2 = new complex16(1.0, 0.0);
            int c__1 = 1;

            // Local variables
            int i;
            complex16 alpha;

            // Parameter adjustments
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;
            --d;
            --e;
            --tauq;
            --taup;
            x_dim1 = *ldx;
            x_offset = 1 + x_dim1;
            x -= x_offset;
            y_dim1 = *ldy;
            y_offset = 1 + y_dim1;
            y -= y_offset;

            // Function Body
            if (*m <= 0 || *n <= 0)
            {
                return 0;
            }

            if (*m >= *n)
            {
                // Reduce to upper bidiagonal form

                i__1 = *nb;
                for (i = 1; i <= i__1; ++i)
                {
                    // Update A(i:m,i)

                    i__2 = i - 1;
                    zlacgv(&i__2, &y[i + y_dim1], ldy);
                    i__2 = *m - i + 1;
                    i__3 = i - 1;
                    z__1.r = -1.0;
                    z__1.i = -0.0;
                    zgemv("No transpose", &i__2, &i__3, &z__1, &a[i + a_dim1], lda,
                         &y[i + y_dim1], ldy, &c_b2, &a[i + i * a_dim1], &c__1);
                    i__2 = i - 1;
                    zlacgv(&i__2, &y[i + y_dim1], ldy);
                    i__2 = *m - i + 1;
                    i__3 = i - 1;
                    z__1.r = -1.0;
                    z__1.i = -0.0;
                    zgemv("No transpose", &i__2, &i__3, &z__1, &x[i + x_dim1], ldx,
                         &a[i * a_dim1 + 1], &c__1, &c_b2, &a[i + i * a_dim1], &c__1);

                    // Generate reflection Q(i) to annihilate A(i+1:m,i)

                    i__2 = i + i * a_dim1;
                    alpha.r = a[i__2].r;
                    alpha.i = a[i__2].i;
                    i__2 = *m - i + 1;
                    // Computing MIN
                    i__3 = i + 1;
                    zlarfg(&i__2, &alpha, &a[Math.Min(i__3, *m) + i * a_dim1], &c__1, &tauq[i]);
                    i__2 = i;
                    d[i__2] = alpha.r;

                    if (i < *n)
                    {
                        i__2 = i + i * a_dim1;
                        a[i__2].r = 1.0;
                        a[i__2].i = 0.0;

                        // Compute Y(i+1:n,i)

                        i__2 = *m - i + 1;
                        i__3 = *n - i;
                        zgemv("Conjugate transpose", &i__2, &i__3, &c_b2, &a[i + (i + 1) * a_dim1],
                            lda, &a[i + i * a_dim1], &c__1, &c_b1, &y[i + 1 + i * y_dim1], &c__1);
                        i__2 = *m - i + 1;
                        i__3 = i - 1;
                        zgemv("Conjugate transpose", &i__2, &i__3, &c_b2, &a[i + a_dim1], lda,
                            &a[i + i * a_dim1], &c__1, &c_b1, &y[i * y_dim1 + 1], &c__1);
                        i__2 = *n - i;
                        i__3 = i - 1;
                        z__1.r = -1.0;
                        z__1.i = -0.0;
                        zgemv("No transpose", &i__2, &i__3, &z__1, &y[i + 1 + y_dim1], ldy,
                            &y[i * y_dim1 + 1], &c__1, &c_b2, &y[i + 1 + i * y_dim1], &c__1);
                        i__2 = *m - i + 1;
                        i__3 = i - 1;
                        zgemv("Conjugate transpose", &i__2, &i__3, &c_b2, &x[i + x_dim1],
                            ldx, &a[i + i * a_dim1], &c__1, &c_b1, &y[i * y_dim1 + 1], &c__1);
                        i__2 = i - 1;
                        i__3 = *n - i;
                        z__1.r = -1.0;
                        z__1.i = -0.0;
                        zgemv("Conjugate transpose", &i__2, &i__3, &z__1, &a[(i + 1) * a_dim1 + 1],
                            lda, &y[i * y_dim1 + 1], &c__1, &c_b2, &y[i + 1 + i * y_dim1], &c__1);
                        i__2 = *n - i;
                        zscal(&i__2, &tauq[i], &y[i + 1 + i * y_dim1], &c__1);

                        // Update A(i,i+1:n)

                        i__2 = *n - i;
                        zlacgv(&i__2, &a[i + (i + 1) * a_dim1], lda);
                        zlacgv(&i, &a[i + a_dim1], lda);
                        i__2 = *n - i;
                        z__1.r = -1.0;
                        z__1.i = -0.0;
                        zgemv("No transpose", &i__2, &i, &z__1, &y[i + 1 + y_dim1], ldy,
                            &a[i + a_dim1], lda, &c_b2, &a[i + (i + 1) * a_dim1], lda);
                        zlacgv(&i, &a[i + a_dim1], lda);
                        i__2 = i - 1;
                        zlacgv(&i__2, &x[i + x_dim1], ldx);
                        i__2 = i - 1;
                        i__3 = *n - i;
                        z__1.r = -1.0;
                        z__1.i = -0.0;
                        zgemv("Conjugate transpose", &i__2, &i__3, &z__1, &a[(i + 1) * a_dim1 + 1],
                            lda, &x[i + x_dim1], ldx, &c_b2, &a[i + (i + 1) * a_dim1], lda);
                        i__2 = i - 1;
                        zlacgv(&i__2, &x[i + x_dim1], ldx);

                        // Generate reflection P(i) to annihilate A(i,i+2:n)

                        i__2 = i + (i + 1) * a_dim1;
                        alpha.r = a[i__2].r;
                        alpha.i = a[i__2].i;
                        i__2 = *n - i;
                        // Computing MIN
                        i__3 = i + 2;
                        zlarfg(&i__2, &alpha, &a[i + Math.Min(i__3, *n) * a_dim1], lda, &taup[i]);
                        i__2 = i;
                        e[i__2] = alpha.r;
                        i__2 = i + (i + 1) * a_dim1;
                        a[i__2].r = 1.0;
                        a[i__2].i = 0.0;

                        // Compute X(i+1:m,i)

                        i__2 = *m - i;
                        i__3 = *n - i;
                        zgemv("No transpose", &i__2, &i__3, &c_b2, &a[i + 1 + (i + 1) * a_dim1],
                            lda, &a[i + (i + 1) * a_dim1], lda, &c_b1, &x[i + 1 + i * x_dim1], &c__1);
                        i__2 = *n - i;
                        zgemv("Conjugate transpose", &i__2, &i, &c_b2, &y[i + 1 + y_dim1], ldy,
                            &a[i + (i + 1) * a_dim1], lda, &c_b1, &x[i * x_dim1 + 1], &c__1);
                        i__2 = *m - i;
                        z__1.r = -1.0;
                        z__1.i = -0.0;
                        zgemv("No transpose", &i__2, &i, &z__1, &a[i + 1 + a_dim1], lda,
                            &x[i * x_dim1 + 1], &c__1, &c_b2, &x[i + 1 + i * x_dim1], &c__1);
                        i__2 = i - 1;
                        i__3 = *n - i;
                        zgemv("No transpose", &i__2, &i__3, &c_b2, &a[(i + 1) * a_dim1 + 1],
                            lda, &a[i + (i + 1) * a_dim1], lda, &c_b1, &x[i * x_dim1 + 1], &c__1);
                        i__2 = *m - i;
                        i__3 = i - 1;
                        z__1.r = -1.0;
                        z__1.i = -0.0;
                        zgemv("No transpose", &i__2, &i__3, &z__1, &x[i + 1 + x_dim1], ldx,
                            &x[i * x_dim1 + 1], &c__1, &c_b2, &x[i + 1 + i * x_dim1], &c__1);
                        i__2 = *m - i;
                        zscal(&i__2, &taup[i], &x[i + 1 + i * x_dim1], &c__1);
                        i__2 = *n - i;
                        zlacgv(&i__2, &a[i + (i + 1) * a_dim1], lda);
                    }
                }
            }
            else
            {
                // Reduce to lower bidiagonal form

                i__1 = *nb;
                for (i = 1; i <= i__1; ++i)
                {
                    // Update A(i,i:n)

                    i__2 = *n - i + 1;
                    zlacgv(&i__2, &a[i + i * a_dim1], lda);
                    i__2 = i - 1;
                    zlacgv(&i__2, &a[i + a_dim1], lda);
                    i__2 = *n - i + 1;
                    i__3 = i - 1;
                    z__1.r = -1.0;
                    z__1.i = -0.0;
                    zgemv("No transpose", &i__2, &i__3, &z__1, &y[i + y_dim1], ldy,
                         &a[i + a_dim1], lda, &c_b2, &a[i + i * a_dim1], lda);
                    i__2 = i - 1;
                    zlacgv(&i__2, &a[i + a_dim1], lda);
                    i__2 = i - 1;
                    zlacgv(&i__2, &x[i + x_dim1], ldx);
                    i__2 = i - 1;
                    i__3 = *n - i + 1;
                    z__1.r = -1.0;
                    z__1.i = -0.0;
                    zgemv("Conjugate transpose", &i__2, &i__3, &z__1, &a[i * a_dim1 + 1],
                        lda, &x[i + x_dim1], ldx, &c_b2, &a[i + i * a_dim1], lda);
                    i__2 = i - 1;
                    zlacgv(&i__2, &x[i + x_dim1], ldx);

                    // Generate reflection P(i) to annihilate A(i,i+1:n)

                    i__2 = i + i * a_dim1;
                    alpha.r = a[i__2].r;
                    alpha.i = a[i__2].i;
                    i__2 = *n - i + 1;
                    // Computing MIN
                    i__3 = i + 1;
                    zlarfg(&i__2, &alpha, &a[i + Math.Min(i__3, *n) * a_dim1], lda, &taup[i]);
                    i__2 = i;
                    d[i__2] = alpha.r;

                    if (i < *m)
                    {
                        i__2 = i + i * a_dim1;
                        a[i__2].r = 1.0;
                        a[i__2].i = 0.0;

                        // Compute X(i+1:m,i)

                        i__2 = *m - i;
                        i__3 = *n - i + 1;
                        zgemv("No transpose", &i__2, &i__3, &c_b2, &a[i + 1 + i * a_dim1], lda,
                            &a[i + i * a_dim1], lda, &c_b1, &x[i + 1 + i * x_dim1], &c__1);
                        i__2 = *n - i + 1;
                        i__3 = i - 1;
                        zgemv("Conjugate transpose", &i__2, &i__3, &c_b2, &y[i + y_dim1], ldy,
                            &a[i + i * a_dim1], lda, &c_b1, &x[i * x_dim1 + 1], &c__1);
                        i__2 = *m - i;
                        i__3 = i - 1;
                        z__1.r = -1.0;
                        z__1.i = -0.0;
                        zgemv("No transpose", &i__2, &i__3, &z__1, &a[i + 1 + a_dim1], lda,
                            &x[i * x_dim1 + 1], &c__1, &c_b2, &x[i + 1 + i * x_dim1], &c__1);
                        i__2 = i - 1;
                        i__3 = *n - i + 1;
                        zgemv("No transpose", &i__2, &i__3, &c_b2, &a[i * a_dim1 + 1], lda,
                            &a[i + i * a_dim1], lda, &c_b1, &x[i * x_dim1 + 1], &c__1);
                        i__2 = *m - i;
                        i__3 = i - 1;
                        z__1.r = -1.0;
                        z__1.i = -0.0;
                        zgemv("No transpose", &i__2, &i__3, &z__1, &x[i + 1 + x_dim1], ldx,
                            &x[i * x_dim1 + 1], &c__1, &c_b2, &x[i + 1 + i * x_dim1], &c__1);
                        i__2 = *m - i;
                        zscal(&i__2, &taup[i], &x[i + 1 + i * x_dim1], &c__1);
                        i__2 = *n - i + 1;
                        zlacgv(&i__2, &a[i + i * a_dim1], lda);

                        // Update A(i+1:m,i)

                        i__2 = i - 1;
                        zlacgv(&i__2, &y[i + y_dim1], ldy);
                        i__2 = *m - i;
                        i__3 = i - 1;
                        z__1.r = -1.0;
                        z__1.i = -0.0;
                        zgemv("No transpose", &i__2, &i__3, &z__1, &a[i + 1 + a_dim1], lda,
                            &y[i + y_dim1], ldy, &c_b2, &a[i + 1 + i * a_dim1], &c__1);
                        i__2 = i - 1;
                        zlacgv(&i__2, &y[i + y_dim1], ldy);
                        i__2 = *m - i;
                        z__1.r = -1.0;
                        z__1.i = -0.0;
                        zgemv("No transpose", &i__2, &i, &z__1, &x[i + 1 + x_dim1], ldx,
                            &a[i * a_dim1 + 1], &c__1, &c_b2, &a[i + 1 + i * a_dim1], &c__1);

                        // Generate reflection Q(i) to annihilate A(i+2:m,i)

                        i__2 = i + 1 + i * a_dim1;
                        alpha.r = a[i__2].r;
                        alpha.i = a[i__2].i;
                        i__2 = *m - i;
                        // Computing MIN
                        i__3 = i + 2;
                        zlarfg(&i__2, &alpha, &a[Math.Min(i__3, *m) + i * a_dim1], &c__1, &tauq[i]);
                        i__2 = i;
                        e[i__2] = alpha.r;
                        i__2 = i + 1 + i * a_dim1;
                        a[i__2].r = 1.0;
                        a[i__2].i = 0.0;

                        // Compute Y(i+1:n,i)

                        i__2 = *m - i;
                        i__3 = *n - i;
                        zgemv("Conjugate transpose", &i__2, &i__3, &c_b2, &a[i + 1 + (i + 1) * a_dim1],
                            lda, &a[i + 1 + i * a_dim1], &c__1, &c_b1, &y[i + 1 + i * y_dim1], &c__1);
                        i__2 = *m - i;
                        i__3 = i - 1;
                        zgemv("Conjugate transpose", &i__2, &i__3, &c_b2, &a[i + 1 + a_dim1], lda,
                            &a[i + 1 + i * a_dim1], &c__1, &c_b1, &y[i * y_dim1 + 1], &c__1);
                        i__2 = *n - i;
                        i__3 = i - 1;
                        z__1.r = -1.0;
                        z__1.i = -0.0;
                        zgemv("No transpose", &i__2, &i__3, &z__1, &y[i + 1 + y_dim1], ldy,
                            &y[i * y_dim1 + 1], &c__1, &c_b2, &y[i + 1 + i * y_dim1], &c__1);
                        i__2 = *m - i;
                        zgemv("Conjugate transpose", &i__2, &i, &c_b2, &x[i + 1 + x_dim1], ldx,
                            &a[i + 1 + i * a_dim1], &c__1, &c_b1, &y[i * y_dim1 + 1], &c__1);
                        i__2 = *n - i;
                        z__1.r = -1.0;
                        z__1.i = -0.0;
                        zgemv("Conjugate transpose", &i, &i__2, &z__1, &a[(i + 1) * a_dim1 + 1], lda,
                            &y[i * y_dim1 + 1], &c__1, &c_b2, &y[i + 1 + i * y_dim1], &c__1);
                        i__2 = *n - i;
                        zscal(&i__2, &tauq[i], &y[i + 1 + i * y_dim1], &c__1);
                    }
                    else
                    {
                        i__2 = *n - i + 1;
                        zlacgv(&i__2, &a[i + i * a_dim1], lda);
                    }
                }
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zlacgv(int* n, complex16* x, int* incx)
        {
            //  -- LAPACK auxiliary routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. 
            //     November 2006 

            //  Purpose 
            //  ======= 

            //  ZLACGV conjugates a complex vector of length N. 

            //  Arguments 
            //  ========= 

            //  N       (input) int 
            //          The length of the vector X.  N >= 0. 

            //  X       (input/output) COMPLEX*16 array, dimension 
            //                         (1+(N-1)*abs(INCX)) 
            //          On entry, the vector of length N to be conjugated. 
            //          On exit, X is overwritten with conjg(X). 

            //  INCX    (input) int 
            //          The spacing between successive elements of X. 

            // ===================================================================== 

            // System generated locals 
            int i__1, i__2;
            complex16 z__1;

            // Local variables 
            int i, ioff;

            // Parameter adjustments 
            --x;

            // Function Body 
            if (*incx == 1)
            {
                i__1 = *n;
                for (i = 1; i <= i__1; ++i)
                {
                    i__2 = i;
                    d_cnjg(&z__1, &x[i]);

                    x[i__2].r = z__1.r;
                    x[i__2].i = z__1.i;
                }
            }
            else
            {
                ioff = 1;
                if (*incx < 0)
                {
                    ioff = 1 - (*n - 1) * *incx;
                }

                i__1 = *n;
                for (i = 1; i <= i__1; ++i)
                {
                    i__2 = ioff;
                    d_cnjg(&z__1, &x[ioff]);

                    x[i__2].r = z__1.r;
                    x[i__2].i = z__1.i;
                    ioff += *incx;
                }
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zlacn2(int* n, complex16* v, complex16* x, double* est, int* kase, int* isave)
        {
            //  -- LAPACK auxiliary routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. 
            //     November 2006 

            //  Purpose 
            //  ======= 

            //  ZLACN2 estimates the 1-norm of a square, complex matrix A. 
            //  Reverse communication is used for evaluating matrix-vector products. 

            //  Arguments 
            //  ========= 

            //  N      (input) int 
            //         The order of the matrix.  N >= 1. 

            //  V      (workspace) COMPLEX*16 array, dimension (N) 
            //         On the final return, V = A*W,  where  EST = norm(V)/norm(W) 
            //         (W is not returned). 

            //  X      (input/output) COMPLEX*16 array, dimension (N) 
            //         On an intermediate return, X should be overwritten by 
            //               A * X,   if KASE=1, 
            //               A' * X,  if KASE=2, 
            //         where A' is the conjugate transpose of A, and ZLACN2 must be 
            //         re-called with all the other parameters unchanged. 

            //  EST    (input/output) DOUBLE PRECISION 
            //         On entry with KASE = 1 or 2 and ISAVE(1) = 3, EST should be 
            //         unchanged from the previous call to ZLACN2. 
            //         On exit, EST is an estimate (a lower bound) for norm(A). 

            //  KASE   (input/output) int 
            //         On the initial call to ZLACN2, KASE should be 0. 
            //         On an intermediate return, KASE will be 1 or 2, indicating 
            //         whether X should be overwritten by A * X  or A' * X. 
            //         On the final return from ZLACN2, KASE will again be 0. 

            //  ISAVE  (input/output) int array, dimension (3) 
            //         ISAVE is used to save variables between calls to ZLACN2 

            //  Further Details 
            //  ======= ======= 

            //  Contributed by Nick Higham, University of Manchester. 
            //  Originally named CONEST, dated March 16, 1988. 

            //  Reference: N.J. Higham, "FORTRAN codes for estimating the one-norm of 
            //  a real or complex matrix, with applications to condition estimation", 
            //  ACM Trans. Math. Soft., vol. 14, no. 4, pp. 381-396, December 1988. 

            //  Last modified:  April, 1999 

            //  This is a thread safe version of ZLACON, which uses the array ISAVE 
            //  in place of a SAVE statement, as follows: 

            //     ZLACON     ZLACN2 
            //      JUMP     ISAVE(1) 
            //      J        ISAVE(2) 
            //      ITER     ISAVE(3) 

            //  ===================================================================== 

            // System generated locals 
            int i__1, i__2, i__3;
            double d__1, d__2;
            complex16 z__1;

            // Table of constant values
            int c__1 = 1;

            // Local variables 
            int i;
            double temp, absxi;
            int jlast;
            double safmin, altsgn, estold;

            // Parameter adjustments 
            --isave;
            --x;
            --v;

            // Function Body 
            safmin = dlamch("Safe minimum");

            if (*kase == 0)
            {
                i__1 = *n;
                for (i = 1; i <= i__1; ++i)
                {
                    i__2 = i;
                    d__1 = 1.0 / (double)(*n);

                    z__1.r = d__1;
                    z__1.i = 0.0;

                    x[i__2].r = z__1.r;
                    x[i__2].i = z__1.i;
                }

                *kase = 1;
                isave[1] = 1;
                return 0;
            }

            switch (isave[1])
            {
                case 1: goto L20;
                case 2: goto L40;
                case 3: goto L70;
                case 4: goto L90;
                case 5: goto L120;
            }

            // ................ ENTRY   (ISAVE( 1 ) = 1) 
        // FIRST ITERATION.  X HAS BEEN OVERWRITTEN BY A*X. 

        L20:
            if (*n == 1)
            {
                v[1].r = x[1].r;
                v[1].i = x[1].i;

                *est = z_abs(&v[1]);
                // ... QUIT 
                goto L130;
            }

            *est = dzsum1(n, &x[1], &c__1);

            i__1 = *n;
            for (i = 1; i <= i__1; ++i)
            {
                absxi = z_abs(&x[i]);
                if (absxi > safmin)
                {
                    i__2 = i;
                    i__3 = i;
                    d__1 = x[i__3].r / absxi;
                    d__2 = d_imag(&x[i]) / absxi;

                    z__1.r = d__1;
                    z__1.i = d__2;

                    x[i__2].r = z__1.r;
                    x[i__2].i = z__1.i;
                }
                else
                {
                    i__2 = i;
                    x[i__2].r = 1.0;
                    x[i__2].i = 0.0;
                }
            }

            *kase = 2;
            isave[1] = 2;
            return 0;

            // ................ ENTRY   (ISAVE( 1 ) = 2) 
        // FIRST ITERATION.  X HAS BEEN OVERWRITTEN BY CTRANS(A)*X. 

        L40:
            isave[2] = izmax1(n, &x[1], &c__1);
            isave[3] = 2;

            // MAIN LOOP - ITERATIONS 2,3,...,ITMAX. 

        L50:
            i__1 = *n;
            for (i = 1; i <= i__1; ++i)
            {
                i__2 = i;
                x[i__2].r = 0.0;
                x[i__2].i = 0.0;
            }

            i__1 = isave[2];

            x[i__1].r = 1.0;
            x[i__1].i = 0.0;

            *kase = 1;
            isave[1] = 3;
            return 0;

            // ................ ENTRY   (ISAVE( 1 ) = 3) 
        // X HAS BEEN OVERWRITTEN BY A*X. 

        L70:
            zcopy(n, &x[1], &c__1, &v[1], &c__1);
            estold = *est;
            *est = dzsum1(n, &v[1], &c__1);

            // TEST FOR CYCLING. 
            if (*est <= estold)
            {
                goto L100;
            }

            i__1 = *n;
            for (i = 1; i <= i__1; ++i)
            {
                absxi = z_abs(&x[i]);

                if (absxi > safmin)
                {
                    i__2 = i;
                    i__3 = i;
                    d__1 = x[i__3].r / absxi;
                    d__2 = d_imag(&x[i]) / absxi;

                    z__1.r = d__1;
                    z__1.i = d__2;

                    x[i__2].r = z__1.r;
                    x[i__2].i = z__1.i;
                }
                else
                {
                    i__2 = i;
                    x[i__2].r = 1.0;
                    x[i__2].i = 0.0;
                }
            }

            *kase = 2;
            isave[1] = 4;
            return 0;

            // ................ ENTRY   (ISAVE( 1 ) = 4) 
        // X HAS BEEN OVERWRITTEN BY CTRANS(A)*X. 

        L90:
            jlast = isave[2];
            isave[2] = izmax1(n, &x[1], &c__1);
            if (z_abs(&x[jlast]) != z_abs(&x[isave[2]]) && isave[3] < 5)
            {
                ++isave[3];
                goto L50;
            }

            // ITERATION COMPLETE.  FINAL STAGE. 

        L100:
            altsgn = 1.0;
            i__1 = *n;
            for (i = 1; i <= i__1; ++i)
            {
                i__2 = i;
                d__1 = altsgn * ((double)(i - 1) / (double)(*n - 1) + 1.0);

                z__1.r = d__1;
                z__1.i = 0.0;

                x[i__2].r = z__1.r;
                x[i__2].i = z__1.i;

                altsgn = -altsgn;
            }

            *kase = 1;
            isave[1] = 5;
            return 0;

            // ................ ENTRY   (ISAVE( 1 ) = 5) 
        // X HAS BEEN OVERWRITTEN BY A*X. 

        L120:
            temp = dzsum1(n, &x[1], &c__1) / (double)(*n * 3) * 2.0;

            if (temp > *est)
            {
                zcopy(n, &x[1], &c__1, &v[1], &c__1);
                *est = temp;
            }

        L130:
            *kase = 0;

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zlacp2(string uplo, int* m, int* n, double* a, int* lda, complex16* b, int* ldb)
        {
            //  -- LAPACK auxiliary routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     November 2006

            //  Purpose
            //  =======

            //  ZLACP2 copies all or part of a real two-dimensional matrix A to a
            //  complex matrix B.

            //  Arguments
            //  =========

            //  UPLO    (input) CHARACTER*1
            //          Specifies the part of the matrix A to be copied to B.
            //          = 'U':      Upper triangular part
            //          = 'L':      Lower triangular part
            //          Otherwise:  All of the matrix A

            //  M       (input) int
            //          The number of rows of the matrix A.  M >= 0.

            //  N       (input) int
            //          The number of columns of the matrix A.  N >= 0.

            //  A       (input) DOUBLE PRECISION array, dimension (LDA,N)
            //          The m by n matrix A.  If UPLO = 'U', only the upper trapezium
            //          is accessed; if UPLO = 'L', only the lower trapezium is
            //          accessed.

            //  LDA     (input) int
            //          The leading dimension of the array A.  LDA >= max(1,M).

            //  B       (output) COMPLEX*16 array, dimension (LDB,N)
            //          On exit, B = A in the locations specified by UPLO.

            //  LDB     (input) int
            //          The leading dimension of the array B.  LDB >= max(1,M).

            //  =====================================================================

            // System generated locals
            int a_dim1, a_offset, b_dim1, b_offset, i__1, i__2, i__3, i__4;

            // Local variables
            int i, j;

            // Parameter adjustments
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;
            b_dim1 = *ldb;
            b_offset = 1 + b_dim1;
            b -= b_offset;

            // Function Body
            if (lsame(uplo, "U"))
            {
                i__1 = *n;
                for (j = 1; j <= i__1; ++j)
                {
                    i__2 = Math.Min(j, *m);
                    for (i = 1; i <= i__2; ++i)
                    {
                        i__3 = i + j * b_dim1;
                        i__4 = i + j * a_dim1;

                        b[i__3].r = a[i__4];
                        b[i__3].i = 0.0;
                    }
                }

            }
            else if (lsame(uplo, "L"))
            {
                i__1 = *n;
                for (j = 1; j <= i__1; ++j)
                {
                    i__2 = *m;
                    for (i = j; i <= i__2; ++i)
                    {
                        i__3 = i + j * b_dim1;
                        i__4 = i + j * a_dim1;

                        b[i__3].r = a[i__4];
                        b[i__3].i = 0.0;
                    }
                }

            }
            else
            {
                i__1 = *n;
                for (j = 1; j <= i__1; ++j)
                {
                    i__2 = *m;
                    for (i = 1; i <= i__2; ++i)
                    {
                        i__3 = i + j * b_dim1;
                        i__4 = i + j * a_dim1;

                        b[i__3].r = a[i__4];
                        b[i__3].i = 0.0;
                    }
                }
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zlacpy(string uplo, int* m, int* n, complex16* a, int* lda, complex16* b, int* ldb)
        {
            //  -- LAPACK auxiliary routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. 
            //     November 2006 

            //  Purpose 
            //  ======= 

            //  ZLACPY copies all or part of a two-dimensional matrix A to another 
            //  matrix B. 

            //  Arguments 
            //  ========= 

            //  UPLO    (input) CHARACTER*1 
            //          Specifies the part of the matrix A to be copied to B. 
            //          = 'U':      Upper triangular part 
            //          = 'L':      Lower triangular part 
            //          Otherwise:  All of the matrix A 

            //  M       (input) int 
            //          The number of rows of the matrix A.  M >= 0. 

            //  N       (input) int 
            //          The number of columns of the matrix A.  N >= 0. 

            //  A       (input) COMPLEX*16 array, dimension (LDA,N) 
            //          The m by n matrix A.  If UPLO = 'U', only the upper trapezium 
            //          is accessed; if UPLO = 'L', only the lower trapezium is 
            //          accessed. 

            //  LDA     (input) int 
            //          The leading dimension of the array A.  LDA >= max(1,M). 

            //  B       (output) COMPLEX*16 array, dimension (LDB,N) 
            //          On exit, B = A in the locations specified by UPLO. 

            //  LDB     (input) int 
            //          The leading dimension of the array B.  LDB >= max(1,M). 

            //  ===================================================================== 

            // System generated locals 
            int a_dim1, a_offset, b_dim1, b_offset, i__1, i__2, i__3, i__4;

            // Local variables 
            int i, j;

            // Parameter adjustments 
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;
            b_dim1 = *ldb;
            b_offset = 1 + b_dim1;
            b -= b_offset;

            // Function Body 
            if (lsame(uplo, "U"))
            {
                i__1 = *n;
                for (j = 1; j <= i__1; ++j)
                {
                    i__2 = Math.Min(j, *m);
                    for (i = 1; i <= i__2; ++i)
                    {
                        i__3 = i + j * b_dim1;
                        i__4 = i + j * a_dim1;
                        b[i__3].r = a[i__4].r;
                        b[i__3].i = a[i__4].i;
                    }
                }

            }
            else if (lsame(uplo, "L"))
            {
                i__1 = *n;
                for (j = 1; j <= i__1; ++j)
                {
                    i__2 = *m;
                    for (i = j; i <= i__2; ++i)
                    {
                        i__3 = i + j * b_dim1;
                        i__4 = i + j * a_dim1;
                        b[i__3].r = a[i__4].r;
                        b[i__3].i = a[i__4].i;
                    }
                }
            }
            else
            {
                i__1 = *n;
                for (j = 1; j <= i__1; ++j)
                {
                    i__2 = *m;
                    for (i = 1; i <= i__2; ++i)
                    {
                        i__3 = i + j * b_dim1;
                        i__4 = i + j * a_dim1;
                        b[i__3].r = a[i__4].r;
                        b[i__3].i = a[i__4].i;
                    }
                }
            }

            return 0;

            // End of ZLACPY 
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zlacrm(int* m, int* n, complex16* a,
            int* lda, double* b, int* ldb, complex16* c, int* ldc, double* rwork)
        {
            //  -- LAPACK auxiliary routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     November 2006

            //  Purpose
            //  =======

            //  ZLACRM performs a very simple matrix-matrix multiplication:
            //           C := A * B,
            //  where A is M by N and complex; B is N by N and real;
            //  C is M by N and complex.

            //  Arguments
            //  =========

            //  M       (input) int
            //          The number of rows of the matrix A and of the matrix C.
            //          M >= 0.

            //  N       (input) int
            //          The number of columns and rows of the matrix B and
            //          the number of columns of the matrix C.
            //          N >= 0.

            //  A       (input) COMPLEX*16 array, dimension (LDA, N)
            //          A contains the M by N matrix A.

            //  LDA     (input) int
            //          The leading dimension of the array A. LDA >=max(1,M).

            //  B       (input) DOUBLE PRECISION array, dimension (LDB, N)
            //          B contains the N by N matrix B.

            //  LDB     (input) int
            //          The leading dimension of the array B. LDB >=max(1,N).

            //  C       (input) COMPLEX*16 array, dimension (LDC, N)
            //          C contains the M by N matrix C.

            //  LDC     (input) int
            //          The leading dimension of the array C. LDC >=max(1,N).

            //  RWORK   (workspace) DOUBLE PRECISION array, dimension (2*M*N)

            //  =====================================================================

            // System generated locals
            int b_dim1, b_offset, a_dim1, a_offset, c_dim1, c_offset, i__1, i__2, i__3, i__4, i__5;
            double d__1;
            complex16 z__1;

            // Table of constant values
            double c_b6 = 1.0;
            double c_b7 = 0.0;

            // Local variables
            int i, j, l;

            // Parameter adjustments
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;
            b_dim1 = *ldb;
            b_offset = 1 + b_dim1;
            b -= b_offset;
            c_dim1 = *ldc;
            c_offset = 1 + c_dim1;
            c -= c_offset;
            --rwork;

            // Function Body
            if (*m == 0 || *n == 0)
            {
                return 0;
            }

            i__1 = *n;
            for (j = 1; j <= i__1; ++j)
            {
                i__2 = *m;
                for (i = 1; i <= i__2; ++i)
                {
                    i__3 = i + j * a_dim1;
                    rwork[(j - 1) * *m + i] = a[i__3].r;
                }
            }

            l = *m * *n + 1;
            dgemm("N", "N", m, n, n, &c_b6, &rwork[1], m, &b[b_offset], ldb, &c_b7, &rwork[l], m);
            i__1 = *n;
            for (j = 1; j <= i__1; ++j)
            {
                i__2 = *m;
                for (i = 1; i <= i__2; ++i)
                {
                    i__3 = i + j * c_dim1;
                    i__4 = l + (j - 1) * *m + i - 1;

                    c[i__3].r = rwork[i__4];
                    c[i__3].i = 0.0;
                }
            }

            i__1 = *n;
            for (j = 1; j <= i__1; ++j)
            {
                i__2 = *m;
                for (i = 1; i <= i__2; ++i)
                {
                    rwork[(j - 1) * *m + i] = d_imag(&a[i + j * a_dim1]);
                }
            }

            dgemm("N", "N", m, n, n, &c_b6, &rwork[1], m, &b[b_offset], ldb, &c_b7, &rwork[l], m);
            i__1 = *n;
            for (j = 1; j <= i__1; ++j)
            {
                i__2 = *m;
                for (i = 1; i <= i__2; ++i)
                {
                    i__3 = i + j * c_dim1;
                    i__4 = i + j * c_dim1;

                    d__1 = c[i__4].r;
                    i__5 = l + (j - 1) * *m + i - 1;
                    z__1.r = d__1;
                    z__1.i = rwork[i__5];

                    c[i__3].r = z__1.r;
                    c[i__3].i = z__1.i;
                }
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static void zladiv(complex16* ret_val, complex16* x, complex16* y)
        {
            //  -- LAPACK auxiliary routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. 
            //     November 2006 

            //  Purpose 
            //  ======= 

            //  ZLADIV := X / Y, where X and Y are complex.  The computation of X / Y 
            //  will not overflow on an intermediary step unless the results 
            //  overflows. 

            //  Arguments 
            //  ========= 

            //  X       (input) COMPLEX*16 
            //  Y       (input) COMPLEX*16 
            //          The complex scalars X and Y. 

            //  ===================================================================== 

            // System generated locals 
            double d__1, d__2, d__3, d__4;
            complex16 z__1;

            // Local variables 
            double zi, zr;

            d__1 = x.r;
            d__2 = d_imag(x);
            d__3 = y.r;
            d__4 = d_imag(y);
            dladiv(&d__1, &d__2, &d__3, &d__4, &zr, &zi);

            z__1.r = zr;
            z__1.i = zi;

            ret_val.r = z__1.r;
            ret_val.i = z__1.i;

            return;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zlaein(bool* rightv, bool* noinit, int* n, complex16* h, int* ldh, complex16* w,
            complex16* v, complex16* b, int* ldb, double* rwork, double* eps3, double* smlnum, int* info)
        {
            //  -- LAPACK auxiliary routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     November 2006

            //  Purpose
            //  =======

            //  ZLAEIN uses inverse iteration to find a right or left eigenvector
            //  corresponding to the eigenvalue W of a complex upper Hessenberg
            //  matrix H.

            //  Arguments
            //  =========

            //  RIGHTV   (input) LOGICAL
            //          = .TRUE. : compute right eigenvector;
            //          = .FALSE.: compute left eigenvector.

            //  NOINIT   (input) LOGICAL
            //          = .TRUE. : no initial vector supplied in V
            //          = .FALSE.: initial vector supplied in V.

            //  N       (input) INTEGER
            //          The order of the matrix H.  N >= 0.

            //  H       (input) COMPLEX*16 array, dimension (LDH,N)
            //          The upper Hessenberg matrix H.

            //  LDH     (input) INTEGER
            //          The leading dimension of the array H.  LDH >= max(1,N).

            //  W       (input) COMPLEX*16
            //          The eigenvalue of H whose corresponding right or left
            //          eigenvector is to be computed.

            //  V       (input/output) COMPLEX*16 array, dimension (N)
            //          On entry, if NOINIT = .FALSE., V must contain a starting
            //          vector for inverse iteration; otherwise V need not be set.
            //          On exit, V contains the computed eigenvector, normalized so
            //          that the component of largest magnitude has magnitude 1; here
            //          the magnitude of a complex number (x,y) is taken to be
            //          |x| + |y|.

            //  B       (workspace) COMPLEX*16 array, dimension (LDB,N)

            //  LDB     (input) INTEGER
            //          The leading dimension of the array B.  LDB >= max(1,N).

            //  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)

            //  EPS3    (input) DOUBLE PRECISION
            //          A small machine-dependent value which is used to perturb
            //          close eigenvalues, and to replace zero pivots.

            //  SMLNUM  (input) DOUBLE PRECISION
            //          A machine-dependent value close to the underflow threshold.

            //  INFO    (output) INTEGER
            //          = 0:  successful exit
            //          = 1:  inverse iteration did not converge; V is set to the
            //                last iterate.

            //  =====================================================================

            // System generated locals
            int b_dim1, b_offset, h_dim1, h_offset, i__1, i__2, i__3, i__4, i__5;
            double d__1, d__2, d__3;
            complex16 z__1, z__2;

            // Table of constant values
            int c__1 = 1;

            // Local variables
            int i, j;
            complex16 x, ei, ej;
            int its, ierr;
            complex16 temp;
            double scale;
            string trans;
            double rtemp, rootn, vnorm;
            string normin;
            double nrmsml;
            double growto;

            // Parameter adjustments
            h_dim1 = *ldh;
            h_offset = 1 + h_dim1;
            h -= h_offset;
            --v;
            b_dim1 = *ldb;
            b_offset = 1 + b_dim1;
            b -= b_offset;
            --rwork;

            // Function Body
            *info = 0;

            // GROWTO is the threshold used in the acceptance test for an
            // eigenvector.

            rootn = Math.Sqrt((double)(*n));
            growto = 0.1 / rootn;
            // Computing MAX
            d__1 = 1.0;
            d__2 = *eps3 * rootn;
            nrmsml = Math.Max(d__1, d__2) * *smlnum;

            // Form B = H - W*I (except that the subdiagonal elements are not
            // stored).

            i__1 = *n;
            for (j = 1; j <= i__1; ++j)
            {
                i__2 = j - 1;
                for (i = 1; i <= i__2; ++i)
                {
                    i__3 = i + j * b_dim1;
                    i__4 = i + j * h_dim1;

                    b[i__3].r = h[i__4].r;
                    b[i__3].i = h[i__4].i;
                }

                i__2 = j + j * b_dim1;
                i__3 = j + j * h_dim1;

                z__1.r = h[i__3].r - w.r;
                z__1.i = h[i__3].i - w.i;

                b[i__2].r = z__1.r;
                b[i__2].i = z__1.i;
            }

            if (*noinit)
            {
                // Initialize V.

                i__1 = *n;
                for (i = 1; i <= i__1; ++i)
                {
                    i__2 = i;
                    v[i__2].r = *eps3;
                    v[i__2].i = 0.0;
                }
            }
            else
            {
                // Scale supplied initial vector.

                vnorm = dznrm2(n, &v[1], &c__1);
                d__1 = *eps3 * rootn / Math.Max(vnorm, nrmsml);
                zdscal(n, &d__1, &v[1], &c__1);
            }

            if (*rightv)
            {
                // LU decomposition with partial pivoting of B, replacing zero
                // pivots by EPS3.

                i__1 = *n - 1;
                for (i = 1; i <= i__1; ++i)
                {
                    i__2 = i + 1 + i * h_dim1;
                    ei.r = h[i__2].r;
                    ei.i = h[i__2].i;
                    i__2 = i + i * b_dim1;
                    if (Math.Abs(b[i__2].r) + Math.Abs(d_imag(&b[i + i * b_dim1])) < Math.Abs(ei.r) + Math.Abs(d_imag(&ei)))
                    {
                        // Interchange rows and eliminate.

                        zladiv(&z__1, &b[i + i * b_dim1], &ei);

                        x.r = z__1.r;
                        x.i = z__1.i;

                        i__2 = i + i * b_dim1;

                        b[i__2].r = ei.r;
                        b[i__2].i = ei.i;

                        i__2 = *n;
                        for (j = i + 1; j <= i__2; ++j)
                        {
                            i__3 = i + 1 + j * b_dim1;

                            temp.r = b[i__3].r;
                            temp.i = b[i__3].i;

                            i__3 = i + 1 + j * b_dim1;
                            i__4 = i + j * b_dim1;

                            z__2.r = x.r * temp.r - x.i * temp.i;
                            z__2.i = x.r * temp.i + x.i * temp.r;

                            z__1.r = b[i__4].r - z__2.r;
                            z__1.i = b[i__4].i - z__2.i;

                            b[i__3].r = z__1.r;
                            b[i__3].i = z__1.i;

                            i__3 = i + j * b_dim1;

                            b[i__3].r = temp.r;
                            b[i__3].i = temp.i;
                        }
                    }
                    else
                    {
                        // Eliminate without interchange.

                        i__2 = i + i * b_dim1;
                        if (b[i__2].r == 0.0 && b[i__2].i == 0.0)
                        {
                            i__3 = i + i * b_dim1;

                            b[i__3].r = *eps3;
                            b[i__3].i = 0.0;
                        }

                        zladiv(&z__1, &ei, &b[i + i * b_dim1]);

                        x.r = z__1.r;
                        x.i = z__1.i;

                        if (x.r != 0.0 || x.i != 0.0)
                        {
                            i__2 = *n;
                            for (j = i + 1; j <= i__2; ++j)
                            {
                                i__3 = i + 1 + j * b_dim1;
                                i__4 = i + 1 + j * b_dim1;

                                i__5 = i + j * b_dim1;

                                z__2.r = x.r * b[i__5].r - x.i * b[i__5].i;
                                z__2.i = x.r * b[i__5].i + x.i * b[i__5].r;

                                z__1.r = b[i__4].r - z__2.r;
                                z__1.i = b[i__4].i - z__2.i;

                                b[i__3].r = z__1.r;
                                b[i__3].i = z__1.i;
                            }
                        }
                    }
                }

                i__1 = *n + *n * b_dim1;
                if (b[i__1].r == 0.0 && b[i__1].i == 0.0)
                {
                    i__2 = *n + *n * b_dim1;
                    b[i__2].r = *eps3;
                    b[i__2].i = 0.0;
                }

                trans = "N";
            }
            else
            {
                // UL decomposition with partial pivoting of B, replacing zero
                // pivots by EPS3.

                for (j = *n; j >= 2; --j)
                {
                    i__1 = j + (j - 1) * h_dim1;
                    ej.r = h[i__1].r;
                    ej.i = h[i__1].i;

                    i__1 = j + j * b_dim1;
                    if (Math.Abs(b[i__1].r) + Math.Abs(d_imag(&b[j + j * b_dim1])) < Math.Abs(ej.r) + Math.Abs(d_imag(&ej)))
                    {
                        // Interchange columns and eliminate.

                        zladiv(&z__1, &b[j + j * b_dim1], &ej);

                        x.r = z__1.r;
                        x.i = z__1.i;

                        i__1 = j + j * b_dim1;

                        b[i__1].r = ej.r;
                        b[i__1].i = ej.i;

                        i__1 = j - 1;
                        for (i = 1; i <= i__1; ++i)
                        {
                            i__2 = i + (j - 1) * b_dim1;
                            temp.r = b[i__2].r;
                            temp.i = b[i__2].i;

                            i__2 = i + (j - 1) * b_dim1;
                            i__3 = i + j * b_dim1;

                            z__2.r = x.r * temp.r - x.i * temp.i;
                            z__2.i = x.r * temp.i + x.i * temp.r;

                            z__1.r = b[i__3].r - z__2.r;
                            z__1.i = b[i__3].i - z__2.i;

                            b[i__2].r = z__1.r;
                            b[i__2].i = z__1.i;

                            i__2 = i + j * b_dim1;

                            b[i__2].r = temp.r;
                            b[i__2].i = temp.i;
                        }
                    }
                    else
                    {
                        // Eliminate without interchange.

                        i__1 = j + j * b_dim1;
                        if (b[i__1].r == 0.0 && b[i__1].i == 0.0)
                        {
                            i__2 = j + j * b_dim1;
                            b[i__2].r = *eps3;
                            b[i__2].i = 0.0;
                        }

                        zladiv(&z__1, &ej, &b[j + j * b_dim1]);
                        x.r = z__1.r;
                        x.i = z__1.i;

                        if (x.r != 0.0 || x.i != 0.0)
                        {
                            i__1 = j - 1;
                            for (i = 1; i <= i__1; ++i)
                            {
                                i__2 = i + (j - 1) * b_dim1;
                                i__3 = i + (j - 1) * b_dim1;

                                i__4 = i + j * b_dim1;

                                z__2.r = x.r * b[i__4].r - x.i * b[i__4].i;
                                z__2.i = x.r * b[i__4].i + x.i * b[i__4].r;

                                z__1.r = b[i__3].r - z__2.r;
                                z__1.i = b[i__3].i - z__2.i;

                                b[i__2].r = z__1.r;
                                b[i__2].i = z__1.i;
                            }
                        }
                    }
                }

                i__1 = b_dim1 + 1;
                if (b[i__1].r == 0.0 && b[i__1].i == 0.0)
                {
                    i__2 = b_dim1 + 1;
                    b[i__2].r = *eps3;
                    b[i__2].i = 0.0;
                }

                trans = "C";
            }

            normin = "N";

            i__1 = *n;
            for (its = 1; its <= i__1; ++its)
            {
                // Solve U*x = scale*v for a right eigenvector
                // or U'*x = scale*v for a left eigenvector,
                // overwriting x on v.

                zlatrs("Upper", trans, "Nonunit", normin, n, &b[b_offset], ldb, &v[1], &scale, &rwork[1], &ierr);
                normin = "Y";

                // Test for sufficient growth in the norm of v.

                vnorm = dzasum(n, &v[1], &c__1);
                if (vnorm >= growto * scale)
                {
                    goto L120;
                }

                // Choose new orthogonal starting vector and try again.

                rtemp = *eps3 / (rootn + 1.0);
                v[1].r = *eps3;
                v[1].i = 0.0;
                i__2 = *n;

                for (i = 2; i <= i__2; ++i)
                {
                    i__3 = i;
                    v[i__3].r = rtemp;
                    v[i__3].i = 0.0;
                }

                i__2 = *n - its + 1;
                i__3 = *n - its + 1;

                d__1 = *eps3 * rootn;
                z__1.r = v[i__3].r - d__1;

                z__1.i = v[i__3].i;

                v[i__2].r = z__1.r;
                v[i__2].i = z__1.i;
            }

            // Failure to find eigenvector in N iterations.

            *info = 1;

        L120:

            // Normalize eigenvector.

            i = izamax(n, &v[1], &c__1);
            i__1 = i;
            d__3 = 1.0 / (Math.Abs(v[i__1].r) + Math.Abs(d_imag(&v[i])));
            zdscal(n, &d__3, &v[1], &c__1);

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zlahqr(bool* wantt, bool* wantz, int* n, int* ilo, int* ihi, complex16* h, int* ldh,
            complex16* w, int* iloz, int* ihiz, complex16* z, int* ldz, int* info)
        {
            //  -- LAPACK auxiliary routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd.. 
            //     November 2006 

            //     Purpose 
            //     ======= 

            //     ZLAHQR is an auxiliary routine called by CHSEQR to update the 
            //     eigenvalues and Schur decomposition already computed by CHSEQR, by 
            //     dealing with the Hessenberg submatrix in rows and columns ILO to 
            //     IHI. 

            //     Arguments 
            //     ========= 

            //     WANTT   (input) bool 
            //          = .TRUE. : the full Schur form T is required; 
            //          = .FALSE.: only eigenvalues are required. 

            //     WANTZ   (input) bool 
            //          = .TRUE. : the matrix of Schur vectors Z is required; 
            //          = .FALSE.: Schur vectors are not required. 

            //     N       (input) int 
            //          The order of the matrix H.  N >= 0. 

            //     ILO     (input) int 
            //     IHI     (input) int 
            //          It is assumed that H is already upper triangular in rows and 
            //          columns IHI+1:N, and that H(ILO,ILO-1) = 0 (unless ILO = 1). 
            //          ZLAHQR works primarily with the Hessenberg submatrix in rows 
            //          and columns ILO to IHI, but applies transformations to all of 
            //          H if WANTT is .TRUE.. 
            //          1 <= ILO <= max(1,IHI); IHI <= N. 

            //     H       (input/output) COMPLEX*16 array, dimension (LDH,N) 
            //          On entry, the upper Hessenberg matrix H. 
            //          On exit, if INFO is zero and if WANTT is .TRUE., then H 
            //          is upper triangular in rows and columns ILO:IHI.  If INFO 
            //          is zero and if WANTT is .FALSE., then the contents of H 
            //          are unspecified on exit.  The output state of H in case 
            //          INF is positive is below under the description of INFO. 

            //     LDH     (input) int 
            //          The leading dimension of the array H. LDH >= max(1,N). 

            //     W       (output) COMPLEX*16 array, dimension (N) 
            //          The computed eigenvalues ILO to IHI are stored in the 
            //          corresponding elements of W. If WANTT is .TRUE., the 
            //          eigenvalues are stored in the same order as on the diagonal 
            //          of the Schur form returned in H, with W(i) = H(i,i). 

            //     ILOZ    (input) int 
            //     IHIZ    (input) int 
            //          Specify the rows of Z to which transformations must be 
            //          applied if WANTZ is .TRUE.. 
            //          1 <= ILOZ <= ILO; IHI <= IHIZ <= N. 

            //     Z       (input/output) COMPLEX*16 array, dimension (LDZ,N) 
            //          If WANTZ is .TRUE., on entry Z must contain the current 
            //          matrix Z of transformations accumulated by CHSEQR, and on 
            //          exit Z has been updated; transformations are applied only to 
            //          the submatrix Z(ILOZ:IHIZ,ILO:IHI). 
            //          If WANTZ is .FALSE., Z is not referenced. 

            //     LDZ     (input) int 
            //          The leading dimension of the array Z. LDZ >= max(1,N). 

            //     INFO    (output) int 
            //           =   0: successful exit 
            //          .GT. 0: if INFO = i, ZLAHQR failed to compute all the 
            //                  eigenvalues ILO to IHI in a total of 30 iterations 
            //                  per eigenvalue; elements i+1:ihi of W contain 
            //                  those eigenvalues which have been successfully 
            //                  computed. 

            //                  If INFO .GT. 0 and WANTT is .FALSE., then on exit, 
            //                  the remaining unconverged eigenvalues are the 
            //                  eigenvalues of the upper Hessenberg matrix 
            //                  rows and columns ILO thorugh INFO of the final, 
            //                  output value of H. 

            //                  If INFO .GT. 0 and WANTT is .TRUE., then on exit 
            //          (*)       (initial value of H)*U  = U*(final value of H) 
            //                  where U is an orthognal matrix.    The final 
            //                  value of H is upper Hessenberg and triangular in 
            //                  rows and columns INFO+1 through IHI. 

            //                  If INFO .GT. 0 and WANTZ is .TRUE., then on exit 
            //                      (final value of Z)  = (initial value of Z)*U 
            //                  where U is the orthogonal matrix in (*) 
            //                  (regardless of the value of WANTT.) 

            //     Further Details 
            //     =============== 

            //     02-96 Based on modifications by 
            //     David Day, Sandia National Laboratory, USA 

            //     12-04 Further modifications by 
            //     Ralph Byers, University of Kansas, USA 
            //     This is a modified version of ZLAHQR from LAPACK version 3.0. 
            //     It is (1) more robust against overflow and underflow and 
            //     (2) adopts the more conservative Ahues & Tisseur stopping 
            //     criterion (LAWN 122, 1997). 

            //     ========================================================= 

            // System generated locals 
            int h_dim1, h_offset, z_dim1, z_offset, i__1, i__2, i__3, i__4;
            double d__1, d__2, d__3, d__4, d__5, d__6;
            complex16 z__1, z__2, z__3, z__4, z__5, z__6, z__7;

            // Table of constant values
            int c__1 = 1;
            int c__2 = 2;

            // Local variables 
            int i, j, k, l, m;
            double s;
            complex16 t, u, x, y;
            complex16[] v = new complex16[2];
            int i1 = 0, i2 = 0;
            complex16 t1;
            double t2;
            complex16 v2;
            double aa, ab, ba, bb, h10;
            complex16 h11;
            double h21;
            complex16 h22, sc;
            int nh, nz;
            double sx;
            int jhi;
            complex16 h11s;
            int jlo, its;
            double ulp;
            complex16 sum;
            double tst;
            complex16 temp;
            double rtemp;
            double safmin, safmax;
            double smlnum;

            // Parameter adjustments 
            h_dim1 = *ldh;
            h_offset = 1 + h_dim1;
            h -= h_offset;
            --w;
            z_dim1 = *ldz;
            z_offset = 1 + z_dim1;
            z -= z_offset;

            // Function Body 
            *info = 0;

            // Quick return if possible 

            if (*n == 0)
            {
                return 0;
            }
            if (*ilo == *ihi)
            {
                i__1 = *ilo;
                i__2 = *ilo + *ilo * h_dim1;

                w[i__1].r = h[i__2].r;
                w[i__1].i = h[i__2].i;
                return 0;
            }

            // ==== clear out the trash ==== 
            i__1 = *ihi - 3;
            for (j = *ilo; j <= i__1; ++j)
            {
                i__2 = j + 2 + j * h_dim1;

                h[i__2].r = 0.0;
                h[i__2].i = 0.0;
                i__2 = j + 3 + j * h_dim1;

                h[i__2].r = 0.0;
                h[i__2].i = 0.0;
            }
            if (*ilo <= *ihi - 2)
            {
                i__1 = *ihi + (*ihi - 2) * h_dim1;

                h[i__1].r = 0.0;
                h[i__1].i = 0.0;
            }

            // ==== ensure that subdiagonal entries are real ==== 
            if (*wantt)
            {
                jlo = 1;
                jhi = *n;
            }
            else
            {
                jlo = *ilo;
                jhi = *ihi;
            }

            i__1 = *ihi;

            for (i = *ilo + 1; i <= i__1; ++i)
            {
                if (d_imag(&h[i + (i - 1) * h_dim1]) != 0.0)
                {
                    // ==== The following redundant normalization 
                    // .    avoids problems with both gradual and 
                    // .    sudden underflow in ABS(H(I,I-1)) ==== 

                    i__2 = i + (i - 1) * h_dim1;
                    i__3 = i + (i - 1) * h_dim1;
                    d__3 = Math.Abs(h[i__3].r) + Math.Abs(d_imag(&h[i + (i - 1) * h_dim1]));

                    z__1.r = h[i__2].r / d__3;
                    z__1.i = h[i__2].i / d__3;

                    sc.r = z__1.r;
                    sc.i = z__1.i;

                    d_cnjg(&z__2, &sc);
                    d__1 = z_abs(&sc);

                    z__1.r = z__2.r / d__1;
                    z__1.i = z__2.i / d__1;

                    sc.r = z__1.r;
                    sc.i = z__1.i;

                    i__2 = i + (i - 1) * h_dim1;
                    d__1 = z_abs(&h[i + (i - 1) * h_dim1]);

                    h[i__2].r = d__1;
                    h[i__2].i = 0.0;

                    i__2 = jhi - i + 1;

                    zscal(&i__2, &sc, &h[i + i * h_dim1], ldh);

                    // Computing MIN 
                    i__3 = jhi;
                    i__4 = i + 1;
                    i__2 = Math.Min(i__3, i__4) - jlo + 1;
                    d_cnjg(&z__1, &sc);
                    zscal(&i__2, &z__1, &h[jlo + i * h_dim1], &c__1);

                    if (*wantz)
                    {
                        i__2 = *ihiz - *iloz + 1;
                        d_cnjg(&z__1, &sc);
                        zscal(&i__2, &z__1, &z[*iloz + i * z_dim1], &c__1);
                    }
                }
            }

            nh = *ihi - *ilo + 1;
            nz = *ihiz - *iloz + 1;

            // Set machine-dependent constants for the stopping criterion. 

            safmin = dlamch("SAFE MINIMUM");
            safmax = 1.0 / safmin;
            dlabad(&safmin, &safmax);
            ulp = dlamch("PRECISION");
            smlnum = safmin * ((double)nh / ulp);

            // I1 and I2 are the indices of the first row and last column of H 
            // to which transformations must be applied. If eigenvalues only are 
            // being computed, I1 and I2 are set inside the main loop. 

            if (*wantt)
            {
                i1 = 1;
                i2 = *n;
            }

            // The main loop begins here. I is the loop index and decreases from 
            // IHI to ILO in steps of 1. Each iteration of the loop works 
            // with the active submatrix in rows and columns L to I. 
            // Eigenvalues I+1 to IHI have already converged. Either L = ILO, or 
            // H(L,L-1) is negligible so that the matrix splits. 

            i = *ihi;
        L30:
            if (i < *ilo)
            {
                goto L150;
            }

            // Perform QR iterations on rows and columns ILO to I until a 
            // submatrix of order 1 splits off at the bottom because a 
            // subdiagonal element has become negligible. 

            l = *ilo;
            for (its = 0; its <= 30; ++its)
            {

                // Look for a single small subdiagonal element. 

                i__1 = l + 1;
                for (k = i; k >= i__1; --k)
                {
                    i__2 = k + (k - 1) * h_dim1;

                    if (Math.Abs(h[i__2].r) + Math.Abs(d_imag(&h[k + (k - 1) * h_dim1])) <= smlnum)
                    {
                        goto L50;
                    }

                    i__2 = k - 1 + (k - 1) * h_dim1;
                    i__3 = k + k * h_dim1;
                    tst = Math.Abs(h[i__2].r) + Math.Abs(d_imag(&h[k - 1 + (k - 1) * h_dim1])) +
                        (Math.Abs(h[i__3].r) + Math.Abs(d_imag(&h[k + k * h_dim1])));

                    if (tst == 0.0)
                    {
                        if (k - 2 >= *ilo)
                        {
                            i__2 = k - 1 + (k - 2) * h_dim1;
                            tst += Math.Abs(h[i__2].r);
                        }
                        if (k + 1 <= *ihi)
                        {
                            i__2 = k + 1 + k * h_dim1;
                            tst += Math.Abs(h[i__2].r);
                        }
                    }

                    // ==== The following is a conservative small subdiagonal 
                    // .    deflation criterion due to Ahues & Tisseur (LAWN 122, 
                    // .    1997). It has better mathematical foundation and 
                    // .    improves accuracy in some examples.  ==== 
                    i__2 = k + (k - 1) * h_dim1;
                    if (Math.Abs(h[i__2].r) <= ulp * tst)
                    {
                        // Computing MAX 
                        i__2 = k + (k - 1) * h_dim1;
                        i__3 = k - 1 + k * h_dim1;

                        d__5 = Math.Abs(h[i__2].r) + Math.Abs(d_imag(&h[k + (k - 1) * h_dim1]));
                        d__6 = Math.Abs(h[i__3].r) + Math.Abs(d_imag(&h[k - 1 + k * h_dim1]));

                        ab = Math.Max(d__5, d__6);
                        // Computing MIN 
                        i__2 = k + (k - 1) * h_dim1;
                        i__3 = k - 1 + k * h_dim1;
                        d__5 = Math.Abs(h[i__2].r) + Math.Abs(d_imag(&h[k + (k - 1) * h_dim1]));
                        d__6 = Math.Abs(h[i__3].r) + Math.Abs(d_imag(&h[k - 1 + k * h_dim1]));
                        ba = Math.Min(d__5, d__6);
                        i__2 = k - 1 + (k - 1) * h_dim1;
                        i__3 = k + k * h_dim1;

                        z__2.r = h[i__2].r - h[i__3].r;
                        z__2.i = h[i__2].i - h[i__3].i;

                        z__1.r = z__2.r;
                        z__1.i = z__2.i;

                        // Computing MAX 
                        i__4 = k + k * h_dim1;
                        d__5 = Math.Abs(h[i__4].r) + Math.Abs(d_imag(&h[k + k * h_dim1]));
                        d__6 = Math.Abs(z__1.r) + Math.Abs(d_imag(&z__1));
                        aa = Math.Max(d__5, d__6);
                        i__2 = k - 1 + (k - 1) * h_dim1;
                        i__3 = k + k * h_dim1;

                        z__2.r = h[i__2].r - h[i__3].r;
                        z__2.i = h[i__2].i - h[i__3].i;

                        z__1.r = z__2.r;
                        z__1.i = z__2.i;

                        // Computing MIN 
                        i__4 = k + k * h_dim1;
                        d__5 = Math.Abs(h[i__4].r) + Math.Abs(d_imag(&h[k + k * h_dim1]));
                        d__6 = Math.Abs(z__1.r) + Math.Abs(d_imag(&z__1));
                        bb = Math.Min(d__5, d__6);
                        s = aa + ab;

                        // Computing MAX 
                        d__1 = smlnum;
                        d__2 = ulp * (bb * (aa / s));
                        if (ba * (ab / s) <= Math.Max(d__1, d__2))
                        {
                            goto L50;
                        }
                    }
                }
            L50:
                l = k;
                if (l > *ilo)
                {
                    // H(L,L-1) is negligible 

                    i__1 = l + (l - 1) * h_dim1;
                    h[i__1].r = 0.0;
                    h[i__1].i = 0.0;
                }

                // Exit from loop if a submatrix of order 1 has split off. 

                if (l >= i)
                {
                    goto L140;
                }

                // Now the active submatrix is in rows and columns L to I. If 
                // eigenvalues only are being computed, only the active submatrix 
                // need be transformed. 

                if (!(*wantt))
                {
                    i1 = l;
                    i2 = i;
                }

                if (its == 10)
                {
                    // Exceptional shift. 

                    i__1 = l + 1 + l * h_dim1;
                    s = Math.Abs(h[i__1].r) * 0.75;
                    i__1 = l + l * h_dim1;

                    z__1.r = s + h[i__1].r;
                    z__1.i = h[i__1].i;

                    t.r = z__1.r;
                    t.i = z__1.i;
                }
                else if (its == 20)
                {
                    // Exceptional shift. 

                    i__1 = i + (i - 1) * h_dim1;
                    s = Math.Abs(h[i__1].r) * 0.75;
                    i__1 = i + i * h_dim1;

                    z__1.r = s + h[i__1].r;
                    z__1.i = h[i__1].i;

                    t.r = z__1.r;
                    t.i = z__1.i;
                }
                else
                {
                    // Wilkinson's shift. 

                    i__1 = i + i * h_dim1;

                    t.r = h[i__1].r;
                    t.i = h[i__1].i;

                    z_sqrt(&z__2, &h[i - 1 + i * h_dim1]);
                    z_sqrt(&z__3, &h[i + (i - 1) * h_dim1]);

                    z__1.r = z__2.r * z__3.r - z__2.i * z__3.i;
                    z__1.i = z__2.r * z__3.i + z__2.i * z__3.r;

                    u.r = z__1.r;
                    u.i = z__1.i;

                    s = Math.Abs(u.r) + Math.Abs(d_imag(&u));

                    if (s != 0.0)
                    {
                        i__1 = i - 1 + (i - 1) * h_dim1;

                        z__2.r = h[i__1].r - t.r;
                        z__2.i = h[i__1].i - t.i;

                        z__1.r = z__2.r * 0.5;
                        z__1.i = z__2.i * 0.5;

                        x.r = z__1.r;
                        x.i = z__1.i;

                        sx = Math.Abs(x.r) + Math.Abs(d_imag(&x));

                        // Computing MAX 
                        d__3 = s;
                        d__4 = Math.Abs(x.r) + Math.Abs(d_imag(&x));
                        s = Math.Max(d__3, d__4);

                        z__5.r = x.r / s;
                        z__5.i = x.i / s;

                        pow_zi(&z__4, &z__5, &c__2);

                        z__7.r = u.r / s;
                        z__7.i = u.i / s;

                        pow_zi(&z__6, &z__7, &c__2);

                        z__3.r = z__4.r + z__6.r;
                        z__3.i = z__4.i + z__6.i;

                        z_sqrt(&z__2, &z__3);

                        z__1.r = s * z__2.r;
                        z__1.i = s * z__2.i;

                        y.r = z__1.r;
                        y.i = z__1.i;

                        if (sx > 0.0)
                        {
                            z__1.r = x.r / sx;
                            z__1.i = x.i / sx;

                            z__2.r = x.r / sx;
                            z__2.i = x.i / sx;

                            if (z__1.r * y.r + d_imag(&z__2) * d_imag(&y) < 0.0)
                            {
                                z__3.r = -y.r;
                                z__3.i = -y.i;

                                y.r = z__3.r;
                                y.i = z__3.i;
                            }
                        }

                        z__4.r = x.r + y.r;
                        z__4.i = x.i + y.i;

                        zladiv(&z__3, &u, &z__4);

                        z__2.r = u.r * z__3.r - u.i * z__3.i;
                        z__2.i = u.r * z__3.i + u.i * z__3.r;

                        z__1.r = t.r - z__2.r;
                        z__1.i = t.i - z__2.i;

                        t.r = z__1.r;
                        t.i = z__1.i;
                    }
                }

                // Look for two consecutive small subdiagonal elements. 

                i__1 = l + 1;
                for (m = i - 1; m >= i__1; --m)
                {
                    // Determine the effect of starting the single-shift QR 
                    // iteration at row M, and see if this would make H(M,M-1) 
                    // negligible. 

                    i__2 = m + m * h_dim1;

                    h11.r = h[i__2].r;
                    h11.i = h[i__2].i;

                    i__2 = m + 1 + (m + 1) * h_dim1;

                    h22.r = h[i__2].r;
                    h22.i = h[i__2].i;

                    z__1.r = h11.r - t.r;
                    z__1.i = h11.i - t.i;

                    h11s.r = z__1.r;
                    h11s.i = z__1.i;

                    i__2 = m + 1 + m * h_dim1;
                    h21 = h[i__2].r;
                    s = Math.Abs(h11s.r) + Math.Abs(d_imag(&h11s)) + Math.Abs(h21);

                    z__1.r = h11s.r / s;
                    z__1.i = h11s.i / s;

                    h11s.r = z__1.r;
                    h11s.i = z__1.i;

                    h21 /= s;

                    v[0].r = h11s.r;
                    v[0].i = h11s.i;

                    v[1].r = h21;
                    v[1].i = 0.0;

                    i__2 = m + (m - 1) * h_dim1;
                    h10 = h[i__2].r;

                    if (Math.Abs(h10) * Math.Abs(h21) <= ulp * ((Math.Abs(h11s.r) + Math.Abs(d_imag(&h11s))) *
                        (Math.Abs(h11.r) + Math.Abs(d_imag(&h11)) + (Math.Abs(h22.r) + Math.Abs(d_imag(&h22))))))
                    {
                        goto L70;
                    }
                }

                i__1 = l + l * h_dim1;

                h11.r = h[i__1].r;
                h11.i = h[i__1].i;

                i__1 = l + 1 + (l + 1) * h_dim1;

                h22.r = h[i__1].r;
                h22.i = h[i__1].i;

                z__1.r = h11.r - t.r;
                z__1.i = h11.i - t.i;

                h11s.r = z__1.r;
                h11s.i = z__1.i;

                i__1 = l + 1 + l * h_dim1;
                h21 = h[i__1].r;
                s = Math.Abs(h11s.r) + Math.Abs(d_imag(&h11s)) + Math.Abs(h21);

                z__1.r = h11s.r / s;
                z__1.i = h11s.i / s;

                h11s.r = z__1.r;
                h11s.i = z__1.i;
                h21 /= s;
                v[0].r = h11s.r;
                v[0].i = h11s.i;

                v[1].r = h21;
                v[1].i = 0.0;
            L70:

                // Single-shift QR step 

                i__1 = i - 1;
                for (k = m; k <= i__1; ++k)
                {
                    // The first iteration of this loop determines a reflection G 
                    // from the vector V and applies it from left and right to H, 
                    // thus creating a nonzero bulge below the subdiagonal. 

                    // Each subsequent iteration determines a reflection G to 
                    // restore the Hessenberg form in the (K-1)th column, and thus 
                    // chases the bulge one step toward the bottom of the active 
                    // submatrix. 

                    // V(2) is always real before the call to ZLARFG, and hence 
                    // after the call T2 ( = T1*V(2) ) is also real. 

                    if (k > m)
                    {
                        zcopy(&c__2, &h[k + (k - 1) * h_dim1], &c__1, v, &c__1);
                    }
                    zlarfg(&c__2, v, &v[1], &c__1, &t1);

                    if (k > m)
                    {
                        i__2 = k + (k - 1) * h_dim1;

                        h[i__2].r = v[0].r;
                        h[i__2].i = v[0].i;

                        i__2 = k + 1 + (k - 1) * h_dim1;

                        h[i__2].r = 0.0;
                        h[i__2].i = 0.0;
                    }

                    v2.r = v[1].r;
                    v2.i = v[1].i;
                    z__1.r = t1.r * v2.r - t1.i * v2.i;
                    z__1.i = t1.r * v2.i + t1.i * v2.r;
                    t2 = z__1.r;

                    // Apply G from the left to transform the rows of the matrix 
                    // in columns K to I2. 

                    i__2 = i2;
                    for (j = k; j <= i__2; ++j)
                    {
                        d_cnjg(&z__3, &t1);
                        i__3 = k + j * h_dim1;

                        z__2.r = z__3.r * h[i__3].r - z__3.i * h[i__3].i;
                        z__2.i = z__3.r * h[i__3].i + z__3.i * h[i__3].r;

                        i__4 = k + 1 + j * h_dim1;

                        z__4.r = t2 * h[i__4].r;
                        z__4.i = t2 * h[i__4].i;

                        z__1.r = z__2.r + z__4.r;
                        z__1.i = z__2.i + z__4.i;

                        sum.r = z__1.r;
                        sum.i = z__1.i;

                        i__3 = k + j * h_dim1;
                        i__4 = k + j * h_dim1;

                        z__1.r = h[i__4].r - sum.r;
                        z__1.i = h[i__4].i - sum.i;

                        h[i__3].r = z__1.r;
                        h[i__3].i = z__1.i;

                        i__3 = k + 1 + j * h_dim1;
                        i__4 = k + 1 + j * h_dim1;

                        z__2.r = sum.r * v2.r - sum.i * v2.i;
                        z__2.i = sum.r * v2.i + sum.i * v2.r;

                        z__1.r = h[i__4].r - z__2.r;
                        z__1.i = h[i__4].i - z__2.i;

                        h[i__3].r = z__1.r;
                        h[i__3].i = z__1.i;
                    }

                    // Apply G from the right to transform the columns of the 
                    // matrix in rows I1 to min(K+2,I). 

                    // Computing MIN 
                    i__3 = k + 2;
                    i__2 = Math.Min(i__3, i);

                    for (j = i1; j <= i__2; ++j)
                    {
                        i__3 = j + k * h_dim1;

                        z__2.r = t1.r * h[i__3].r - t1.i * h[i__3].i;
                        z__2.i = t1.r * h[i__3].i + t1.i * h[i__3].r;

                        i__4 = j + (k + 1) * h_dim1;

                        z__3.r = t2 * h[i__4].r;
                        z__3.i = t2 * h[i__4].i;

                        z__1.r = z__2.r + z__3.r;
                        z__1.i = z__2.i + z__3.i;

                        sum.r = z__1.r;
                        sum.i = z__1.i;

                        i__3 = j + k * h_dim1;
                        i__4 = j + k * h_dim1;

                        z__1.r = h[i__4].r - sum.r;
                        z__1.i = h[i__4].i - sum.i;

                        h[i__3].r = z__1.r;
                        h[i__3].i = z__1.i;

                        i__3 = j + (k + 1) * h_dim1;
                        i__4 = j + (k + 1) * h_dim1;

                        d_cnjg(&z__3, &v2);

                        z__2.r = sum.r * z__3.r - sum.i * z__3.i;
                        z__2.i = sum.r * z__3.i + sum.i * z__3.r;

                        z__1.r = h[i__4].r - z__2.r;
                        z__1.i = h[i__4].i - z__2.i;

                        h[i__3].r = z__1.r;
                        h[i__3].i = z__1.i;
                    }

                    if (*wantz)
                    {
                        // Accumulate transformations in the matrix Z 

                        i__2 = *ihiz;

                        for (j = *iloz; j <= i__2; ++j)
                        {
                            i__3 = j + k * z_dim1;

                            z__2.r = t1.r * z[i__3].r - t1.i * z[i__3].i;
                            z__2.i = t1.r * z[i__3].i + t1.i * z[i__3].r;

                            i__4 = j + (k + 1) * z_dim1;

                            z__3.r = t2 * z[i__4].r;
                            z__3.i = t2 * z[i__4].i;

                            z__1.r = z__2.r + z__3.r;
                            z__1.i = z__2.i + z__3.i;

                            sum.r = z__1.r;
                            sum.i = z__1.i;

                            i__3 = j + k * z_dim1;
                            i__4 = j + k * z_dim1;

                            z__1.r = z[i__4].r - sum.r;
                            z__1.i = z[i__4].i - sum.i;

                            z[i__3].r = z__1.r;
                            z[i__3].i = z__1.i;

                            i__3 = j + (k + 1) * z_dim1;
                            i__4 = j + (k + 1) * z_dim1;
                            d_cnjg(&z__3, &v2);

                            z__2.r = sum.r * z__3.r - sum.i * z__3.i;
                            z__2.i = sum.r * z__3.i + sum.i * z__3.r;

                            z__1.r = z[i__4].r - z__2.r;
                            z__1.i = z[i__4].i - z__2.i;

                            z[i__3].r = z__1.r;
                            z[i__3].i = z__1.i;
                        }
                    }

                    if (k == m && m > l)
                    {
                        // If the QR step was started at row M > L because two 
                        // consecutive small subdiagonals were found, then extra 
                        // scaling must be performed to ensure that H(M,M-1) remains 
                        // real. 

                        z__1.r = 1.0 - t1.r;
                        z__1.i = 0.0 - t1.i;

                        temp.r = z__1.r;
                        temp.i = z__1.i;

                        d__1 = z_abs(&temp);

                        z__1.r = temp.r / d__1;
                        z__1.i = temp.i / d__1;

                        temp.r = z__1.r;
                        temp.i = z__1.i;

                        i__2 = m + 1 + m * h_dim1;
                        i__3 = m + 1 + m * h_dim1;
                        d_cnjg(&z__2, &temp);

                        z__1.r = h[i__3].r * z__2.r - h[i__3].i * z__2.i;
                        z__1.i = h[i__3].r * z__2.i + h[i__3].i * z__2.r;

                        h[i__2].r = z__1.r;
                        h[i__2].i = z__1.i;

                        if (m + 2 <= i)
                        {
                            i__2 = m + 2 + (m + 1) * h_dim1;
                            i__3 = m + 2 + (m + 1) * h_dim1;

                            z__1.r = h[i__3].r * temp.r - h[i__3].i * temp.i;
                            z__1.i = h[i__3].r * temp.i + h[i__3].i * temp.r;

                            h[i__2].r = z__1.r;
                            h[i__2].i = z__1.i;
                        }

                        i__2 = i;
                        for (j = m; j <= i__2; ++j)
                        {
                            if (j != m + 1)
                            {
                                if (i2 > j)
                                {
                                    i__3 = i2 - j;
                                    zscal(&i__3, &temp, &h[j + (j + 1) * h_dim1], ldh);
                                }

                                i__3 = j - i1;
                                d_cnjg(&z__1, &temp);
                                zscal(&i__3, &z__1, &h[i1 + j * h_dim1], &c__1);

                                if (*wantz)
                                {
                                    d_cnjg(&z__1, &temp);
                                    zscal(&nz, &z__1, &z[*iloz + j * z_dim1], &c__1);
                                }
                            }
                        }
                    }
                }

                // Ensure that H(I,I-1) is real. 

                i__1 = i + (i - 1) * h_dim1;

                temp.r = h[i__1].r;
                temp.i = h[i__1].i;

                if (d_imag(&temp) != 0.0)
                {
                    rtemp = z_abs(&temp);
                    i__1 = i + (i - 1) * h_dim1;

                    h[i__1].r = rtemp;
                    h[i__1].i = 0.0;

                    z__1.r = temp.r / rtemp;
                    z__1.i = temp.i / rtemp;

                    temp.r = z__1.r;
                    temp.i = z__1.i;

                    if (i2 > i)
                    {
                        i__1 = i2 - i;
                        d_cnjg(&z__1, &temp);
                        zscal(&i__1, &z__1, &h[i + (i + 1) * h_dim1], ldh);
                    }
                    i__1 = i - i1;

                    zscal(&i__1, &temp, &h[i1 + i * h_dim1], &c__1);
                    if (*wantz)
                    {
                        zscal(&nz, &temp, &z[*iloz + i * z_dim1], &c__1);
                    }
                }
            }

            // Failure to converge in remaining number of iterations 

            *info = i;
            return 0;

        L140:

            // H(I,I-1) is negligible: one eigenvalue has converged. 

            i__1 = i;
            i__2 = i + i * h_dim1;

            w[i__1].r = h[i__2].r;
            w[i__1].i = h[i__2].i;

            // return to start of the main loop with new value of I. 

            i = l - 1;
            goto L30;

        L150:
            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zlahr2(int* n, int* k, int* nb,
            complex16* a, int* lda, complex16* tau, complex16* t,
            int* ldt, complex16* y, int* ldy)
        {
            //  -- LAPACK auxiliary routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. 
            //     November 2006 

            //  Purpose 
            //  ======= 

            //  ZLAHR2 reduces the first NB columns of A complex general n-BY-(n-k+1) 
            //  matrix A so that elements below the k-th subdiagonal are zero. The 
            //  reduction is performed by an unitary similarity transformation 
            //  Q' * A * Q. The routine returns the matrices V and T which determine 
            //  Q as a block reflector I - V*T*V', and also the matrix Y = A * V * T. 

            //  This is an auxiliary routine called by ZGEHRD. 

            //  Arguments 
            //  ========= 

            //  N       (input) int 
            //          The order of the matrix A. 

            //  K       (input) int 
            //          The offset for the reduction. Elements below the k-th 
            //          subdiagonal in the first NB columns are reduced to zero. 
            //          K < N. 

            //  NB      (input) int 
            //          The number of columns to be reduced. 

            //  A       (input/output) COMPLEX*16 array, dimension (LDA,N-K+1) 
            //          On entry, the n-by-(n-k+1) general matrix A. 
            //          On exit, the elements on and above the k-th subdiagonal in 
            //          the first NB columns are overwritten with the corresponding 
            //          elements of the reduced matrix; the elements below the k-th 
            //          subdiagonal, with the array TAU, represent the matrix Q as a 
            //          product of elementary reflectors. The other columns of A are 
            //          unchanged. See Further Details. 

            //  LDA     (input) int 
            //          The leading dimension of the array A.  LDA >= max(1,N). 

            //  TAU     (output) COMPLEX*16 array, dimension (NB) 
            //          The scalar factors of the elementary reflectors. See Further 
            //          Details. 

            //  T       (output) COMPLEX*16 array, dimension (LDT,NB) 
            //          The upper triangular matrix T. 

            //  LDT     (input) int 
            //          The leading dimension of the array T.  LDT >= NB. 

            //  Y       (output) COMPLEX*16 array, dimension (LDY,NB) 
            //          The n-by-nb matrix Y. 

            //  LDY     (input) int 
            //          The leading dimension of the array Y. LDY >= N. 

            //  Further Details 
            //  =============== 

            //  The matrix Q is represented as a product of nb elementary reflectors 

            //     Q = H(1) H(2) . . . H(nb). 

            //  Each H(i) has the form 

            //     H(i) = I - tau * v * v' 

            //  where tau is a complex scalar, and v is a complex vector with 
            //  v(1:i+k-1) = 0, v(i+k) = 1; v(i+k+1:n) is stored on exit in 
            //  A(i+k+1:n,i), and tau in TAU(i). 

            //  The elements of the vectors v together form the (n-k+1)-by-nb matrix 
            //  V which is needed, with T and Y, to apply the transformation to the 
            //  unreduced part of the matrix, using an update of the form: 
            //  A := (I - V*T*V') * (A - Y*V'). 

            //  The contents of A on exit are illustrated by the following example 
            //  with n = 7, k = 3 and nb = 2: 

            //     ( a   a   a   a   a ) 
            //     ( a   a   a   a   a ) 
            //     ( a   a   a   a   a ) 
            //     ( h   h   a   a   a ) 
            //     ( v1  h   a   a   a ) 
            //     ( v1  v2  a   a   a ) 
            //     ( v1  v2  a   a   a ) 

            //  where a denotes an element of the original matrix A, h denotes a 
            //  modified element of the upper Hessenberg matrix H, and vi denotes an 
            //  element of the vector defining H(i). 

            //  This file is a slight modification of LAPACK-3.0's ZLAHRD 
            //  incorporating improvements proposed by Quintana-Orti and Van de 
            //  Gejin. Note that the entries of A(1:K,2:NB) differ from those 
            //  returned by the original LAPACK routine. This function is 
            //  not backward compatible with LAPACK3.0. 

            //  ===================================================================== 

            // System generated locals 
            int a_dim1, a_offset, t_dim1, t_offset, y_dim1, y_offset, i__1, i__2, i__3;
            complex16 z__1;

            // Table of constant values
            complex16 c_b1 = new complex16(0.0, 0.0);
            complex16 c_b2 = new complex16(1.0, 0.0);
            int c__1 = 1;

            // Local variables 
            int i;
            complex16 ei = new complex16(0, 0);

            // Parameter adjustments 
            --tau;
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;
            t_dim1 = *ldt;
            t_offset = 1 + t_dim1;
            t -= t_offset;
            y_dim1 = *ldy;
            y_offset = 1 + y_dim1;
            y -= y_offset;

            // Function Body 
            if (*n <= 1)
            {
                return 0;
            }

            i__1 = *nb;
            for (i = 1; i <= i__1; ++i)
            {
                if (i > 1)
                {
                    // Update A(K+1:N,I) 

                    // Update I-th column of A - Y * V' 

                    i__2 = i - 1;
                    zlacgv(&i__2, &a[*k + i - 1 + a_dim1], lda);
                    i__2 = *n - *k;
                    i__3 = i - 1;
                    z__1.r = -1.0;
                    z__1.i = -0.0;

                    zgemv("NO TRANSPOSE", &i__2, &i__3, &z__1, &y[*k + 1 + y_dim1], ldy,
                        &a[*k + i - 1 + a_dim1], lda, &c_b2, &a[*k + 1 + i * a_dim1], &c__1);

                    i__2 = i - 1;
                    zlacgv(&i__2, &a[*k + i - 1 + a_dim1], lda);

                    // Apply I - V * T' * V' to this column (call it b) from the 
                    // left, using the last column of T as workspace 

                    // Let  V = ( V1 )   and   b = ( b1 )   (first I-1 rows) 
                    //          ( V2 )             ( b2 ) 

                    // where V1 is unit lower triangular 

                    // w := V1' * b1 

                    i__2 = i - 1;
                    zcopy(&i__2, &a[*k + 1 + i * a_dim1], &c__1, &t[*nb * t_dim1 + 1], &c__1);
                    i__2 = i - 1;
                    ztrmv("Lower", "Conjugate transpose", "UNIT", &i__2, &a[*k + 1 +
                        a_dim1], lda, &t[*nb * t_dim1 + 1], &c__1);

                    // w := w + V2'*b2 

                    i__2 = *n - *k - i + 1;
                    i__3 = i - 1;
                    zgemv("Conjugate transpose", &i__2, &i__3, &c_b2, &a[*k + i +
                        a_dim1], lda, &a[*k + i + i * a_dim1], &c__1, &c_b2,
                        &t[*nb * t_dim1 + 1], &c__1);

                    // w := T'*w 

                    i__2 = i - 1;
                    ztrmv("Upper", "Conjugate transpose", "NON-UNIT", &i__2, &t[
                        t_offset], ldt, &t[*nb * t_dim1 + 1], &c__1);

                    // b2 := b2 - V2*w 

                    i__2 = *n - *k - i + 1;
                    i__3 = i - 1;
                    z__1.r = -1.0;
                    z__1.i = -0.0;
                    zgemv("NO TRANSPOSE", &i__2, &i__3, &z__1, &a[*k + i + a_dim1],
                         lda, &t[*nb * t_dim1 + 1], &c__1, &c_b2, &a[*k + i + i * a_dim1], &c__1);

                    //  b1 := b1 - V1*w 

                    i__2 = i - 1;
                    ztrmv("Lower", "NO TRANSPOSE", "UNIT", &i__2, &a[*k + 1 + a_dim1], lda, &t[*nb * t_dim1 + 1], &c__1);
                    i__2 = i - 1;
                    z__1.r = -1.0;
                    z__1.i = -0.0;
                    zaxpy(&i__2, &z__1, &t[*nb * t_dim1 + 1], &c__1, &a[*k + 1 + i * a_dim1], &c__1);

                    i__2 = *k + i - 1 + (i - 1) * a_dim1;

                    a[i__2].r = ei.r;
                    a[i__2].i = ei.i;
                }

                // Generate the elementary reflector H(I) to annihilate 
                // A(K+I+1:N,I) 

                i__2 = *n - *k - i + 1;

                // Computing MIN 
                i__3 = *k + i + 1;
                zlarfg(&i__2, &a[*k + i + i * a_dim1], &a[Math.Min(i__3, *n) + i * a_dim1], &c__1, &tau[i]);
                i__2 = *k + i + i * a_dim1;

                ei.r = a[i__2].r;
                ei.i = a[i__2].i;

                i__2 = *k + i + i * a_dim1;

                a[i__2].r = 1.0;
                a[i__2].i = 0.0;

                // Compute  Y(K+1:N,I) 

                i__2 = *n - *k;
                i__3 = *n - *k - i + 1;

                zgemv("NO TRANSPOSE", &i__2, &i__3, &c_b2, &a[*k + 1 + (i + 1) *
                    a_dim1], lda, &a[*k + i + i * a_dim1], &c__1, &c_b1, &y[*k + 1 + i * y_dim1], &c__1);

                i__2 = *n - *k - i + 1;
                i__3 = i - 1;

                zgemv("Conjugate transpose", &i__2, &i__3, &c_b2, &a[*k + i +
                    a_dim1], lda, &a[*k + i + i * a_dim1], &c__1, &c_b1, &t[i * t_dim1 + 1], &c__1);

                i__2 = *n - *k;
                i__3 = i - 1;
                z__1.r = -1.0;
                z__1.i = -0.0;

                zgemv("NO TRANSPOSE", &i__2, &i__3, &z__1, &y[*k + 1 + y_dim1], ldy,
                    &t[i * t_dim1 + 1], &c__1, &c_b2, &y[*k + 1 + i * y_dim1], &c__1);

                i__2 = *n - *k;
                zscal(&i__2, &tau[i], &y[*k + 1 + i * y_dim1], &c__1);

                // Compute T(1:I,I) 

                i__2 = i - 1;
                i__3 = i;

                z__1.r = -tau[i__3].r;
                z__1.i = -tau[i__3].i;

                zscal(&i__2, &z__1, &t[i * t_dim1 + 1], &c__1);
                i__2 = i - 1;
                ztrmv("Upper", "No Transpose", "NON-UNIT", &i__2, &t[t_offset], ldt, &t[i * t_dim1 + 1], &c__1);
                i__2 = i + i * t_dim1;
                i__3 = i;

                t[i__2].r = tau[i__3].r;
                t[i__2].i = tau[i__3].i;
            }

            i__1 = *k + *nb + *nb * a_dim1;

            a[i__1].r = ei.r;
            a[i__1].i = ei.i;

            // Compute Y(1:K,1:NB) 

            zlacpy("ALL", k, nb, &a[(a_dim1 << 1) + 1], lda, &y[y_offset], ldy);
            ztrmm("RIGHT", "Lower", "NO TRANSPOSE", "UNIT", k, nb, &c_b2, &a[*k + 1
                + a_dim1], lda, &y[y_offset], ldy);

            if (*n > *k + *nb)
            {
                i__1 = *n - *k - *nb;

                zgemm("NO TRANSPOSE", "NO TRANSPOSE", k, nb, &i__1, &c_b2, &a[(*nb +
                    2) * a_dim1 + 1], lda, &a[*k + 1 + *nb + a_dim1], lda, &c_b2, &y[y_offset], ldy);
            }

            ztrmm("RIGHT", "Upper", "NO TRANSPOSE", "NON-UNIT", k, nb, &c_b2,
                &t[t_offset], ldt, &y[y_offset], ldy);

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static double zlange(string norm, int* m, int* n, complex16* a, int* lda, double* work)
        {
            //  -- LAPACK auxiliary routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. 
            //     November 2006 

            //  Purpose 
            //  ======= 

            //  ZLANGE  returns the value of the one norm,  or the Frobenius norm, or 
            //  the  infinity norm,  or the  element of  largest absolute value  of a 
            //  complex matrix A. 

            //  Description 
            //  =========== 

            //  ZLANGE returns the value 

            //     ZLANGE = ( max(abs(A(i,j))), NORM = 'M' or 'm' 
            //              ( 
            //              ( norm1(A),         NORM = '1', 'O' or 'o' 
            //              ( 
            //              ( normI(A),         NORM = 'I' or 'i' 
            //              ( 
            //              ( normF(A),         NORM = 'F', 'f', 'E' or 'e' 

            //  where  norm1  denotes the  one norm of a matrix (maximum column sum), 
            //  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and 
            //  normF  denotes the  Frobenius norm of a matrix (square root of sum of 
            //  squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm. 

            //  Arguments 
            //  ========= 

            //  NORM    (input) CHARACTER*1 
            //          Specifies the value to be returned in ZLANGE as described 
            //          above. 

            //  M       (input) int 
            //          The number of rows of the matrix A.  M >= 0.  When M = 0, 
            //          ZLANGE is set to zero. 

            //  N       (input) int 
            //          The number of columns of the matrix A.  N >= 0.  When N = 0, 
            //          ZLANGE is set to zero. 

            //  A       (input) COMPLEX*16 array, dimension (LDA,N) 
            //          The m by n matrix A. 

            //  LDA     (input) int 
            //          The leading dimension of the array A.  LDA >= max(M,1). 

            //  WORK    (workspace) DOUBLE PRECISION array, dimension (MAX(1,LWORK)), 
            //          where LWORK >= M when NORM = 'I'; otherwise, WORK is not 
            //          referenced. 

            // ===================================================================== 

            // System generated locals 
            int a_dim1, a_offset, i__1, i__2;
            double ret_val, d__1, d__2;

            // Table of constant values
            int c__1 = 1;

            // Local variables 
            int i, j;
            double sum, scale;
            double value = 0;

            // Parameter adjustments 
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;
            --work;

            // Function Body 
            if (Math.Min(*m, *n) == 0)
            {
                value = 0.0;
            }
            else if (lsame(norm, "M"))
            {
                // Find max(abs(A(i,j))). 
                value = 0.0;
                i__1 = *n;
                for (j = 1; j <= i__1; ++j)
                {
                    i__2 = *m;
                    for (i = 1; i <= i__2; ++i)
                    {
                        // Computing MAX 
                        d__1 = value;
                        d__2 = z_abs(&a[i + j * a_dim1]);
                        value = Math.Max(d__1, d__2);
                    }
                }
            }
            else if (lsame(norm, "O") || norm[0] == '1')
            {
                // Find norm1(A). 
                value = 0.0;
                i__1 = *n;
                for (j = 1; j <= i__1; ++j)
                {
                    sum = 0.0;
                    i__2 = *m;
                    for (i = 1; i <= i__2; ++i)
                    {
                        sum += z_abs(&a[i + j * a_dim1]);
                    }
                    value = Math.Max(value, sum);
                }
            }
            else if (lsame(norm, "I"))
            {
                // Find normI(A). 
                i__1 = *m;
                for (i = 1; i <= i__1; ++i)
                {
                    work[i] = 0.0;
                }
                i__1 = *n;
                for (j = 1; j <= i__1; ++j)
                {
                    i__2 = *m;
                    for (i = 1; i <= i__2; ++i)
                    {
                        work[i] += z_abs(&a[i + j * a_dim1]);
                    }
                }
                value = 0.0;
                i__1 = *m;
                for (i = 1; i <= i__1; ++i)
                {
                    // Computing MAX 
                    d__1 = value;
                    d__2 = work[i];
                    value = Math.Max(d__1, d__2);
                }
            }
            else if (lsame(norm, "F") || lsame(norm, "E"))
            {
                // Find normF(A). 
                scale = 0.0;
                sum = 1.0;
                i__1 = *n;
                for (j = 1; j <= i__1; ++j)
                {
                    zlassq(m, &a[j * a_dim1 + 1], &c__1, &scale, &sum);
                }
                value = scale * Math.Sqrt(sum);
            }

            ret_val = value;

            return ret_val;
        }

        [SuppressUnmanagedCodeSecurity]
        public static double zlanhs(string norm, int* n, complex16* a, int* lda, double* work)
        {
            //  -- LAPACK auxiliary routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     November 2006

            //  Purpose
            //  =======

            //  ZLANHS  returns the value of the one norm,  or the Frobenius norm, or
            //  the  infinity norm,  or the  element of  largest absolute value  of a
            //  Hessenberg matrix A.

            //  Description
            //  ===========

            //  ZLANHS returns the value

            //     ZLANHS = ( max(abs(A(i,j))), NORM = 'M' or 'm'
            //              (
            //              ( norm1(A),         NORM = '1', 'O' or 'o'
            //              (
            //              ( normI(A),         NORM = 'I' or 'i'
            //              (
            //              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'

            //  where  norm1  denotes the  one norm of a matrix (maximum column sum),
            //  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            //  normF  denotes the  Frobenius norm of a matrix (square root of sum of
            //  squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.

            //  Arguments
            //  =========

            //  NORM    (input) CHARACTER*1
            //          Specifies the value to be returned in ZLANHS as described
            //          above.

            //  N       (input) INTEGER
            //          The order of the matrix A.  N >= 0.0  When N = 0, ZLANHS is
            //          set to zero.

            //  A       (input) COMPLEX*16 array, dimension (LDA,N)
            //          The n by n upper Hessenberg matrix A; the part of A below the
            //          first sub-diagonal is not referenced.

            //  LDA     (input) INTEGER
            //          The leading dimension of the array A.  LDA >= max(N,1).

            //  WORK    (workspace) DOUBLE PRECISION array, dimension (MAX(1,LWORK)),
            //          where LWORK >= N when NORM = 'I'; otherwise, WORK is not
            //          referenced.

            // =====================================================================

            // System generated locals
            int a_dim1, a_offset, i__1, i__2, i__3, i__4;
            double ret_val, d__1, d__2;

            // Table of constant values
            int c__1 = 1;

            // Local variables
            int i, j;
            double sum, scale;
            double value = 0.0;

            // Parameter adjustments
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;
            --work;

            // Function Body
            if (*n == 0)
            {
                value = 0.0;
            }
            else if (lsame(norm, "M"))
            {
                // Find max(abs(A(i,j))).

                value = 0.0;
                i__1 = *n;
                for (j = 1; j <= i__1; ++j)
                {
                    // Computing MIN
                    i__3 = *n;
                    i__4 = j + 1;
                    i__2 = Math.Min(i__3, i__4);
                    for (i = 1; i <= i__2; ++i)
                    {
                        // Computing MAX
                        d__1 = value;
                        d__2 = z_abs(&a[i + j * a_dim1]);
                        value = Math.Max(d__1, d__2);
                    }
                }
            }
            else if (lsame(norm, "O") || norm[0] == '1')
            {
                // Find norm1(A).

                value = 0.0;
                i__1 = *n;
                for (j = 1; j <= i__1; ++j)
                {
                    sum = 0.0;
                    // Computing MIN
                    i__3 = *n;
                    i__4 = j + 1;
                    i__2 = Math.Min(i__3, i__4);
                    for (i = 1; i <= i__2; ++i)
                    {
                        sum += z_abs(&a[i + j * a_dim1]);
                    }
                    value = Math.Max(value, sum);
                }
            }
            else if (lsame(norm, "I"))
            {
                // Find normI(A).

                i__1 = *n;
                for (i = 1; i <= i__1; ++i)
                {
                    work[i] = 0.0;
                }
                i__1 = *n;
                for (j = 1; j <= i__1; ++j)
                {
                    // Computing MIN
                    i__3 = *n;
                    i__4 = j + 1;
                    i__2 = Math.Min(i__3, i__4);
                    for (i = 1; i <= i__2; ++i)
                    {
                        work[i] += z_abs(&a[i + j * a_dim1]);
                    }
                }
                value = 0.0;
                i__1 = *n;
                for (i = 1; i <= i__1; ++i)
                {
                    // Computing MAX
                    d__1 = value;
                    d__2 = work[i];
                    value = Math.Max(d__1, d__2);
                }
            }
            else if (lsame(norm, "F") || lsame(norm, "E"))
            {
                // Find normF(A).

                scale = 0.0;
                sum = 1.0;
                i__1 = *n;
                for (j = 1; j <= i__1; ++j)
                {
                    // Computing MIN
                    i__3 = *n;
                    i__4 = j + 1;
                    i__2 = Math.Min(i__3, i__4);
                    zlassq(&i__2, &a[j * a_dim1 + 1], &c__1, &scale, &sum);
                }
                value = scale * Math.Sqrt(sum);
            }

            ret_val = value;
            return ret_val;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zlaqr0(bool* wantt, bool* wantz, int* n,
            int* ilo, int* ihi, complex16* h, int* ldh,
            complex16* w, int* iloz, int* ihiz, complex16* z,
            int* ldz, complex16* work, int* lwork, int* info)
        {
            //  -- LAPACK auxiliary routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd.. 
            //     November 2006 

            //     Purpose 
            //     ======= 

            //     ZLAQR0 computes the eigenvalues of a Hessenberg matrix H 
            //     and, optionally, the matrices T and Z from the Schur decomposition 
            //     H = Z T Z**H, where T is an upper triangular matrix (the 
            //     Schur form), and Z is the unitary matrix of Schur vectors. 

            //     Optionally Z may be postmultiplied into an input unitary 
            //     matrix Q so that this routine can give the Schur factorization 
            //     of a matrix A which has been reduced to the Hessenberg form H 
            //     by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*H*(QZ)**H. 

            //     Arguments 
            //     ========= 

            //     WANTT   (input) bool 
            //          = .TRUE. : the full Schur form T is required; 
            //          = .FALSE.: only eigenvalues are required. 

            //     WANTZ   (input) bool 
            //          = .TRUE. : the matrix of Schur vectors Z is required; 
            //          = .FALSE.: Schur vectors are not required. 

            //     N     (input) int 
            //           The order of the matrix H.  N .GE. 0. 

            //     ILO   (input) int 
            //     IHI   (input) int 
            //           It is assumed that H is already upper triangular in rows 
            //           and columns 1:ILO-1 and IHI+1:N and, if ILO.GT.1, 
            //           H(ILO,ILO-1) is zero. ILO and IHI are normally set by a 
            //           previous call to ZGEBAL, and then passed to ZGEHRD when the 
            //           matrix output by ZGEBAL is reduced to Hessenberg form. 
            //           Otherwise, ILO and IHI should be set to 1 and N, 
            //           respectively.  If N.GT.0, then 1.LE.ILO.LE.IHI.LE.N. 
            //           If N = 0, then ILO = 1 and IHI = 0. 

            //     H     (input/output) COMPLEX*16 array, dimension (LDH,N) 
            //           On entry, the upper Hessenberg matrix H. 
            //           On exit, if INFO = 0 and WANTT is .TRUE., then H 
            //           contains the upper triangular matrix T from the Schur 
            //           decomposition (the Schur form). If INFO = 0 and WANT is 
            //           .FALSE., then the contents of H are unspecified on exit. 
            //           (The output value of H when INFO.GT.0 is given under the 
            //           description of INFO below.) 

            //           This subroutine may explicitly set H(i,j) = 0 for i.GT.j and 
            //           j = 1, 2, ... ILO-1 or j = IHI+1, IHI+2, ... N. 

            //     LDH   (input) int 
            //           The leading dimension of the array H. LDH .GE. max(1,N). 

            //     W        (output) COMPLEX*16 array, dimension (N) 
            //           The computed eigenvalues of H(ILO:IHI,ILO:IHI) are stored 
            //           in W(ILO:IHI). If WANTT is .TRUE., then the eigenvalues are 
            //           stored in the same order as on the diagonal of the Schur 
            //           form returned in H, with W(i) = H(i,i). 

            //     Z     (input/output) COMPLEX*16 array, dimension (LDZ,IHI) 
            //           If WANTZ is .FALSE., then Z is not referenced. 
            //           If WANTZ is .TRUE., then Z(ILO:IHI,ILOZ:IHIZ) is 
            //           replaced by Z(ILO:IHI,ILOZ:IHIZ)*U where U is the 
            //           orthogonal Schur factor of H(ILO:IHI,ILO:IHI). 
            //           (The output value of Z when INFO.GT.0 is given under 
            //           the description of INFO below.) 

            //     LDZ   (input) int 
            //           The leading dimension of the array Z.  if WANTZ is .TRUE. 
            //           then LDZ.GE.MAX(1,IHIZ).  Otherwize, LDZ.GE.1. 

            //     WORK  (workspace/output) COMPLEX*16 array, dimension LWORK 
            //           On exit, if LWORK = -1, WORK(1) returns an estimate of 
            //           the optimal value for LWORK. 

            //     LWORK (input) int 
            //           The dimension of the array WORK.  LWORK .GE. max(1,N) 
            //           is sufficient, but LWORK typically as large as 6*N may 
            //           be required for optimal performance.  A workspace query 
            //           to determine the optimal workspace size is recommended. 

            //           If LWORK = -1, then ZLAQR0 does a workspace query. 
            //           In this case, ZLAQR0 checks the input parameters and 
            //           estimates the optimal workspace size for the given 
            //           values of N, ILO and IHI.  The estimate is returned 
            //           in WORK(1).  No error message related to LWORK is 
            //           issued by XERBLA.  Neither H nor Z are accessed. 


            //     INFO  (output) int 
            //             =  0:  successful exit 
            //           .GT. 0:  if INFO = i, ZLAQR0 failed to compute all of 
            //                the eigenvalues.  Elements 1:ilo-1 and i+1:n of WR 
            //                and WI contain those eigenvalues which have been 
            //                successfully computed.  (Failures are rare.) 

            //                If INFO .GT. 0 and WANT is .FALSE., then on exit, 
            //                the remaining unconverged eigenvalues are the eigen- 
            //                values of the upper Hessenberg matrix rows and 
            //                columns ILO through INFO of the final, output 
            //                value of H. 

            //                If INFO .GT. 0 and WANTT is .TRUE., then on exit 

            //           (*)  (initial value of H)*U  = U*(final value of H) 

            //                where U is a unitary matrix.  The final 
            //                value of  H is upper Hessenberg and triangular in 
            //                rows and columns INFO+1 through IHI. 

            //                If INFO .GT. 0 and WANTZ is .TRUE., then on exit 

            //                  (final value of Z(ILO:IHI,ILOZ:IHIZ) 
            //                   =  (initial value of Z(ILO:IHI,ILOZ:IHIZ)*U 

            //                where U is the unitary matrix in (*) (regard- 
            //                less of the value of WANTT.) 

            //                If INFO .GT. 0 and WANTZ is .FALSE., then Z is not 
            //                accessed. 

            //     ================================================================ 
            //     Based on contributions by 
            //        Karen Braman and Ralph Byers, Department of Mathematics, 
            //        University of Kansas, USA 

            //     ================================================================ 
            //     References: 
            //       K. Braman, R. Byers and R. Mathias, The Multi-Shift QR 
            //       Algorithm Part I: Maintaining Well Focused Shifts, and Level 3 
            //       Performance, SIAM Journal of Matrix Analysis, volume 23, pages 
            //       929--947, 2002. 

            //       K. Braman, R. Byers and R. Mathias, The Multi-Shift QR 
            //       Algorithm Part II: Aggressive Early Deflation, SIAM Journal 
            //       of Matrix Analysis, volume 23, pages 948--973, 2002. 

            //     ================================================================ 
            //     .. Parameters .. 

            //     ==== Matrices of order NTINY or smaller must be processed by 
            //     .    ZLAHQR because of insufficient subdiagonal scratch space. 
            //     .    (This is a hard limit.) ==== 

            //     ==== Exceptional deflation windows:  try to cure rare 
            //     .    slow convergence by varying the size of the 
            //     .    deflation window after KEXNW iterations. ==== 

            //     ==== Exceptional shifts: try to cure rare slow convergence 
            //     .    with ad-hoc exceptional shifts every KEXSH iterations. 
            //     .    ==== 

            //     ==== The constant WILK1 is used to form the exceptional 
            //     .    shifts. ==== 

            // System generated locals 
            int h_dim1, h_offset, z_dim1, z_offset, i__1, i__2, i__3, i__4, i__5;
            double d__1, d__3;
            complex16 z__1, z__2, z__3, z__4, z__5;

            // Table of constant values
            int c__13 = 13;
            int c__15 = 15;
            int c_n1 = -1;
            int c__12 = 12;
            int c__14 = 14;
            int c__16 = 16;
            bool c_false = false;
            int c__1 = 1;
            int c__3 = 3;

            // Local variables 
            int i, k;
            double s;
            complex16 aa, bb, cc, dd;
            int ld, nh, it, ks, kt, ku, kv, ls, ns, nw;
            complex16 tr2, det;
            int inf, kdu, nho, nve, kwh, nsr, nwr, kwv, ndec = 0, ndfl, kbot, nmin;
            complex16 swap;
            int ktop;
            complex16[] zdum = new complex16[1]; // was [1][1] 
            int kacc22, itmax, nsmax, nwmax, kwtop;
            int nibble;
            string jbcmpz;
            complex16 rtdisc;
            int nwupbd;
            bool sorted;
            int lwkopt;

            // Parameter adjustments 
            h_dim1 = *ldh;
            h_offset = 1 + h_dim1;
            h -= h_offset;
            --w;
            z_dim1 = *ldz;
            z_offset = 1 + z_dim1;
            z -= z_offset;
            --work;

            // Function Body 
            *info = 0;

            // ==== Quick return for N = 0: nothing to do. ==== 

            if (*n == 0)
            {
                work[1].r = 1.0;
                work[1].i = 0.0;
                return 0;
            }

            if (*n <= 11)
            {
                // ==== Tiny matrices must use ZLAHQR. ==== 

                lwkopt = 1;
                if (*lwork != -1)
                {
                    zlahqr(wantt, wantz, n, ilo, ihi, &h[h_offset], ldh, &w[1],
                        iloz, ihiz, &z[z_offset], ldz, info);
                }
            }
            else
            {
                // ==== Use small bulge multi-shift QR with aggressive early 
                // .    deflation on larger-than-tiny matrices. ==== 

                // ==== Hope for the best. ==== 

                *info = 0;

                // ==== Set up job flags for ILAENV. ==== 

                if (*wantt)
                {
                    jbcmpz = "S";
                }
                else
                {
                    jbcmpz = "E";
                }
                if (*wantz)
                {
                    jbcmpz += 'V';
                }
                else
                {
                    jbcmpz += 'N';
                }

                // ==== NWR = recommended deflation window size.  At this 
                // .    point,  N .GT. NTINY = 11, so there is enough 
                // .    subdiagonal workspace for NWR.GE.2 as required. 
                // .    (In fact, there is enough subdiagonal space for 
                // .    NWR.GE.3.) ==== 

                nwr = ilaenv(&c__13, "ZLAQR0", jbcmpz, n, ilo, ihi, lwork);
                nwr = Math.Max(2, nwr);
                // Computing MIN 
                i__1 = *ihi - *ilo + 1;
                i__2 = (*n - 1) / 3;
                i__1 = Math.Min(i__1, i__2);
                nwr = Math.Min(i__1, nwr);

                // ==== NSR = recommended number of simultaneous shifts. 
                // .    At this point N .GT. NTINY = 11, so there is at 
                // .    enough subdiagonal workspace for NSR to be even 
                // .    and greater than or equal to two as required. ==== 

                nsr = ilaenv(&c__15, "ZLAQR0", jbcmpz, n, ilo, ihi, lwork);

                // Computing MIN 
                i__1 = nsr;
                i__2 = (*n + 6) / 9;
                i__1 = Math.Min(i__1, i__2);
                i__2 = *ihi - *ilo;
                nsr = Math.Min(i__1, i__2);
                // Computing MAX 
                i__1 = 2;
                i__2 = nsr - nsr % 2;
                nsr = Math.Max(i__1, i__2);

                // ==== Estimate optimal workspace ==== 

                // ==== Workspace query call to ZLAQR3 ==== 

                i__1 = nwr + 1;
                zlaqr3(wantt, wantz, n, ilo, ihi, &i__1, &h[h_offset], ldh, iloz,
                    ihiz, &z[z_offset], ldz, &ls, &ld, &w[1], &h[h_offset],
                    ldh, n, &h[h_offset], ldh, n, &h[h_offset], ldh, &work[1], &c_n1);

                // ==== Optimal workspace = MAX(ZLAQR5, ZLAQR3) ==== 

                // Computing MAX 
                i__1 = nsr * 3 / 2;
                i__2 = (int)work[1].r;
                lwkopt = Math.Max(i__1, i__2);

                // ==== Quick return in case of workspace query. ==== 

                if (*lwork == -1)
                {
                    d__1 = (double)lwkopt;
                    z__1.r = d__1;
                    z__1.i = 0.0;
                    work[1].r = z__1.r;
                    work[1].i = z__1.i;
                    return 0;
                }

                // ==== ZLAHQR/ZLAQR0 crossover point ==== 

                nmin = ilaenv(&c__12, "ZLAQR0", jbcmpz, n, ilo, ihi, lwork);
                nmin = Math.Max(11, nmin);

                // ==== Nibble crossover point ==== 

                nibble = ilaenv(&c__14, "ZLAQR0", jbcmpz, n, ilo, ihi, lwork);
                nibble = Math.Max(0, nibble);

                // ==== Accumulate reflections during ttswp?  Use block 
                // .    2-by-2 structure during matrix-matrix multiply? ==== 

                kacc22 = ilaenv(&c__16, "ZLAQR0", jbcmpz, n, ilo, ihi, lwork);
                kacc22 = Math.Max(0, kacc22);
                kacc22 = Math.Min(2, kacc22);

                // ==== NWMAX = the largest possible deflation window for 
                // .    which there is sufficient workspace. ==== 

                // Computing MIN 
                i__1 = (*n - 1) / 3;
                i__2 = *lwork / 2;
                nwmax = Math.Min(i__1, i__2);
                nw = nwmax;

                // ==== NSMAX = the Largest number of simultaneous shifts 
                // .    for which there is sufficient workspace. ==== 

                // Computing MIN 
                i__1 = (*n + 6) / 9;
                i__2 = (*lwork << 1) / 3;
                nsmax = Math.Min(i__1, i__2);
                nsmax -= nsmax % 2;

                // ==== NDFL: an iteration count restarted at deflation. ==== 

                ndfl = 1;

                // ==== ITMAX = iteration limit ==== 

                // Computing MAX 
                i__1 = 10;
                i__2 = *ihi - *ilo + 1;
                itmax = Math.Max(i__1, i__2) * 30;

                // ==== Last row and column in the active block ==== 

                kbot = *ihi;

                // ==== Main Loop ==== 

                i__1 = itmax;
                for (it = 1; it <= i__1; ++it)
                {
                    // ==== Done when KBOT falls below ILO ==== 

                    if (kbot < *ilo)
                    {
                        goto L80;
                    }

                    // ==== Locate active block ==== 

                    i__2 = *ilo + 1;
                    for (k = kbot; k >= i__2; --k)
                    {
                        i__3 = k + (k - 1) * h_dim1;
                        if (h[i__3].r == 0.0 && h[i__3].i == 0.0)
                        {
                            goto L20;
                        }
                    }
                    k = *ilo;
                L20:
                    ktop = k;

                    // ==== Select deflation window size: 
                    // .    Typical Case: 
                    // .      If possible and advisable, nibble the entire 
                    // .      active block.  If not, use size MIN(NWR,NWMAX) 
                    // .      or MIN(NWR+1,NWMAX) depending upon which has 
                    // .      the smaller corresponding subdiagonal entry 
                    // .      (a heuristic). 
                    // . 
                    // .    Exceptional Case: 
                    // .      If there have been no deflations in KEXNW or 
                    // .      more iterations, then vary the deflation window 
                    // .      size.   At first, because, larger windows are, 
                    // .      in general, more powerful than smaller ones, 
                    // .      rapidly increase the window to the maximum possible. 
                    // .      Then, gradually reduce the window size. ==== 

                    nh = kbot - ktop + 1;
                    nwupbd = Math.Min(nh, nwmax);
                    if (ndfl < 5)
                    {
                        nw = Math.Min(nwupbd, nwr);
                    }
                    else
                    {
                        // Computing MIN 
                        i__2 = nwupbd;
                        i__3 = nw << 1;
                        nw = Math.Min(i__2, i__3);
                    }
                    if (nw < nwmax)
                    {
                        if (nw >= nh - 1)
                        {
                            nw = nh;
                        }
                        else
                        {
                            kwtop = kbot - nw + 1;
                            i__2 = kwtop + (kwtop - 1) * h_dim1;
                            i__3 = kwtop - 1 + (kwtop - 2) * h_dim1;
                            if (Math.Abs(h[i__2].r) + Math.Abs(d_imag(&h[kwtop + (kwtop - 1) * h_dim1])) > Math.Abs(h[i__3].r) +
                                Math.Abs(d_imag(&h[kwtop - 1 + (kwtop - 2) * h_dim1])))
                            {
                                ++nw;
                            }
                        }
                    }
                    if (ndfl < 5)
                    {
                        ndec = -1;
                    }
                    else if (ndec >= 0 || nw >= nwupbd)
                    {
                        ++ndec;
                        if (nw - ndec < 2)
                        {
                            ndec = 0;
                        }
                        nw -= ndec;
                    }

                    // ==== Aggressive early deflation: 
                    // .    split workspace under the subdiagonal into 
                    // .      - an nw-by-nw work array V in the lower 
                    // .        left-hand-corner, 
                    // .      - an NW-by-at-least-NW-but-more-is-better 
                    // .        (NW-by-NHO) horizontal work array aint 
                    // .        the bottom edge, 
                    // .      - an at-least-NW-but-more-is-better (NHV-by-NW) 
                    // .        vertical work array aint the left-hand-edge. 
                    // .        ==== 

                    kv = *n - nw + 1;
                    kt = nw + 1;
                    nho = *n - nw - 1 - kt + 1;
                    kwv = nw + 2;
                    nve = *n - nw - kwv + 1;

                    // ==== Aggressive early deflation ==== 

                    zlaqr3(wantt, wantz, n, &ktop, &kbot, &nw, &h[h_offset], ldh,
                        iloz, ihiz, &z[z_offset], ldz, &ls, &ld, &w[1], &h[kv
                        + h_dim1], ldh, &nho, &h[kv + kt * h_dim1], ldh, &nve, &
                        h[kwv + h_dim1], ldh, &work[1], lwork);

                    // ==== Adjust KBOT accounting for new deflations. ==== 

                    kbot -= ld;

                    // ==== KS points to the shifts. ==== 

                    ks = kbot - ls + 1;

                    // ==== Skip an expensive QR sweep if there is a (partly 
                    // .    heuristic) reason to expect that many eigenvalues 
                    // .    will deflate without it.  Here, the QR sweep is 
                    // .    skipped if many eigenvalues have just been deflated 
                    // .    or if the remaining active block is small. 

                    if (ld == 0 || ld * 100 <= nw * nibble && kbot - ktop + 1 > Math.Min(nmin, nwmax))
                    {
                        // ==== NS = nominal number of simultaneous shifts. 
                        // .    This may be lowered (slightly) if ZLAQR3 
                        // .    did not provide that many shifts. ==== 

                        // Computing MIN 
                        // Computing MAX 
                        i__4 = 2;
                        i__5 = kbot - ktop;
                        i__2 = Math.Min(nsmax, nsr);
                        i__3 = Math.Max(i__4, i__5);
                        ns = Math.Min(i__2, i__3);
                        ns -= ns % 2;

                        // ==== If there have been no deflations 
                        // .    in a multiple of KEXSH iterations, 
                        // .    then try exceptional shifts. 
                        // .    Otherwise use shifts provided by 
                        // .    ZLAQR3 above or from the eigenvalues 
                        // .    of a trailing principal submatrix. ==== 

                        if (ndfl % 6 == 0)
                        {
                            ks = kbot - ns + 1;
                            i__2 = ks + 1;
                            for (i = kbot; i >= i__2; i += -2)
                            {
                                i__3 = i;
                                i__4 = i + i * h_dim1;
                                i__5 = i + (i - 1) * h_dim1;

                                d__3 = (Math.Abs(h[i__5].r) + Math.Abs(d_imag(&h[i + (i - 1) * h_dim1]))) * 0.75;

                                z__1.r = h[i__4].r + d__3;
                                z__1.i = h[i__4].i;

                                w[i__3].r = z__1.r;
                                w[i__3].i = z__1.i;

                                i__3 = i - 1;
                                i__4 = i;
                                w[i__3].r = w[i__4].r;
                                w[i__3].i = w[i__4].i;
                            }
                        }
                        else
                        {
                            // ==== Got NS/2 or fewer shifts? Use ZLAQR4 or 
                            // .    ZLAHQR on a trailing principal submatrix to 
                            // .    get more. (Since NS.LE.NSMAX.LE.(N+6)/9, 
                            // .    there is enough space below the subdiagonal 
                            // .    to fit an NS-by-NS scratch array.) ==== 

                            if (kbot - ks + 1 <= ns / 2)
                            {
                                ks = kbot - ns + 1;
                                kt = *n - ns + 1;
                                zlacpy("A", &ns, &ns, &h[ks + ks * h_dim1], ldh, &h[kt + h_dim1], ldh);
                                if (ns > nmin)
                                {
                                    zlaqr4(&c_false, &c_false, &ns, &c__1, &ns, &h[kt + h_dim1], ldh, &w[ks], &c__1, &c__1,
                                        zdum, &c__1, &work[1], lwork, &inf);
                                }
                                else
                                {
                                    zlahqr(&c_false, &c_false, &ns, &c__1, &ns, &h[kt + h_dim1], ldh, &w[ks], &c__1, &c__1,
                                        zdum, &c__1, &inf);
                                }
                                ks += inf;

                                // ==== In case of a rare QR failure use 
                                // .    eigenvalues of the trailing 2-by-2 
                                // .    principal submatrix.  Scale to avoid 
                                // .    overflows, underflows and subnormals. 
                                // .    (The scale factor S can not be zero, 
                                // .    because H(KBOT,KBOT-1) is nonzero.) ==== 

                                if (ks >= kbot)
                                {
                                    i__2 = kbot - 1 + (kbot - 1) * h_dim1;
                                    i__3 = kbot + (kbot - 1) * h_dim1;
                                    i__4 = kbot - 1 + kbot * h_dim1;
                                    i__5 = kbot + kbot * h_dim1;

                                    s = Math.Abs(h[i__2].r) + Math.Abs(d_imag(&h[kbot - 1 + (kbot - 1) * h_dim1])) +
                                        (Math.Abs(h[i__3].r) + Math.Abs(d_imag(&h[kbot + (kbot - 1) * h_dim1]))) +
                                        (Math.Abs(h[i__4].r) + Math.Abs(d_imag(&h[kbot - 1 + kbot * h_dim1]))) +
                                        (Math.Abs(h[i__5].r) + Math.Abs(d_imag(&h[kbot + kbot * h_dim1])));

                                    i__2 = kbot - 1 + (kbot - 1) * h_dim1;

                                    z__1.r = h[i__2].r / s;
                                    z__1.i = h[i__2].i / s;

                                    aa.r = z__1.r;
                                    aa.i = z__1.i;

                                    i__2 = kbot + (kbot - 1) * h_dim1;

                                    z__1.r = h[i__2].r / s;
                                    z__1.i = h[i__2].i / s;

                                    cc.r = z__1.r;
                                    cc.i = z__1.i;

                                    i__2 = kbot - 1 + kbot * h_dim1;

                                    z__1.r = h[i__2].r / s;
                                    z__1.i = h[i__2].i / s;

                                    bb.r = z__1.r;
                                    bb.i = z__1.i;

                                    i__2 = kbot + kbot * h_dim1;

                                    z__1.r = h[i__2].r / s;
                                    z__1.i = h[i__2].i / s;

                                    dd.r = z__1.r;
                                    dd.i = z__1.i;

                                    z__2.r = aa.r + dd.r;
                                    z__2.i = aa.i + dd.i;

                                    z__1.r = z__2.r / 2.0;
                                    z__1.i = z__2.i / 2.0;

                                    tr2.r = z__1.r;
                                    tr2.i = z__1.i;

                                    z__3.r = aa.r - tr2.r;
                                    z__3.i = aa.i - tr2.i;

                                    z__4.r = dd.r - tr2.r;
                                    z__4.i = dd.i - tr2.i;

                                    z__2.r = z__3.r * z__4.r - z__3.i * z__4.i;
                                    z__2.i = z__3.r * z__4.i + z__3.i * z__4.r;

                                    z__5.r = bb.r * cc.r - bb.i * cc.i;
                                    z__5.i = bb.r * cc.i + bb.i * cc.r;

                                    z__1.r = z__2.r - z__5.r;
                                    z__1.i = z__2.i - z__5.i;

                                    det.r = z__1.r;
                                    det.i = z__1.i;

                                    z__2.r = -det.r;
                                    z__2.i = -det.i;

                                    z_sqrt(&z__1, &z__2);

                                    rtdisc.r = z__1.r;
                                    rtdisc.i = z__1.i;

                                    i__2 = kbot - 1;

                                    z__2.r = tr2.r + rtdisc.r;
                                    z__2.i = tr2.i + rtdisc.i;

                                    z__1.r = s * z__2.r;
                                    z__1.i = s * z__2.i;

                                    w[i__2].r = z__1.r;
                                    w[i__2].i = z__1.i;

                                    i__2 = kbot;
                                    z__2.r = tr2.r - rtdisc.r;
                                    z__2.i = tr2.i - rtdisc.i;

                                    z__1.r = s * z__2.r;
                                    z__1.i = s * z__2.i;

                                    w[i__2].r = z__1.r;
                                    w[i__2].i = z__1.i;

                                    ks = kbot - 1;
                                }
                            }

                            if (kbot - ks + 1 > ns)
                            {
                                // ==== Sort the shifts (Helps a little) ==== 

                                sorted = false;
                                i__2 = ks + 1;
                                for (k = kbot; k >= i__2; --k)
                                {
                                    if (sorted)
                                    {
                                        goto L60;
                                    }
                                    sorted = true;
                                    i__3 = k - 1;

                                    for (i = ks; i <= i__3; ++i)
                                    {
                                        i__4 = i;
                                        i__5 = i + 1;
                                        if (Math.Abs(w[i__4].r) + Math.Abs(d_imag(&w[i])) < Math.Abs(w[i__5].r) + Math.Abs(d_imag(&w[i + 1])))
                                        {
                                            sorted = false;
                                            i__4 = i;

                                            swap.r = w[i__4].r;
                                            swap.i = w[i__4].i;

                                            i__4 = i;
                                            i__5 = i + 1;

                                            w[i__4].r = w[i__5].r;
                                            w[i__4].i = w[i__5].i;

                                            i__4 = i + 1;

                                            w[i__4].r = swap.r;
                                            w[i__4].i = swap.i;
                                        }
                                    }
                                }
                            L60:
                                ;
                            }
                        }

                        // ==== If there are only two shifts, then use 
                        // .    only one.  ==== 

                        if (kbot - ks + 1 == 2)
                        {
                            i__2 = kbot;
                            i__3 = kbot + kbot * h_dim1;

                            z__2.r = w[i__2].r - h[i__3].r;
                            z__2.i = w[i__2].i - h[i__3].i;

                            z__1.r = z__2.r;
                            z__1.i = z__2.i;

                            i__4 = kbot - 1;
                            i__5 = kbot + kbot * h_dim1;
                            z__4.r = w[i__4].r - h[i__5].r;
                            z__4.i = w[i__4].i - h[i__5].i;

                            z__3.r = z__4.r;
                            z__3.i = z__4.i;

                            if (Math.Abs(z__1.r) + Math.Abs(d_imag(&z__1)) < Math.Abs(z__3.r) + Math.Abs(d_imag(&z__3)))
                            {
                                i__2 = kbot - 1;
                                i__3 = kbot;

                                w[i__2].r = w[i__3].r;
                                w[i__2].i = w[i__3].i;
                            }
                            else
                            {
                                i__2 = kbot;
                                i__3 = kbot - 1;
                                w[i__2].r = w[i__3].r;
                                w[i__2].i = w[i__3].i;
                            }
                        }

                        // ==== Use up to NS of the the smallest magnatiude 
                        // .    shifts.  If there aren't NS shifts available, 
                        // .    then use them all, possibly dropping one to 
                        // .    make the number of shifts even. ==== 

                        // Computing MIN 
                        i__2 = ns;
                        i__3 = kbot - ks + 1;
                        ns = Math.Min(i__2, i__3);
                        ns -= ns % 2;
                        ks = kbot - ns + 1;

                        // ==== Small-bulge multi-shift QR sweep: 
                        // .    split workspace under the subdiagonal into 
                        // .    - a KDU-by-KDU work array U in the lower 
                        // .      left-hand-corner, 
                        // .    - a KDU-by-at-least-KDU-but-more-is-better 
                        // .      (KDU-by-NHo) horizontal work array WH aint 
                        // .      the bottom edge, 
                        // .    - and an at-least-KDU-but-more-is-better-by-KDU 
                        // .      (NVE-by-KDU) vertical work WV arrow aint 
                        // .      the left-hand-edge. ==== 

                        kdu = ns * 3 - 3;
                        ku = *n - kdu + 1;
                        kwh = kdu + 1;
                        nho = *n - kdu - 3 - (kdu + 1) + 1;
                        kwv = kdu + 4;
                        nve = *n - kdu - kwv + 1;

                        // ==== Small-bulge multi-shift QR sweep ==== 

                        zlaqr5(wantt, wantz, &kacc22, n, &ktop, &kbot, &ns, &w[ks],
                            &h[h_offset], ldh, iloz, ihiz, &z[z_offset], ldz,
                            &work[1], &c__3, &h[ku + h_dim1], ldh, &nve, &h[kwv + h_dim1],
                            ldh, &nho, &h[ku + kwh * h_dim1], ldh);
                    }

                    // ==== Note progress (or the lack of it). ==== 

                    if (ld > 0)
                    {
                        ndfl = 1;
                    }
                    else
                    {
                        ++ndfl;
                    }

                    // ==== End of main loop ==== 
                }

                // ==== Iteration limit exceeded.  Set INFO to show where 
                // .    the problem occurred and exit. ==== 

                *info = kbot;
            L80:
                ;
            }

            // ==== Return the optimal value of LWORK. ==== 

            d__1 = (double)lwkopt;

            z__1.r = d__1;
            z__1.i = 0.0;

            work[1].r = z__1.r;
            work[1].i = z__1.i;

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zlaqr1(int* n, complex16* h, int* ldh, complex16* s1, complex16* s2, complex16* v)
        {
            //  -- LAPACK auxiliary routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd.. 
            //     November 2006 

            //       Given a 2-by-2 or 3-by-3 matrix H, ZLAQR1 sets v to a 
            //       scalar multiple of the first column of the product 

            //       (*)  K = (H - s1*I)*(H - s2*I) 

            //       scaling to avoid overflows and most underflows. 

            //       This is useful for starting double implicit shift bulges 
            //       in the QR algorithm. 


            //       N      (input) int 
            //              Order of the matrix H. N must be either 2 or 3. 

            //       H      (input) COMPLEX*16 array of dimension (LDH,N) 
            //              The 2-by-2 or 3-by-3 matrix H in (*). 

            //       LDH    (input) int 
            //              The leading dimension of H as declared in 
            //              the calling procedure.  LDH.GE.N 

            //       S1     (input) COMPLEX*16 
            //       S2     S1 and S2 are the shifts defining K in (*) above. 

            //       V      (output) COMPLEX*16 array of dimension N 
            //              A scalar multiple of the first column of the 
            //              matrix K in (*). 

            //     ================================================================ 
            //     Based on contributions by 
            //        Karen Braman and Ralph Byers, Department of Mathematics, 
            //        University of Kansas, USA 

            //     ================================================================ 

            // System generated locals 
            int h_dim1, h_offset, i__1, i__2, i__3, i__4;
            complex16 z__1, z__2, z__3, z__4, z__5, z__6, z__7, z__8;

            // Local variables 
            double s;
            complex16 h21s, h31s;

            // Parameter adjustments 
            h_dim1 = *ldh;
            h_offset = 1 + h_dim1;
            h -= h_offset;
            --v;

            // Function Body 
            if (*n == 2)
            {
                i__1 = h_dim1 + 1;

                z__2.r = h[i__1].r - s2.r;
                z__2.i = h[i__1].i - s2.i;

                z__1.r = z__2.r;
                z__1.i = z__2.i;

                i__2 = h_dim1 + 2;

                s = Math.Abs(z__1.r) + Math.Abs(d_imag(&z__1)) + (Math.Abs(h[i__2].r) + Math.Abs(d_imag(&h[h_dim1 + 2])));

                if (s == 0.0)
                {
                    v[1].r = 0.0;
                    v[1].i = 0.0;

                    v[2].r = 0.0;
                    v[2].i = 0.0;
                }
                else
                {
                    i__1 = h_dim1 + 2;

                    z__1.r = h[i__1].r / s;
                    z__1.i = h[i__1].i / s;

                    h21s.r = z__1.r;
                    h21s.i = z__1.i;

                    i__1 = (h_dim1 << 1) + 1;

                    z__2.r = h21s.r * h[i__1].r - h21s.i * h[i__1].i;
                    z__2.i = h21s.r * h[i__1].i + h21s.i * h[i__1].r;

                    i__2 = h_dim1 + 1;

                    z__4.r = h[i__2].r - s1.r;
                    z__4.i = h[i__2].i - s1.i;

                    i__3 = h_dim1 + 1;

                    z__6.r = h[i__3].r - s2.r;
                    z__6.i = h[i__3].i - s2.i;

                    z__5.r = z__6.r / s;
                    z__5.i = z__6.i / s;

                    z__3.r = z__4.r * z__5.r - z__4.i * z__5.i;
                    z__3.i = z__4.r * z__5.i + z__4.i * z__5.r;

                    z__1.r = z__2.r + z__3.r;
                    z__1.i = z__2.i + z__3.i;

                    v[1].r = z__1.r;
                    v[1].i = z__1.i;

                    i__1 = h_dim1 + 1;
                    i__2 = (h_dim1 << 1) + 2;

                    z__4.r = h[i__1].r + h[i__2].r;
                    z__4.i = h[i__1].i + h[i__2].i;

                    z__3.r = z__4.r - s1.r;
                    z__3.i = z__4.i - s1.i;

                    z__2.r = z__3.r - s2.r;
                    z__2.i = z__3.i - s2.i;

                    z__1.r = h21s.r * z__2.r - h21s.i * z__2.i;
                    z__1.i = h21s.r * z__2.i + h21s.i * z__2.r;

                    v[2].r = z__1.r;
                    v[2].i = z__1.i;
                }
            }
            else
            {
                i__1 = h_dim1 + 1;

                z__2.r = h[i__1].r - s2.r;
                z__2.i = h[i__1].i - s2.i;

                z__1.r = z__2.r;
                z__1.i = z__2.i;

                i__2 = h_dim1 + 2;
                i__3 = h_dim1 + 3;

                s = Math.Abs(z__1.r) + Math.Abs(d_imag(&z__1)) + (Math.Abs(h[i__2].r) +
                    Math.Abs(d_imag(&h[h_dim1 + 2]))) + (Math.Abs(h[i__3].r) + Math.Abs(d_imag(&h[h_dim1 + 3])));

                if (s == 0.0)
                {
                    v[1].r = 0.0;
                    v[1].i = 0.0;

                    v[2].r = 0.0;
                    v[2].i = 0.0;

                    v[3].r = 0.0;
                    v[3].i = 0.0;
                }
                else
                {
                    i__1 = h_dim1 + 2;

                    z__1.r = h[i__1].r / s;
                    z__1.i = h[i__1].i / s;

                    h21s.r = z__1.r;
                    h21s.i = z__1.i;

                    i__1 = h_dim1 + 3;

                    z__1.r = h[i__1].r / s;
                    z__1.i = h[i__1].i / s;

                    h31s.r = z__1.r;
                    h31s.i = z__1.i;

                    i__1 = h_dim1 + 1;

                    z__4.r = h[i__1].r - s1.r;
                    z__4.i = h[i__1].i - s1.i;

                    i__2 = h_dim1 + 1;

                    z__6.r = h[i__2].r - s2.r;
                    z__6.i = h[i__2].i - s2.i;

                    z__5.r = z__6.r / s;
                    z__5.i = z__6.i / s;

                    z__3.r = z__4.r * z__5.r - z__4.i * z__5.i;
                    z__3.i = z__4.r * z__5.i + z__4.i * z__5.r;

                    i__3 = (h_dim1 << 1) + 1;

                    z__7.r = h[i__3].r * h21s.r - h[i__3].i * h21s.i;
                    z__7.i = h[i__3].r * h21s.i + h[i__3].i * h21s.r;

                    z__2.r = z__3.r + z__7.r;
                    z__2.i = z__3.i + z__7.i;

                    i__4 = h_dim1 * 3 + 1;

                    z__8.r = h[i__4].r * h31s.r - h[i__4].i * h31s.i;
                    z__8.i = h[i__4].r * h31s.i + h[i__4].i * h31s.r;

                    z__1.r = z__2.r + z__8.r;
                    z__1.i = z__2.i + z__8.i;

                    v[1].r = z__1.r;
                    v[1].i = z__1.i;

                    i__1 = h_dim1 + 1;
                    i__2 = (h_dim1 << 1) + 2;

                    z__5.r = h[i__1].r + h[i__2].r;
                    z__5.i = h[i__1].i + h[i__2].i;

                    z__4.r = z__5.r - s1.r;
                    z__4.i = z__5.i - s1.i;

                    z__3.r = z__4.r - s2.r;
                    z__3.i = z__4.i - s2.i;

                    z__2.r = h21s.r * z__3.r - h21s.i * z__3.i;
                    z__2.i = h21s.r * z__3.i + h21s.i * z__3.r;

                    i__3 = h_dim1 * 3 + 2;
                    z__6.r = h[i__3].r * h31s.r - h[i__3].i * h31s.i;
                    z__6.i = h[i__3].r * h31s.i + h[i__3].i * h31s.r;

                    z__1.r = z__2.r + z__6.r;
                    z__1.i = z__2.i + z__6.i;

                    v[2].r = z__1.r;
                    v[2].i = z__1.i;

                    i__1 = h_dim1 + 1;
                    i__2 = h_dim1 * 3 + 3;

                    z__5.r = h[i__1].r + h[i__2].r;
                    z__5.i = h[i__1].i + h[i__2].i;

                    z__4.r = z__5.r - s1.r;
                    z__4.i = z__5.i - s1.i;

                    z__3.r = z__4.r - s2.r;
                    z__3.i = z__4.i - s2.i;

                    z__2.r = h31s.r * z__3.r - h31s.i * z__3.i;
                    z__2.i = h31s.r * z__3.i + h31s.i * z__3.r;

                    i__3 = (h_dim1 << 1) + 3;

                    z__6.r = h21s.r * h[i__3].r - h21s.i * h[i__3].i;
                    z__6.i = h21s.r * h[i__3].i + h21s.i * h[i__3].r;

                    z__1.r = z__2.r + z__6.r;
                    z__1.i = z__2.i + z__6.i;

                    v[3].r = z__1.r;
                    v[3].i = z__1.i;
                }
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zlaqr2(bool* wantt, bool* wantz, int* n, int* ktop, int* kbot, int* nw, complex16* h,
            int* ldh, int* iloz, int* ihiz, complex16* z, int* ldz, int* ns, int* nd, complex16* sh,
            complex16* v, int* ldv, int* nh, complex16* t, int* ldt, int* nv, complex16* wv, int* ldwv,
            complex16* work, int* lwork)
        {
            //  -- LAPACK auxiliary routine (version 3.2.1)                        -- 
            //     Univ. of Tennessee, Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd.. 
            //  -- April 2009                                                      -- 

            //     This subroutine is identical to ZLAQR3 except that it avoids 
            //     recursion by calling ZLAHQR instead of ZLAQR4. 


            //     ****************************************************************** 
            //     Aggressive early deflation: 

            //     This subroutine accepts as input an upper Hessenberg matrix 
            //     H and performs an unitary similarity transformation 
            //     designed to detect and deflate fully converged eigenvalues from 
            //     a trailing principal submatrix.  On output H has been over- 
            //     written by a new Hessenberg matrix that is a perturbation of 
            //     an unitary similarity transformation of H.  It is to be 
            //     hoped that the final version of H has many zero subdiagonal 
            //     entries. 

            //     ****************************************************************** 
            //     WANTT   (input) bool 
            //          If .TRUE., then the Hessenberg matrix H is fully updated 
            //          so that the triangular Schur factor may be 
            //          computed (in cooperation with the calling subroutine). 
            //          If .FALSE., then only enough of H is updated to preserve 
            //          the eigenvalues. 

            //     WANTZ   (input) bool 
            //          If .TRUE., then the unitary matrix Z is updated so 
            //          so that the unitary Schur factor may be computed 
            //          (in cooperation with the calling subroutine). 
            //          If .FALSE., then Z is not referenced. 

            //     N       (input) int 
            //          The order of the matrix H and (if WANTZ is .TRUE.) the 
            //          order of the unitary matrix Z. 

            //     KTOP    (input) int 
            //          It is assumed that either KTOP = 1 or H(KTOP,KTOP-1)=0. 
            //          KBOT and KTOP together determine an isolated block 
            //          aint the diagonal of the Hessenberg matrix. 

            //     KBOT    (input) int 
            //          It is assumed without a check that either 
            //          KBOT = N or H(KBOT+1,KBOT)=0.  KBOT and KTOP together 
            //          determine an isolated block aint the diagonal of the 
            //          Hessenberg matrix. 

            //     NW      (input) int 
            //          Deflation window size.  1 .LE. NW .LE. (KBOT-KTOP+1). 

            //     H       (input/output) COMPLEX*16 array, dimension (LDH,N) 
            //          On input the initial N-by-N section of H stores the 
            //          Hessenberg matrix undergoing aggressive early deflation. 
            //          On output H has been transformed by a unitary 
            //          similarity transformation, perturbed, and the returned 
            //          to Hessenberg form that (it is to be hoped) has some 
            //          zero subdiagonal entries. 

            //     LDH     (input) int 
            //          Leading dimension of H just as declared in the calling 
            //          subroutine.  N .LE. LDH 

            //     ILOZ    (input) int 
            //     IHIZ    (input) int 
            //          Specify the rows of Z to which transformations must be 
            //          applied if WANTZ is .TRUE.. 1 .LE. ILOZ .LE. IHIZ .LE. N. 

            //     Z       (input/output) COMPLEX*16 array, dimension (LDZ,N) 
            //          IF WANTZ is .TRUE., then on output, the unitary 
            //          similarity transformation mentioned above has been 
            //          accumulated into Z(ILOZ:IHIZ,ILO:IHI) from the right. 
            //          If WANTZ is .FALSE., then Z is unreferenced. 

            //     LDZ     (input) int 
            //          The leading dimension of Z just as declared in the 
            //          calling subroutine.  1 .LE. LDZ. 

            //     NS      (output) int 
            //          The number of unconverged (ie approximate) eigenvalues 
            //          returned in SR and SI that may be used as shifts by the 
            //          calling subroutine. 

            //     ND      (output) int 
            //          The number of converged eigenvalues uncovered by this 
            //          subroutine. 

            //     SH      (output) COMPLEX*16 array, dimension KBOT 
            //          On output, approximate eigenvalues that may 
            //          be used for shifts are stored in SH(KBOT-ND-NS+1) 
            //          through SR(KBOT-ND).  Converged eigenvalues are 
            //          stored in SH(KBOT-ND+1) through SH(KBOT). 

            //     V       (workspace) COMPLEX*16 array, dimension (LDV,NW) 
            //          An NW-by-NW work array. 

            //     LDV     (input) int scalar 
            //          The leading dimension of V just as declared in the 
            //          calling subroutine.  NW .LE. LDV 

            //     NH      (input) int scalar 
            //          The number of columns of T.  NH.GE.NW. 

            //     T       (workspace) COMPLEX*16 array, dimension (LDT,NW) 

            //     LDT     (input) int 
            //          The leading dimension of T just as declared in the 
            //          calling subroutine.  NW .LE. LDT 

            //     NV      (input) int 
            //          The number of rows of work array WV available for 
            //          workspace.  NV.GE.NW. 

            //     WV      (workspace) COMPLEX*16 array, dimension (LDWV,NW) 

            //     LDWV    (input) int 
            //          The leading dimension of W just as declared in the 
            //          calling subroutine.  NW .LE. LDV 

            //     WORK    (workspace) COMPLEX*16 array, dimension LWORK. 
            //          On exit, WORK(1) is set to an estimate of the optimal value 
            //          of LWORK for the given values of N, NW, KTOP and KBOT. 

            //     LWORK   (input) int 
            //          The dimension of the work array WORK.  LWORK = 2*NW 
            //          suffices, but greater efficiency may result from larger 
            //          values of LWORK. 

            //          If LWORK = -1, then a workspace query is assumed; ZLAQR2 
            //          only estimates the optimal workspace size for the given 
            //          values of N, NW, KTOP and KBOT.  The estimate is returned 
            //          in WORK(1).  No error message related to LWORK is issued 
            //          by XERBLA.  Neither H nor Z are accessed. 

            //     ================================================================ 
            //     Based on contributions by 
            //        Karen Braman and Ralph Byers, Department of Mathematics, 
            //        University of Kansas, USA 

            //     ================================================================ 

            // System generated locals 
            int h_dim1, h_offset, t_dim1, t_offset, v_dim1, v_offset, wv_dim1,
                wv_offset, z_dim1, z_offset, i__1, i__2, i__3, i__4;
            double d__1, d__5, d__6;
            complex16 z__1, z__2;

            // Table of constant values
            complex16 c_b1 = new complex16(0.0, 0.0);
            complex16 c_b2 = new complex16(1.0, 0.0);
            int c__1 = 1;
            int c_n1 = -1;
            bool c_true = true;

            // Local variables 
            int i, j;
            complex16 s;
            int jw;
            double foo;
            int kln;
            complex16 tau;
            int knt;
            double ulp;
            int lwk1, lwk2;
            complex16 beta;
            int kcol, info, ifst, ilst, ltop, krow;
            int infqr;
            int kwtop;
            double safmin, safmax;
            double smlnum;
            int lwkopt;

            // Parameter adjustments 
            h_dim1 = *ldh;
            h_offset = 1 + h_dim1;
            h -= h_offset;
            z_dim1 = *ldz;
            z_offset = 1 + z_dim1;
            z -= z_offset;
            --sh;
            v_dim1 = *ldv;
            v_offset = 1 + v_dim1;
            v -= v_offset;
            t_dim1 = *ldt;
            t_offset = 1 + t_dim1;
            t -= t_offset;
            wv_dim1 = *ldwv;
            wv_offset = 1 + wv_dim1;
            wv -= wv_offset;
            --work;

            // Function Body 
            // Computing MIN 
            i__1 = *nw;
            i__2 = *kbot - *ktop + 1;
            jw = Math.Min(i__1, i__2);
            if (jw <= 2)
            {
                lwkopt = 1;
            }
            else
            {
                // ==== Workspace query call to ZGEHRD ==== 

                i__1 = jw - 1;
                zgehrd(&jw, &c__1, &i__1, &t[t_offset], ldt, &work[1], &work[1], &
                    c_n1, &info);
                lwk1 = (int)work[1].r;

                // ==== Workspace query call to ZUNMHR ==== 

                i__1 = jw - 1;
                zunmhr("R", "N", &jw, &jw, &c__1, &i__1, &t[t_offset], ldt, &work[1],
                     &v[v_offset], ldv, &work[1], &c_n1, &info);
                lwk2 = (int)work[1].r;

                // ==== Optimal workspace ==== 

                lwkopt = jw + Math.Max(lwk1, lwk2);
            }

            // ==== Quick return in case of workspace query. ==== 

            if (*lwork == -1)
            {
                d__1 = (double)lwkopt;
                z__1.r = d__1;
                z__1.i = 0.0;

                work[1].r = z__1.r;
                work[1].i = z__1.i;
                return 0;
            }

            // ==== Nothing to do ... 
            // ... for an empty active block ... ==== 
            *ns = 0;
            *nd = 0;
            work[1].r = 1.0;
            work[1].i = 0.0;
            if (*ktop > *kbot)
            {
                return 0;
            }

            // ... nor for an empty deflation window. ==== 
            if (*nw < 1)
            {
                return 0;
            }

            // ==== Machine constants ==== 

            safmin = dlamch("SAFE MINIMUM");
            safmax = 1.0 / safmin;
            dlabad(&safmin, &safmax);
            ulp = dlamch("PRECISION");
            smlnum = safmin * ((double)(*n) / ulp);

            // ==== Setup deflation window ==== 

            // Computing MIN 
            i__1 = *nw;
            i__2 = *kbot - *ktop + 1;
            jw = Math.Min(i__1, i__2);
            kwtop = *kbot - jw + 1;

            if (kwtop == *ktop)
            {
                s.r = 0.0;
                s.i = 0.0;
            }
            else
            {
                i__1 = kwtop + (kwtop - 1) * h_dim1;
                s.r = h[i__1].r;
                s.i = h[i__1].i;
            }

            if (*kbot == kwtop)
            {
                // ==== 1-by-1 deflation window: not much to do ==== 

                i__1 = kwtop;
                i__2 = kwtop + kwtop * h_dim1;
                sh[i__1].r = h[i__2].r;
                sh[i__1].i = h[i__2].i;
                *ns = 1;
                *nd = 0;
                // Computing MAX 
                i__1 = kwtop + kwtop * h_dim1;
                d__5 = smlnum;
                d__6 = ulp * (Math.Abs(h[i__1].r) + Math.Abs(d_imag(&h[kwtop + kwtop * h_dim1])));

                if (Math.Abs(s.r) + Math.Abs(d_imag(&s)) <= Math.Max(d__5, d__6))
                {
                    *ns = 0;
                    *nd = 1;
                    if (kwtop > *ktop)
                    {
                        i__1 = kwtop + (kwtop - 1) * h_dim1;
                        h[i__1].r = 0.0;
                        h[i__1].i = 0.0;
                    }
                }

                work[1].r = 1.0;
                work[1].i = 0.0;
                return 0;
            }

            // ==== Convert to spike-triangular form.  (In case of a 
            // .    rare QR failure, this routine continues to do 
            // .    aggressive early deflation using that part of 
            // .    the deflation window that converged using INFQR 
            // .    here and there to keep track.) ==== 

            zlacpy("U", &jw, &jw, &h[kwtop + kwtop * h_dim1], ldh, &t[t_offset], ldt);
            i__1 = jw - 1;
            i__2 = *ldh + 1;
            i__3 = *ldt + 1;

            zcopy(&i__1, &h[kwtop + 1 + kwtop * h_dim1], &i__2, &t[t_dim1 + 2], &i__3);
            zlaset("A", &jw, &jw, &c_b1, &c_b2, &v[v_offset], ldv);
            zlahqr(&c_true, &c_true, &jw, &c__1, &jw, &t[t_offset], ldt, &sh[kwtop],
                &c__1, &jw, &v[v_offset], ldv, &infqr);

            // ==== Deflation detection loop ==== 

            *ns = jw;
            ilst = infqr + 1;
            i__1 = jw;
            for (knt = infqr + 1; knt <= i__1; ++knt)
            {
                // ==== Small spike tip deflation test ==== 

                i__2 = *ns + *ns * t_dim1;
                foo = Math.Abs(t[i__2].r) + Math.Abs(d_imag(&t[*ns + *ns * t_dim1]));

                if (foo == 0.0)
                {
                    foo = Math.Abs(s.r) + Math.Abs(d_imag(&s));
                }
                i__2 = *ns * v_dim1 + 1;
                // Computing MAX 
                d__5 = smlnum;
                d__6 = ulp * foo;

                if ((Math.Abs(s.r) + Math.Abs(d_imag(&s))) * (Math.Abs(v[i__2].r) +
                    Math.Abs(d_imag(&v[*ns * v_dim1 + 1]))) <= Math.Max(d__5, d__6))
                {
                    // ==== One more converged eigenvalue ==== 
                    --(*ns);
                }
                else
                {
                    // ==== One undeflatable eigenvalue.  Move it up out of the 
                    // .    way.   (ZTREXC can not fail in this case.) ==== 

                    ifst = *ns;
                    ztrexc("V", &jw, &t[t_offset], ldt, &v[v_offset], ldv, &ifst, &ilst, &info);
                    ++ilst;
                }
            }

            // ==== Return to Hessenberg form ==== 

            if (*ns == 0)
            {
                s.r = 0.0;
                s.i = 0.0;
            }

            if (*ns < jw)
            {
                // ==== sorting the diagonal of T improves accuracy for 
                // .    graded matrices.  ==== 

                i__1 = *ns;
                for (i = infqr + 1; i <= i__1; ++i)
                {
                    ifst = i;
                    i__2 = *ns;
                    for (j = i + 1; j <= i__2; ++j)
                    {
                        i__3 = j + j * t_dim1;
                        i__4 = ifst + ifst * t_dim1;
                        if (Math.Abs(t[i__3].r) + Math.Abs(d_imag(&t[j + j * t_dim1])) > Math.Abs(t[i__4].r) + Math.Abs(d_imag(&t[ifst + ifst * t_dim1])))
                        {
                            ifst = j;
                        }
                    }
                    ilst = i;
                    if (ifst != ilst)
                    {
                        ztrexc("V", &jw, &t[t_offset], ldt, &v[v_offset], ldv, &ifst, &ilst, &info);
                    }
                }
            }

            // ==== Restore shift/eigenvalue array from T ==== 

            i__1 = jw;
            for (i = infqr + 1; i <= i__1; ++i)
            {
                i__2 = kwtop + i - 1;
                i__3 = i + i * t_dim1;
                sh[i__2].r = t[i__3].r;
                sh[i__2].i = t[i__3].i;
            }

            if (*ns < jw || s.r == 0.0 && s.i == 0.0)
            {
                if (*ns > 1 && (s.r != 0.0 || s.i != 0.0))
                {
                    // ==== Reflect spike back into lower triangle ====

                    zcopy(ns, &v[v_offset], ldv, &work[1], &c__1);
                    i__1 = *ns;
                    for (i = 1; i <= i__1; ++i)
                    {
                        i__2 = i;
                        d_cnjg(&z__1, &work[i]);

                        work[i__2].r = z__1.r;
                        work[i__2].i = z__1.i;
                    }
                    beta.r = work[1].r;
                    beta.i = work[1].i;
                    zlarfg(ns, &beta, &work[2], &c__1, &tau);

                    work[1].r = 1.0;
                    work[1].i = 0.0;

                    i__1 = jw - 2;
                    i__2 = jw - 2;
                    zlaset("L", &i__1, &i__2, &c_b1, &c_b1, &t[t_dim1 + 3], ldt);

                    d_cnjg(&z__1, &tau);
                    zlarf("L", ns, &jw, &work[1], &c__1, &z__1, &t[t_offset], ldt, &work[jw + 1]);
                    zlarf("R", ns, ns, &work[1], &c__1, &tau, &t[t_offset], ldt, &work[jw + 1]);
                    zlarf("R", &jw, ns, &work[1], &c__1, &tau, &v[v_offset], ldv, &work[jw + 1]);

                    i__1 = *lwork - jw;
                    zgehrd(&jw, &c__1, ns, &t[t_offset], ldt, &work[1], &work[jw + 1], &i__1, &info);
                }

                // ==== Copy updated reduced window into place ====

                if (kwtop > 1)
                {
                    i__1 = kwtop + (kwtop - 1) * h_dim1;
                    d_cnjg(&z__2, &v[v_dim1 + 1]);
                    z__1.r = s.r * z__2.r - s.i * z__2.i;
                    z__1.i = s.r * z__2.i + s.i * z__2.r;
                    h[i__1].r = z__1.r;
                    h[i__1].i = z__1.i;
                }

                zlacpy("U", &jw, &jw, &t[t_offset], ldt, &h[kwtop + kwtop * h_dim1], ldh);
                i__1 = jw - 1;
                i__2 = *ldt + 1;
                i__3 = *ldh + 1;

                zcopy(&i__1, &t[t_dim1 + 2], &i__2, &h[kwtop + 1 + kwtop * h_dim1], &i__3);

                // ==== Accumulate orthogonal matrix in order update 
                // .    H and Z, if requested.  ==== 

                if (*ns > 1 && (s.r != 0.0 || s.i != 0.0))
                {
                    i__1 = *lwork - jw;
                    zunmhr("R", "N", &jw, ns, &c__1, ns, &t[t_offset], ldt, &work[1],
                         &v[v_offset], ldv, &work[jw + 1], &i__1, &info);
                }

                // ==== Update vertical slab in H ==== 

                if (*wantt)
                {
                    ltop = 1;
                }
                else
                {
                    ltop = *ktop;
                }
                i__1 = kwtop - 1;
                i__2 = *nv;
                for (krow = ltop; i__2 < 0 ? krow >= i__1 : krow <= i__1; krow += i__2)
                {
                    // Computing MIN 
                    i__3 = *nv;
                    i__4 = kwtop - krow;
                    kln = Math.Min(i__3, i__4);
                    zgemm("N", "N", &kln, &jw, &jw, &c_b2, &h[krow + kwtop * h_dim1],
                        ldh, &v[v_offset], ldv, &c_b1, &wv[wv_offset], ldwv);
                    zlacpy("A", &kln, &jw, &wv[wv_offset], ldwv, &h[krow + kwtop * h_dim1], ldh);
                }

                // ==== Update horizontal slab in H ==== 

                if (*wantt)
                {
                    i__2 = *n;
                    i__1 = *nh;
                    for (kcol = *kbot + 1; i__1 < 0 ? kcol >= i__2 : kcol <= i__2; kcol += i__1)
                    {
                        // Computing MIN 
                        i__3 = *nh;
                        i__4 = *n - kcol + 1;
                        kln = Math.Min(i__3, i__4);
                        zgemm("C", "N", &jw, &kln, &jw, &c_b2, &v[v_offset], ldv, &
                            h[kwtop + kcol * h_dim1], ldh, &c_b1, &t[t_offset], ldt);
                        zlacpy("A", &jw, &kln, &t[t_offset], ldt, &h[kwtop + kcol * h_dim1], ldh);
                    }
                }

                // ==== Update vertical slab in Z ==== 

                if (*wantz)
                {
                    i__1 = *ihiz;
                    i__2 = *nv;
                    for (krow = *iloz; i__2 < 0 ? krow >= i__1 : krow <= i__1; krow += i__2)
                    {
                        // Computing MIN 
                        i__3 = *nv;
                        i__4 = *ihiz - krow + 1;
                        kln = Math.Min(i__3, i__4);
                        zgemm("N", "N", &kln, &jw, &jw, &c_b2, &z[krow + kwtop * z_dim1],
                            ldz, &v[v_offset], ldv, &c_b1, &wv[wv_offset], ldwv);
                        zlacpy("A", &kln, &jw, &wv[wv_offset], ldwv, &z[krow + kwtop * z_dim1], ldz);
                    }
                }
            }

            // ==== Return the number of deflations ... ==== 

            *nd = jw - *ns;

            // ==== ... and the number of shifts. (Subtracting 
            // .    INFQR from the spike length takes care 
            // .    of the case of a rare QR failure while 
            // .    calculating eigenvalues of the deflation 
            // .    window.)  ==== 

            *ns -= infqr;

            //      ==== Return optimal workspace. ==== 

            d__1 = (double)lwkopt;
            z__1.r = d__1;
            z__1.i = 0.0;

            work[1].r = z__1.r;
            work[1].i = z__1.i;

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zlaqr3(bool* wantt, bool* wantz, int* n, int* ktop, int* kbot, int* nw, complex16* h,
            int* ldh, int* iloz, int* ihiz, complex16* z, int* ldz, int* ns, int* nd, complex16* sh,
            complex16* v, int* ldv, int* nh, complex16* t, int* ldt, int* nv, complex16* wv, int* ldwv,
            complex16* work, int* lwork)
        {
            //  -- LAPACK auxiliary routine (version 3.2.1)                        -- 
            //     Univ. of Tennessee, Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd.. 
            //  -- April 2009                                                      -- 

            //     ****************************************************************** 
            //     Aggressive early deflation: 

            //     This subroutine accepts as input an upper Hessenberg matrix 
            //     H and performs an unitary similarity transformation 
            //     designed to detect and deflate fully converged eigenvalues from 
            //     a trailing principal submatrix.  On output H has been over- 
            //     written by a new Hessenberg matrix that is a perturbation of 
            //     an unitary similarity transformation of H.  It is to be 
            //     hoped that the final version of H has many zero subdiagonal 
            //     entries. 

            //     ****************************************************************** 
            //     WANTT   (input) bool 
            //          If .TRUE., then the Hessenberg matrix H is fully updated 
            //          so that the triangular Schur factor may be 
            //          computed (in cooperation with the calling subroutine). 
            //          If .FALSE., then only enough of H is updated to preserve 
            //          the eigenvalues. 

            //     WANTZ   (input) bool 
            //          If .TRUE., then the unitary matrix Z is updated so 
            //          so that the unitary Schur factor may be computed 
            //          (in cooperation with the calling subroutine). 
            //          If .FALSE., then Z is not referenced. 

            //     N       (input) int 
            //          The order of the matrix H and (if WANTZ is .TRUE.) the 
            //          order of the unitary matrix Z. 

            //     KTOP    (input) int 
            //          It is assumed that either KTOP = 1 or H(KTOP,KTOP-1)=0. 
            //          KBOT and KTOP together determine an isolated block 
            //          aint the diagonal of the Hessenberg matrix. 

            //     KBOT    (input) int 
            //          It is assumed without a check that either 
            //          KBOT = N or H(KBOT+1,KBOT)=0.  KBOT and KTOP together 
            //          determine an isolated block aint the diagonal of the 
            //          Hessenberg matrix. 

            //     NW      (input) int 
            //          Deflation window size.  1 .LE. NW .LE. (KBOT-KTOP+1). 

            //     H       (input/output) COMPLEX*16 array, dimension (LDH,N) 
            //          On input the initial N-by-N section of H stores the 
            //          Hessenberg matrix undergoing aggressive early deflation. 
            //          On output H has been transformed by a unitary 
            //          similarity transformation, perturbed, and the returned 
            //          to Hessenberg form that (it is to be hoped) has some 
            //          zero subdiagonal entries. 

            //     LDH     (input) int 
            //          Leading dimension of H just as declared in the calling 
            //          subroutine.  N .LE. LDH 

            //     ILOZ    (input) int 
            //     IHIZ    (input) int 
            //          Specify the rows of Z to which transformations must be 
            //          applied if WANTZ is .TRUE.. 1 .LE. ILOZ .LE. IHIZ .LE. N. 

            //     Z       (input/output) COMPLEX*16 array, dimension (LDZ,N) 
            //          IF WANTZ is .TRUE., then on output, the unitary 
            //          similarity transformation mentioned above has been 
            //          accumulated into Z(ILOZ:IHIZ,ILO:IHI) from the right. 
            //          If WANTZ is .FALSE., then Z is unreferenced. 

            //     LDZ     (input) int 
            //          The leading dimension of Z just as declared in the 
            //          calling subroutine.  1 .LE. LDZ. 

            //     NS      (output) int 
            //          The number of unconverged (ie approximate) eigenvalues 
            //          returned in SR and SI that may be used as shifts by the 
            //          calling subroutine. 

            //     ND      (output) int 
            //          The number of converged eigenvalues uncovered by this 
            //          subroutine. 

            //     SH      (output) COMPLEX*16 array, dimension KBOT 
            //          On output, approximate eigenvalues that may 
            //          be used for shifts are stored in SH(KBOT-ND-NS+1) 
            //          through SR(KBOT-ND).  Converged eigenvalues are 
            //          stored in SH(KBOT-ND+1) through SH(KBOT). 

            //     V       (workspace) COMPLEX*16 array, dimension (LDV,NW) 
            //          An NW-by-NW work array. 

            //     LDV     (input) int scalar 
            //          The leading dimension of V just as declared in the 
            //          calling subroutine.  NW .LE. LDV 

            //     NH      (input) int scalar 
            //          The number of columns of T.  NH.GE.NW. 

            //     T       (workspace) COMPLEX*16 array, dimension (LDT,NW) 

            //     LDT     (input) int 
            //          The leading dimension of T just as declared in the 
            //          calling subroutine.  NW .LE. LDT 

            //     NV      (input) int 
            //          The number of rows of work array WV available for 
            //          workspace.  NV.GE.NW. 

            //     WV      (workspace) COMPLEX*16 array, dimension (LDWV,NW) 

            //     LDWV    (input) int 
            //          The leading dimension of W just as declared in the 
            //          calling subroutine.  NW .LE. LDV 

            //     WORK    (workspace) COMPLEX*16 array, dimension LWORK. 
            //          On exit, WORK(1) is set to an estimate of the optimal value 
            //          of LWORK for the given values of N, NW, KTOP and KBOT. 

            //     LWORK   (input) int 
            //          The dimension of the work array WORK.  LWORK = 2*NW 
            //          suffices, but greater efficiency may result from larger 
            //          values of LWORK. 

            //          If LWORK = -1, then a workspace query is assumed; ZLAQR3 
            //          only estimates the optimal workspace size for the given 
            //          values of N, NW, KTOP and KBOT.  The estimate is returned 
            //          in WORK(1).  No error message related to LWORK is issued 
            //          by XERBLA.  Neither H nor Z are accessed. 

            //     ================================================================ 
            //     Based on contributions by 
            //        Karen Braman and Ralph Byers, Department of Mathematics, 
            //        University of Kansas, USA 

            //     ================================================================ 

            // System generated locals 
            int h_dim1, h_offset, t_dim1, t_offset, v_dim1, v_offset, wv_dim1,
                wv_offset, z_dim1, z_offset, i__1, i__2, i__3, i__4;
            double d__1, d__5, d__6;
            complex16 z__1, z__2;

            // Table of constant values
            complex16 c_b1 = new complex16(0.0, 0.0);
            complex16 c_b2 = new complex16(1.0, 0.0);
            int c__1 = 1;
            int c_n1 = -1;
            bool c_true = true;
            int c__12 = 12;

            // Local variables 
            int i, j;
            complex16 s;
            int jw;
            double foo;
            int kln;
            complex16 tau;
            int knt;
            double ulp;
            int lwk1, lwk2, lwk3;
            complex16 beta;
            int kcol, info, nmin, ifst, ilst, ltop, krow;
            int infqr;
            int kwtop;
            double safmin;
            double safmax;
            double smlnum;
            int lwkopt;

            // Parameter adjustments 
            h_dim1 = *ldh;
            h_offset = 1 + h_dim1;
            h -= h_offset;
            z_dim1 = *ldz;
            z_offset = 1 + z_dim1;
            z -= z_offset;
            --sh;
            v_dim1 = *ldv;
            v_offset = 1 + v_dim1;
            v -= v_offset;
            t_dim1 = *ldt;
            t_offset = 1 + t_dim1;
            t -= t_offset;
            wv_dim1 = *ldwv;
            wv_offset = 1 + wv_dim1;
            wv -= wv_offset;
            --work;

            // Function Body 
            // Computing MIN 
            i__1 = *nw;
            i__2 = *kbot - *ktop + 1;
            jw = Math.Min(i__1, i__2);

            if (jw <= 2)
            {
                lwkopt = 1;
            }
            else
            {
                // ==== Workspace query call to ZGEHRD ==== 

                i__1 = jw - 1;
                zgehrd(&jw, &c__1, &i__1, &t[t_offset], ldt, &work[1], &work[1], &c_n1, &info);
                lwk1 = (int)work[1].r;

                // ==== Workspace query call to ZUNMHR ==== 

                i__1 = jw - 1;
                zunmhr("R", "N", &jw, &jw, &c__1, &i__1, &t[t_offset], ldt, &work[1],
                     &v[v_offset], ldv, &work[1], &c_n1, &info);
                lwk2 = (int)work[1].r;

                // ==== Workspace query call to ZLAQR4 ==== 

                zlaqr4(&c_true, &c_true, &jw, &c__1, &jw, &t[t_offset], ldt, &sh[1],
                    &c__1, &jw, &v[v_offset], ldv, &work[1], &c_n1, &infqr);

                lwk3 = (int)work[1].r;

                // ==== Optimal workspace ==== 

                // Computing MAX 
                i__1 = jw + Math.Max(lwk1, lwk2);
                lwkopt = Math.Max(i__1, lwk3);
            }

            // ==== Quick return in case of workspace query. ==== 

            if (*lwork == -1)
            {
                d__1 = (double)lwkopt;

                z__1.r = d__1;
                z__1.i = 0.0;

                work[1].r = z__1.r;
                work[1].i = z__1.i;
                return 0;
            }

            // ==== Nothing to do ... 
            // ... for an empty active block ... ==== 
            *ns = 0;
            *nd = 0;

            work[1].r = 1.0;
            work[1].i = 0.0;

            if (*ktop > *kbot)
            {
                return 0;
            }
            // ... nor for an empty deflation window. ==== 
            if (*nw < 1)
            {
                return 0;
            }

            // ==== Machine constants ==== 

            safmin = dlamch("SAFE MINIMUM");
            safmax = 1.0 / safmin;
            dlabad(&safmin, &safmax);
            ulp = dlamch("PRECISION");
            smlnum = safmin * ((double)(*n) / ulp);

            // ==== Setup deflation window ==== 

            // Computing MIN 
            i__1 = *nw;
            i__2 = *kbot - *ktop + 1;
            jw = Math.Min(i__1, i__2);
            kwtop = *kbot - jw + 1;

            if (kwtop == *ktop)
            {
                s.r = 0.0;
                s.i = 0.0;
            }
            else
            {
                i__1 = kwtop + (kwtop - 1) * h_dim1;

                s.r = h[i__1].r;
                s.i = h[i__1].i;
            }

            if (*kbot == kwtop)
            {
                //  ==== 1-by-1 deflation window: not much to do ==== 

                i__1 = kwtop;
                i__2 = kwtop + kwtop * h_dim1;

                sh[i__1].r = h[i__2].r;
                sh[i__1].i = h[i__2].i;

                *ns = 1;
                *nd = 0;

                // Computing MAX 
                i__1 = kwtop + kwtop * h_dim1;
                d__5 = smlnum;
                d__6 = ulp * (Math.Abs(h[i__1].r) + Math.Abs(d_imag(&h[kwtop + kwtop * h_dim1])));

                if (Math.Abs(s.r) + Math.Abs(d_imag(&s)) <= Math.Max(d__5, d__6))
                {
                    *ns = 0;
                    *nd = 1;
                    if (kwtop > *ktop)
                    {
                        i__1 = kwtop + (kwtop - 1) * h_dim1;

                        h[i__1].r = 0.0;
                        h[i__1].i = 0.0;
                    }
                }

                work[1].r = 1.0;
                work[1].i = 0.0;
                return 0;
            }

            // ==== Convert to spike-triangular form.  (In case of a 
            // .    rare QR failure, this routine continues to do 
            // .    aggressive early deflation using that part of 
            // .    the deflation window that converged using INFQR 
            // .    here and there to keep track.) ==== 

            zlacpy("U", &jw, &jw, &h[kwtop + kwtop * h_dim1], ldh, &t[t_offset], ldt);

            i__1 = jw - 1;
            i__2 = *ldh + 1;
            i__3 = *ldt + 1;

            zcopy(&i__1, &h[kwtop + 1 + kwtop * h_dim1], &i__2, &t[t_dim1 + 2], &i__3);

            zlaset("A", &jw, &jw, &c_b1, &c_b2, &v[v_offset], ldv);
            nmin = ilaenv(&c__12, "ZLAQR3", "SV", &jw, &c__1, &jw, lwork);

            if (jw > nmin)
            {
                zlaqr4(&c_true, &c_true, &jw, &c__1, &jw, &t[t_offset], ldt, &sh[kwtop],
                    &c__1, &jw, &v[v_offset], ldv, &work[1], lwork, &infqr);
            }
            else
            {
                zlahqr(&c_true, &c_true, &jw, &c__1, &jw, &t[t_offset], ldt,
                    &sh[kwtop], &c__1, &jw, &v[v_offset], ldv, &infqr);
            }

            // ==== Deflation detection loop ==== 

            *ns = jw;
            ilst = infqr + 1;
            i__1 = jw;
            for (knt = infqr + 1; knt <= i__1; ++knt)
            {
                // ==== Small spike tip deflation test ==== 

                i__2 = *ns + *ns * t_dim1;
                foo = Math.Abs(t[i__2].r) + Math.Abs(d_imag(&t[*ns + *ns * t_dim1]));

                if (foo == 0.0)
                {
                    foo = Math.Abs(s.r) + Math.Abs(d_imag(&s));
                }

                i__2 = *ns * v_dim1 + 1;

                // Computing MAX 
                d__5 = smlnum;
                d__6 = ulp * foo;

                if ((Math.Abs(s.r) + Math.Abs(d_imag(&s))) * (Math.Abs(v[i__2].r) + Math.Abs(d_imag(&v[*ns * v_dim1 + 1]))) <= Math.Max(d__5, d__6))
                {
                    // ==== One more converged eigenvalue ==== 
                    --(*ns);
                }
                else
                {
                    // ==== One undeflatable eigenvalue.  Move it up out of the 
                    // .    way.   (ZTREXC can not fail in this case.) ==== 

                    ifst = *ns;
                    ztrexc("V", &jw, &t[t_offset], ldt, &v[v_offset], ldv, &ifst, &ilst, &info);
                    ++ilst;
                }
            }

            //        ==== Return to Hessenberg form ==== 

            if (*ns == 0)
            {
                s.r = 0.0;
                s.i = 0.0;
            }

            if (*ns < jw)
            {

                // ==== sorting the diagonal of T improves accuracy for 
                // .    graded matrices.  ==== 

                i__1 = *ns;
                for (i = infqr + 1; i <= i__1; ++i)
                {
                    ifst = i;
                    i__2 = *ns;
                    for (j = i + 1; j <= i__2; ++j)
                    {
                        i__3 = j + j * t_dim1;
                        i__4 = ifst + ifst * t_dim1;
                        if (Math.Abs(t[i__3].r) + Math.Abs(d_imag(&t[j + j * t_dim1])) > Math.Abs(t[i__4].r) + Math.Abs(d_imag(&t[ifst + ifst * t_dim1])))
                        {
                            ifst = j;
                        }
                    }

                    ilst = i;
                    if (ifst != ilst)
                    {
                        ztrexc("V", &jw, &t[t_offset], ldt, &v[v_offset], ldv, &ifst, &ilst, &info);
                    }
                }
            }

            //     ==== Restore shift/eigenvalue array from T ==== 

            i__1 = jw;
            for (i = infqr + 1; i <= i__1; ++i)
            {
                i__2 = kwtop + i - 1;
                i__3 = i + i * t_dim1;

                sh[i__2].r = t[i__3].r;
                sh[i__2].i = t[i__3].i;
            }


            if (*ns < jw || s.r == 0.0 && s.i == 0.0)
            {
                if (*ns > 1 && (s.r != 0.0 || s.i != 0.0))
                {
                    // ==== Reflect spike back into lower triangle ==== 

                    zcopy(ns, &v[v_offset], ldv, &work[1], &c__1);
                    i__1 = *ns;

                    for (i = 1; i <= i__1; ++i)
                    {
                        i__2 = i;
                        d_cnjg(&z__1, &work[i]);

                        work[i__2].r = z__1.r;
                        work[i__2].i = z__1.i;
                    }

                    beta.r = work[1].r;
                    beta.i = work[1].i;

                    zlarfg(ns, &beta, &work[2], &c__1, &tau);
                    work[1].r = 1.0;
                    work[1].i = 0.0;

                    i__1 = jw - 2;
                    i__2 = jw - 2;
                    zlaset("L", &i__1, &i__2, &c_b1, &c_b1, &t[t_dim1 + 3], ldt);

                    d_cnjg(&z__1, &tau);
                    zlarf("L", ns, &jw, &work[1], &c__1, &z__1, &t[t_offset], ldt, &work[jw + 1]);
                    zlarf("R", ns, ns, &work[1], &c__1, &tau, &t[t_offset], ldt, &work[jw + 1]);
                    zlarf("R", &jw, ns, &work[1], &c__1, &tau, &v[v_offset], ldv, &work[jw + 1]);

                    i__1 = *lwork - jw;
                    zgehrd(&jw, &c__1, ns, &t[t_offset], ldt, &work[1], &work[jw + 1], &i__1, &info);
                }

                // ==== Copy updated reduced window into place ==== 

                if (kwtop > 1)
                {
                    i__1 = kwtop + (kwtop - 1) * h_dim1;
                    d_cnjg(&z__2, &v[v_dim1 + 1]);

                    z__1.r = s.r * z__2.r - s.i * z__2.i;
                    z__1.i = s.r * z__2.i + s.i * z__2.r;

                    h[i__1].r = z__1.r;
                    h[i__1].i = z__1.i;
                }

                zlacpy("U", &jw, &jw, &t[t_offset], ldt, &h[kwtop + kwtop * h_dim1], ldh);

                i__1 = jw - 1;
                i__2 = *ldt + 1;
                i__3 = *ldh + 1;

                zcopy(&i__1, &t[t_dim1 + 2], &i__2, &h[kwtop + 1 + kwtop * h_dim1], &i__3);

                // ==== Accumulate orthogonal matrix in order update 
                // .    H and Z, if requested.  ==== 

                if (*ns > 1 && (s.r != 0.0 || s.i != 0.0))
                {
                    i__1 = *lwork - jw;
                    zunmhr("R", "N", &jw, ns, &c__1, ns, &t[t_offset], ldt, &work[1],
                         &v[v_offset], ldv, &work[jw + 1], &i__1, &info);
                }

                // ==== Update vertical slab in H ==== 

                if (*wantt)
                {
                    ltop = 1;
                }
                else
                {
                    ltop = *ktop;
                }

                i__1 = kwtop - 1;
                i__2 = *nv;
                for (krow = ltop; i__2 < 0 ? krow >= i__1 : krow <= i__1; krow += i__2)
                {
                    // Computing MIN 
                    i__3 = *nv;
                    i__4 = kwtop - krow;
                    kln = Math.Min(i__3, i__4);

                    zgemm("N", "N", &kln, &jw, &jw, &c_b2, &h[krow + kwtop *
                        h_dim1], ldh, &v[v_offset], ldv, &c_b1, &wv[wv_offset], ldwv);

                    zlacpy("A", &kln, &jw, &wv[wv_offset], ldwv, &h[krow + kwtop * h_dim1], ldh);
                }

                // ==== Update horizontal slab in H ==== 

                if (*wantt)
                {
                    i__2 = *n;
                    i__1 = *nh;

                    for (kcol = *kbot + 1; i__1 < 0 ? kcol >= i__2 : kcol <= i__2; kcol += i__1)
                    {
                        // Computing MIN 
                        i__3 = *nh;
                        i__4 = *n - kcol + 1;
                        kln = Math.Min(i__3, i__4);

                        zgemm("C", "N", &jw, &kln, &jw, &c_b2, &v[v_offset], ldv,
                            &h[kwtop + kcol * h_dim1], ldh, &c_b1, &t[t_offset], ldt);

                        zlacpy("A", &jw, &kln, &t[t_offset], ldt, &h[kwtop + kcol * h_dim1], ldh);
                    }
                }

                // ==== Update vertical slab in Z ==== 

                if (*wantz)
                {
                    i__1 = *ihiz;
                    i__2 = *nv;

                    for (krow = *iloz; i__2 < 0 ? krow >= i__1 : krow <= i__1; krow += i__2)
                    {
                        // Computing MIN 
                        i__3 = *nv;
                        i__4 = *ihiz - krow + 1;
                        kln = Math.Min(i__3, i__4);

                        zgemm("N", "N", &kln, &jw, &jw, &c_b2, &z[krow + kwtop * z_dim1],
                            ldz, &v[v_offset], ldv, &c_b1, &wv[wv_offset], ldwv);

                        zlacpy("A", &kln, &jw, &wv[wv_offset], ldwv, &z[krow + kwtop * z_dim1], ldz);
                    }
                }
            }

            // ==== Return the number of deflations ... ==== 

            *nd = jw - *ns;

            // ==== ... and the number of shifts. (Subtracting 
            // .    INFQR from the spike length takes care 
            // .    of the case of a rare QR failure while 
            // .    calculating eigenvalues of the deflation 
            // .    window.)  ==== 

            *ns -= infqr;

            // ==== Return optimal workspace. ==== 

            d__1 = (double)lwkopt;

            z__1.r = d__1;
            z__1.i = 0.0;
            work[1].r = z__1.r;
            work[1].i = z__1.i;

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zlaqr4(bool* wantt, bool* wantz, int* n, int* ilo, int* ihi, complex16* h, int* ldh,
            complex16* w, int* iloz, int* ihiz, complex16* z, int* ldz, complex16* work, int* lwork, int* info)
        {
            //  -- LAPACK auxiliary routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd.. 
            //     November 2006 

            //     This subroutine implements one level of recursion for ZLAQR0. 
            //     It is a complete implementation of the small bulge multi-shift 
            //     QR algorithm.  It may be called by ZLAQR0 and, for large enough 
            //     deflation window size, it may be called by ZLAQR3.  This 
            //     subroutine is identical to ZLAQR0 except that it calls ZLAQR2 
            //     instead of ZLAQR3. 

            //     Purpose 
            //     ======= 

            //     ZLAQR4 computes the eigenvalues of a Hessenberg matrix H 
            //     and, optionally, the matrices T and Z from the Schur decomposition 
            //     H = Z T Z**H, where T is an upper triangular matrix (the 
            //     Schur form), and Z is the unitary matrix of Schur vectors. 

            //     Optionally Z may be postmultiplied into an input unitary 
            //     matrix Q so that this routine can give the Schur factorization 
            //     of a matrix A which has been reduced to the Hessenberg form H 
            //     by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*H*(QZ)**H. 

            //     Arguments 
            //     ========= 

            //     WANTT   (input) bool 
            //          = .TRUE. : the full Schur form T is required; 
            //          = .FALSE.: only eigenvalues are required. 

            //     WANTZ   (input) bool 
            //          = .TRUE. : the matrix of Schur vectors Z is required; 
            //          = .FALSE.: Schur vectors are not required. 

            //     N     (input) int 
            //           The order of the matrix H.  N .GE. 0. 

            //     ILO   (input) int 
            //     IHI   (input) int 
            //           It is assumed that H is already upper triangular in rows 
            //           and columns 1:ILO-1 and IHI+1:N and, if ILO.GT.1, 
            //           H(ILO,ILO-1) is zero. ILO and IHI are normally set by a 
            //           previous call to ZGEBAL, and then passed to ZGEHRD when the 
            //           matrix output by ZGEBAL is reduced to Hessenberg form. 
            //           Otherwise, ILO and IHI should be set to 1 and N, 
            //           respectively.  If N.GT.0, then 1.LE.ILO.LE.IHI.LE.N. 
            //           If N = 0, then ILO = 1 and IHI = 0. 

            //     H     (input/output) COMPLEX*16 array, dimension (LDH,N) 
            //           On entry, the upper Hessenberg matrix H. 
            //           On exit, if INFO = 0 and WANTT is .TRUE., then H 
            //           contains the upper triangular matrix T from the Schur 
            //           decomposition (the Schur form). If INFO = 0 and WANT is 
            //           .FALSE., then the contents of H are unspecified on exit. 
            //           (The output value of H when INFO.GT.0 is given under the 
            //           description of INFO below.) 

            //           This subroutine may explicitly set H(i,j) = 0 for i.GT.j and 
            //           j = 1, 2, ... ILO-1 or j = IHI+1, IHI+2, ... N. 

            //     LDH   (input) int 
            //           The leading dimension of the array H. LDH .GE. max(1,N). 

            //     W        (output) COMPLEX*16 array, dimension (N) 
            //           The computed eigenvalues of H(ILO:IHI,ILO:IHI) are stored 
            //           in W(ILO:IHI). If WANTT is .TRUE., then the eigenvalues are 
            //           stored in the same order as on the diagonal of the Schur 
            //           form returned in H, with W(i) = H(i,i). 

            //     Z     (input/output) COMPLEX*16 array, dimension (LDZ,IHI) 
            //           If WANTZ is .FALSE., then Z is not referenced. 
            //           If WANTZ is .TRUE., then Z(ILO:IHI,ILOZ:IHIZ) is 
            //           replaced by Z(ILO:IHI,ILOZ:IHIZ)*U where U is the 
            //           orthogonal Schur factor of H(ILO:IHI,ILO:IHI). 
            //           (The output value of Z when INFO.GT.0 is given under 
            //           the description of INFO below.) 

            //     LDZ   (input) int 
            //           The leading dimension of the array Z.  if WANTZ is .TRUE. 
            //           then LDZ.GE.MAX(1,IHIZ).  Otherwize, LDZ.GE.1. 

            //     WORK  (workspace/output) COMPLEX*16 array, dimension LWORK 
            //           On exit, if LWORK = -1, WORK(1) returns an estimate of 
            //           the optimal value for LWORK. 

            //     LWORK (input) int 
            //           The dimension of the array WORK.  LWORK .GE. max(1,N) 
            //           is sufficient, but LWORK typically as large as 6*N may 
            //           be required for optimal performance.  A workspace query 
            //           to determine the optimal workspace size is recommended. 

            //           If LWORK = -1, then ZLAQR4 does a workspace query. 
            //           In this case, ZLAQR4 checks the input parameters and 
            //           estimates the optimal workspace size for the given 
            //           values of N, ILO and IHI.  The estimate is returned 
            //           in WORK(1).  No error message related to LWORK is 
            //           issued by XERBLA.  Neither H nor Z are accessed. 


            //     INFO  (output) int 
            //             =  0:  successful exit 
            //           .GT. 0:  if INFO = i, ZLAQR4 failed to compute all of 
            //                the eigenvalues.  Elements 1:ilo-1 and i+1:n of WR 
            //                and WI contain those eigenvalues which have been 
            //                successfully computed.  (Failures are rare.) 

            //                If INFO .GT. 0 and WANT is .FALSE., then on exit, 
            //                the remaining unconverged eigenvalues are the eigen- 
            //                values of the upper Hessenberg matrix rows and 
            //                columns ILO through INFO of the final, output 
            //                value of H. 

            //                If INFO .GT. 0 and WANTT is .TRUE., then on exit 

            //           (*)  (initial value of H)*U  = U*(final value of H) 

            //                where U is a unitary matrix.  The final 
            //                value of  H is upper Hessenberg and triangular in 
            //                rows and columns INFO+1 through IHI. 

            //                If INFO .GT. 0 and WANTZ is .TRUE., then on exit 

            //                  (final value of Z(ILO:IHI,ILOZ:IHIZ) 
            //                   =  (initial value of Z(ILO:IHI,ILOZ:IHIZ)*U 

            //                where U is the unitary matrix in (*) (regard- 
            //                less of the value of WANTT.) 

            //                If INFO .GT. 0 and WANTZ is .FALSE., then Z is not 
            //                accessed. 

            //     ================================================================ 
            //     Based on contributions by 
            //        Karen Braman and Ralph Byers, Department of Mathematics, 
            //        University of Kansas, USA 

            //     ================================================================ 
            //     References: 
            //       K. Braman, R. Byers and R. Mathias, The Multi-Shift QR 
            //       Algorithm Part I: Maintaining Well Focused Shifts, and Level 3 
            //       Performance, SIAM Journal of Matrix Analysis, volume 23, pages 
            //       929--947, 2002. 

            //       K. Braman, R. Byers and R. Mathias, The Multi-Shift QR 
            //       Algorithm Part II: Aggressive Early Deflation, SIAM Journal 
            //       of Matrix Analysis, volume 23, pages 948--973, 2002. 

            //     ================================================================ 
            //     .. Parameters .. 

            //     ==== Matrices of order NTINY or smaller must be processed by 
            //     .    ZLAHQR because of insufficient subdiagonal scratch space. 
            //     .    (This is a hard limit.) ==== 

            //     ==== Exceptional deflation windows:  try to cure rare 
            //     .    slow convergence by varying the size of the 
            //     .    deflation window after KEXNW iterations. ==== 

            //     ==== Exceptional shifts: try to cure rare slow convergence 
            //     .    with ad-hoc exceptional shifts every KEXSH iterations. 
            //     .    ==== 

            //     ==== The constant WILK1 is used to form the exceptional 
            //     .    shifts. ==== 

            // System generated locals 
            int h_dim1, h_offset, z_dim1, z_offset, i__1, i__2, i__3, i__4, i__5;
            double d__1, d__3;
            complex16 z__1, z__2, z__3, z__4, z__5;

            // Table of constant values
            int c__13 = 13;
            int c__15 = 15;
            int c_n1 = -1;
            int c__12 = 12;
            int c__14 = 14;
            int c__16 = 16;
            bool c_false = false;
            int c__1 = 1;
            int c__3 = 3;

            // Local variables 
            int i, k;
            double s;
            complex16 aa, bb, cc, dd;
            int ld, nh, it, ks, kt, ku, kv, ls, ns, nw;
            complex16 tr2, det;
            int inf, kdu, nho, nve, kwh, nsr, nwr, kwv, ndec = 0, ndfl, kbot, nmin;
            complex16 swap;
            int ktop;
            complex16[] zdum = new complex16[1]; // was [1][1] 
            int kacc22, itmax, nsmax, nwmax, kwtop;
            int nibble;
            string jbcmpz;
            complex16 rtdisc;
            int nwupbd;
            bool sorted;
            int lwkopt;

            // Parameter adjustments 
            h_dim1 = *ldh;
            h_offset = 1 + h_dim1;
            h -= h_offset;
            --w;
            z_dim1 = *ldz;
            z_offset = 1 + z_dim1;
            z -= z_offset;
            --work;

            // Function Body 
            *info = 0;

            // ==== Quick return for N = 0: nothing to do. ==== 

            if (*n == 0)
            {
                work[1].r = 1.0;
                work[1].i = 0.0;
                return 0;
            }

            if (*n <= 11)
            {
                // ==== Tiny matrices must use ZLAHQR. ==== 

                lwkopt = 1;
                if (*lwork != -1)
                {
                    zlahqr(wantt, wantz, n, ilo, ihi, &h[h_offset], ldh, &w[1],
                        iloz, ihiz, &z[z_offset], ldz, info);
                }
            }
            else
            {
                // ==== Use small bulge multi-shift QR with aggressive early 
                // .    deflation on larger-than-tiny matrices. ==== 

                // ==== Hope for the best. ==== 

                *info = 0;

                // ==== Set up job flags for ILAENV. ==== 

                if (*wantt)
                {
                    jbcmpz = "S";
                }
                else
                {
                    jbcmpz = "E";
                }
                if (*wantz)
                {
                    jbcmpz += 'V';
                }
                else
                {
                    jbcmpz += 'N';
                }

                // ==== NWR = recommended deflation window size.  At this 
                // .    point,  N .GT. NTINY = 11, so there is enough 
                // .    subdiagonal workspace for NWR.GE.2 as required. 
                // .    (In fact, there is enough subdiagonal space for 
                // .    NWR.GE.3.) ==== 

                nwr = ilaenv(&c__13, "ZLAQR4", jbcmpz, n, ilo, ihi, lwork);
                nwr = Math.Max(2, nwr);

                // Computing MIN 
                i__1 = *ihi - *ilo + 1;
                i__2 = (*n - 1) / 3;
                i__1 = Math.Min(i__1, i__2);

                nwr = Math.Min(i__1, nwr);

                // ==== NSR = recommended number of simultaneous shifts. 
                // .    At this point N .GT. NTINY = 11, so there is at 
                // .    enough subdiagonal workspace for NSR to be even 
                // .    and greater than or equal to two as required. ==== 

                nsr = ilaenv(&c__15, "ZLAQR4", jbcmpz, n, ilo, ihi, lwork);
                // Computing MIN 
                i__1 = nsr;
                i__2 = (*n + 6) / 9;
                i__1 = Math.Min(i__1, i__2);
                i__2 = *ihi - *ilo;
                nsr = Math.Min(i__1, i__2);
                // Computing MAX 
                i__1 = 2;
                i__2 = nsr - nsr % 2;
                nsr = Math.Max(i__1, i__2);

                // ==== Estimate optimal workspace ==== 

                // ==== Workspace query call to ZLAQR2 ==== 

                i__1 = nwr + 1;
                zlaqr2(wantt, wantz, n, ilo, ihi, &i__1, &h[h_offset], ldh, iloz,
                    ihiz, &z[z_offset], ldz, &ls, &ld, &w[1], &h[h_offset],
                    ldh, n, &h[h_offset], ldh, n, &h[h_offset], ldh, &work[1], &c_n1);

                // ==== Optimal workspace = MAX(ZLAQR5, ZLAQR2) ==== 

                // Computing MAX 
                i__1 = nsr * 3 / 2;
                i__2 = (int)work[1].r;
                lwkopt = Math.Max(i__1, i__2);

                // ==== Quick return in case of workspace query. ==== 

                if (*lwork == -1)
                {
                    d__1 = (double)lwkopt;

                    z__1.r = d__1;
                    z__1.i = 0.0;

                    work[1].r = z__1.r;
                    work[1].i = z__1.i;
                    return 0;
                }

                // ==== ZLAHQR/ZLAQR0 crossover point ==== 

                nmin = ilaenv(&c__12, "ZLAQR4", jbcmpz, n, ilo, ihi, lwork);
                nmin = Math.Max(11, nmin);

                // ==== Nibble crossover point ==== 

                nibble = ilaenv(&c__14, "ZLAQR4", jbcmpz, n, ilo, ihi, lwork);
                nibble = Math.Max(0, nibble);

                // ==== Accumulate reflections during ttswp?  Use block 
                // .    2-by-2 structure during matrix-matrix multiply? ==== 

                kacc22 = ilaenv(&c__16, "ZLAQR4", jbcmpz, n, ilo, ihi, lwork);
                kacc22 = Math.Max(0, kacc22);
                kacc22 = Math.Min(2, kacc22);

                // ==== NWMAX = the largest possible deflation window for 
                // .    which there is sufficient workspace. ==== 

                // Computing MIN 
                i__1 = (*n - 1) / 3;
                i__2 = *lwork / 2;
                nwmax = Math.Min(i__1, i__2);
                nw = nwmax;

                // ==== NSMAX = the Largest number of simultaneous shifts 
                // .    for which there is sufficient workspace. ==== 

                // Computing MIN 
                i__1 = (*n + 6) / 9;
                i__2 = (*lwork << 1) / 3;
                nsmax = Math.Min(i__1, i__2);
                nsmax -= nsmax % 2;

                // ==== NDFL: an iteration count restarted at deflation. ==== 

                ndfl = 1;

                // ==== ITMAX = iteration limit ==== 

                // Computing MAX 
                i__1 = 10;
                i__2 = *ihi - *ilo + 1;
                itmax = Math.Max(i__1, i__2) * 30;

                // ==== Last row and column in the active block ==== 

                kbot = *ihi;

                // ==== Main Loop ==== 

                i__1 = itmax;
                for (it = 1; it <= i__1; ++it)
                {
                    // ==== Done when KBOT falls below ILO ==== 

                    if (kbot < *ilo)
                    {
                        goto L80;
                    }

                    // ==== Locate active block ==== 

                    i__2 = *ilo + 1;
                    for (k = kbot; k >= i__2; --k)
                    {
                        i__3 = k + (k - 1) * h_dim1;
                        if (h[i__3].r == 0.0 && h[i__3].i == 0.0)
                        {
                            goto L20;
                        }
                    }
                    k = *ilo;
                L20:
                    ktop = k;

                    // ==== Select deflation window size: 
                    // .    Typical Case: 
                    // .      If possible and advisable, nibble the entire 
                    // .      active block.  If not, use size MIN(NWR,NWMAX) 
                    // .      or MIN(NWR+1,NWMAX) depending upon which has 
                    // .      the smaller corresponding subdiagonal entry 
                    // .      (a heuristic). 
                    // . 
                    // .    Exceptional Case: 
                    // .      If there have been no deflations in KEXNW or 
                    // .      more iterations, then vary the deflation window 
                    // .      size.   At first, because, larger windows are, 
                    // .      in general, more powerful than smaller ones, 
                    // .      rapidly increase the window to the maximum possible. 
                    // .      Then, gradually reduce the window size. ==== 

                    nh = kbot - ktop + 1;
                    nwupbd = Math.Min(nh, nwmax);
                    if (ndfl < 5)
                    {
                        nw = Math.Min(nwupbd, nwr);
                    }
                    else
                    {
                        // Computing MIN 
                        i__2 = nwupbd;
                        i__3 = nw << 1;
                        nw = Math.Min(i__2, i__3);
                    }
                    if (nw < nwmax)
                    {
                        if (nw >= nh - 1)
                        {
                            nw = nh;
                        }
                        else
                        {
                            kwtop = kbot - nw + 1;
                            i__2 = kwtop + (kwtop - 1) * h_dim1;
                            i__3 = kwtop - 1 + (kwtop - 2) * h_dim1;
                            if (Math.Abs(h[i__2].r) + Math.Abs(d_imag(&h[kwtop + (kwtop - 1) * h_dim1])) > Math.Abs(h[i__3].r) +
                                Math.Abs(d_imag(&h[kwtop - 1 + (kwtop - 2) * h_dim1])))
                            {
                                ++nw;
                            }
                        }
                    }
                    if (ndfl < 5)
                    {
                        ndec = -1;
                    }
                    else if (ndec >= 0 || nw >= nwupbd)
                    {
                        ++ndec;
                        if (nw - ndec < 2)
                        {
                            ndec = 0;
                        }
                        nw -= ndec;
                    }

                    // ==== Aggressive early deflation: 
                    // .    split workspace under the subdiagonal into 
                    // .      - an nw-by-nw work array V in the lower 
                    // .        left-hand-corner, 
                    // .      - an NW-by-at-least-NW-but-more-is-better 
                    // .        (NW-by-NHO) horizontal work array aint 
                    // .        the bottom edge, 
                    // .      - an at-least-NW-but-more-is-better (NHV-by-NW) 
                    // .        vertical work array aint the left-hand-edge. 
                    // .        ==== 

                    kv = *n - nw + 1;
                    kt = nw + 1;
                    nho = *n - nw - 1 - kt + 1;
                    kwv = nw + 2;
                    nve = *n - nw - kwv + 1;

                    // ==== Aggressive early deflation ==== 

                    zlaqr2(wantt, wantz, n, &ktop, &kbot, &nw, &h[h_offset], ldh,
                        iloz, ihiz, &z[z_offset], ldz, &ls, &ld, &w[1], &h[kv
                        + h_dim1], ldh, &nho, &h[kv + kt * h_dim1], ldh, &nve, &
                        h[kwv + h_dim1], ldh, &work[1], lwork);

                    // ==== Adjust KBOT accounting for new deflations. ==== 

                    kbot -= ld;

                    // ==== KS points to the shifts. ==== 

                    ks = kbot - ls + 1;

                    // ==== Skip an expensive QR sweep if there is a (partly 
                    // .    heuristic) reason to expect that many eigenvalues 
                    // .    will deflate without it.  Here, the QR sweep is 
                    // .    skipped if many eigenvalues have just been deflated 
                    // .    or if the remaining active block is small. 

                    if (ld == 0 || ld * 100 <= nw * nibble && kbot - ktop + 1 > Math.Min(nmin, nwmax))
                    {
                        // ==== NS = nominal number of simultaneous shifts. 
                        // .    This may be lowered (slightly) if ZLAQR2 
                        // .    did not provide that many shifts. ==== 

                        // Computing MIN 
                        // Computing MAX 
                        i__4 = 2;
                        i__5 = kbot - ktop;
                        i__2 = Math.Min(nsmax, nsr);
                        i__3 = Math.Max(i__4, i__5);
                        ns = Math.Min(i__2, i__3);
                        ns -= ns % 2;

                        // ==== If there have been no deflations 
                        // .    in a multiple of KEXSH iterations, 
                        // .    then try exceptional shifts. 
                        // .    Otherwise use shifts provided by 
                        // .    ZLAQR2 above or from the eigenvalues 
                        // .    of a trailing principal submatrix. ==== 

                        if (ndfl % 6 == 0)
                        {
                            ks = kbot - ns + 1;
                            i__2 = ks + 1;
                            for (i = kbot; i >= i__2; i += -2)
                            {
                                i__3 = i;
                                i__4 = i + i * h_dim1;
                                i__5 = i + (i - 1) * h_dim1;
                                d__3 = (Math.Abs(h[i__5].r) + Math.Abs(d_imag(&h[i + (i - 1) * h_dim1]))) * 0.75;

                                z__1.r = h[i__4].r + d__3;
                                z__1.i = h[i__4].i;

                                w[i__3].r = z__1.r;
                                w[i__3].i = z__1.i;
                                i__3 = i - 1;
                                i__4 = i;
                                w[i__3].r = w[i__4].r;
                                w[i__3].i = w[i__4].i;
                            }
                        }
                        else
                        {
                            // ==== Got NS/2 or fewer shifts? Use ZLAHQR 
                            // .    on a trailing principal submatrix to 
                            // .    get more. (Since NS.LE.NSMAX.LE.(N+6)/9, 
                            // .    there is enough space below the subdiagonal 
                            // .    to fit an NS-by-NS scratch array.) ==== 

                            if (kbot - ks + 1 <= ns / 2)
                            {
                                ks = kbot - ns + 1;
                                kt = *n - ns + 1;
                                zlacpy("A", &ns, &ns, &h[ks + ks * h_dim1], ldh, &h[kt + h_dim1], ldh);
                                zlahqr(&c_false, &c_false, &ns, &c__1, &ns, &h[kt + h_dim1],
                                    ldh, &w[ks], &c__1, &c__1, zdum, &c__1, &inf);

                                ks += inf;

                                // ==== In case of a rare QR failure use 
                                // .    eigenvalues of the trailing 2-by-2 
                                // .    principal submatrix.  Scale to avoid 
                                // .    overflows, underflows and subnormals. 
                                // .    (The scale factor S can not be zero, 
                                // .    because H(KBOT,KBOT-1) is nonzero.) ==== 

                                if (ks >= kbot)
                                {
                                    i__2 = kbot - 1 + (kbot - 1) * h_dim1;
                                    i__3 = kbot + (kbot - 1) * h_dim1;
                                    i__4 = kbot - 1 + kbot * h_dim1;
                                    i__5 = kbot + kbot * h_dim1;
                                    s = Math.Abs(h[i__2].r) + Math.Abs(d_imag(&h[kbot - 1 + (kbot - 1) * h_dim1])) +
                                        (Math.Abs(h[i__3].r) + Math.Abs(d_imag(&h[kbot + (kbot - 1) * h_dim1]))) +
                                        (Math.Abs(h[i__4].r) + Math.Abs(d_imag(&h[kbot - 1 + kbot * h_dim1]))) +
                                        (Math.Abs(h[i__5].r) + Math.Abs(d_imag(&h[kbot + kbot * h_dim1])));

                                    i__2 = kbot - 1 + (kbot - 1) * h_dim1;
                                    z__1.r = h[i__2].r / s;
                                    z__1.i = h[i__2].i / s;
                                    aa.r = z__1.r;
                                    aa.i = z__1.i;
                                    i__2 = kbot + (kbot - 1) * h_dim1;

                                    z__1.r = h[i__2].r / s;
                                    z__1.i = h[i__2].i / s;

                                    cc.r = z__1.r;
                                    cc.i = z__1.i;

                                    i__2 = kbot - 1 + kbot * h_dim1;
                                    z__1.r = h[i__2].r / s;
                                    z__1.i = h[i__2].i / s;

                                    bb.r = z__1.r;
                                    bb.i = z__1.i;
                                    i__2 = kbot + kbot * h_dim1;

                                    z__1.r = h[i__2].r / s;
                                    z__1.i = h[i__2].i / s;

                                    dd.r = z__1.r;
                                    dd.i = z__1.i;

                                    z__2.r = aa.r + dd.r;
                                    z__2.i = aa.i + dd.i;

                                    z__1.r = z__2.r / 2.0;
                                    z__1.i = z__2.i / 2.0;

                                    tr2.r = z__1.r;
                                    tr2.i = z__1.i;

                                    z__3.r = aa.r - tr2.r;
                                    z__3.i = aa.i - tr2.i;

                                    z__4.r = dd.r - tr2.r;
                                    z__4.i = dd.i - tr2.i;

                                    z__2.r = z__3.r * z__4.r - z__3.i * z__4.i;
                                    z__2.i = z__3.r * z__4.i + z__3.i * z__4.r;

                                    z__5.r = bb.r * cc.r - bb.i * cc.i;
                                    z__5.i = bb.r * cc.i + bb.i * cc.r;

                                    z__1.r = z__2.r - z__5.r;
                                    z__1.i = z__2.i - z__5.i;

                                    det.r = z__1.r;
                                    det.i = z__1.i;

                                    z__2.r = -det.r;
                                    z__2.i = -det.i;

                                    z_sqrt(&z__1, &z__2);

                                    rtdisc.r = z__1.r;
                                    rtdisc.i = z__1.i;

                                    i__2 = kbot - 1;

                                    z__2.r = tr2.r + rtdisc.r;
                                    z__2.i = tr2.i + rtdisc.i;

                                    z__1.r = s * z__2.r;
                                    z__1.i = s * z__2.i;

                                    w[i__2].r = z__1.r;
                                    w[i__2].i = z__1.i;

                                    i__2 = kbot;

                                    z__2.r = tr2.r - rtdisc.r;
                                    z__2.i = tr2.i - rtdisc.i;

                                    z__1.r = s * z__2.r;
                                    z__1.i = s * z__2.i;

                                    w[i__2].r = z__1.r;
                                    w[i__2].i = z__1.i;

                                    ks = kbot - 1;
                                }
                            }

                            if (kbot - ks + 1 > ns)
                            {
                                // ==== Sort the shifts (Helps a little) ==== 

                                sorted = false;
                                i__2 = ks + 1;

                                for (k = kbot; k >= i__2; --k)
                                {
                                    if (sorted)
                                    {
                                        goto L60;
                                    }
                                    sorted = true;
                                    i__3 = k - 1;
                                    for (i = ks; i <= i__3; ++i)
                                    {
                                        i__4 = i;
                                        i__5 = i + 1;

                                        if (Math.Abs(w[i__4].r) + Math.Abs(d_imag(&w[i])) < Math.Abs(w[i__5].r) + Math.Abs(d_imag(&w[i + 1])))
                                        {
                                            sorted = false;
                                            i__4 = i;

                                            swap.r = w[i__4].r;
                                            swap.i = w[i__4].i;

                                            i__4 = i;
                                            i__5 = i + 1;
                                            w[i__4].r = w[i__5].r;
                                            w[i__4].i = w[i__5].i;

                                            i__4 = i + 1;

                                            w[i__4].r = swap.r;
                                            w[i__4].i = swap.i;
                                        }
                                    }
                                }
                            L60:
                                ;
                            }
                        }

                        // ==== If there are only two shifts, then use 
                        // .    only one.  ==== 

                        if (kbot - ks + 1 == 2)
                        {
                            i__2 = kbot;
                            i__3 = kbot + kbot * h_dim1;

                            z__2.r = w[i__2].r - h[i__3].r;
                            z__2.i = w[i__2].i - h[i__3].i;

                            z__1.r = z__2.r;
                            z__1.i = z__2.i;

                            i__4 = kbot - 1;
                            i__5 = kbot + kbot * h_dim1;

                            z__4.r = w[i__4].r - h[i__5].r;
                            z__4.i = w[i__4].i - h[i__5].i;

                            z__3.r = z__4.r;
                            z__3.i = z__4.i;

                            if (Math.Abs(z__1.r) + Math.Abs(d_imag(&z__1)) < Math.Abs(z__3.r) + Math.Abs(d_imag(&z__3)))
                            {
                                i__2 = kbot - 1;
                                i__3 = kbot;

                                w[i__2].r = w[i__3].r;
                                w[i__2].i = w[i__3].i;
                            }
                            else
                            {
                                i__2 = kbot;
                                i__3 = kbot - 1;

                                w[i__2].r = w[i__3].r;
                                w[i__2].i = w[i__3].i;
                            }
                        }

                        // ==== Use up to NS of the the smallest magnatiude 
                        // .    shifts.  If there aren't NS shifts available, 
                        // .    then use them all, possibly dropping one to 
                        // .    make the number of shifts even. ==== 

                        // Computing MIN 
                        i__2 = ns;
                        i__3 = kbot - ks + 1;
                        ns = Math.Min(i__2, i__3);
                        ns -= ns % 2;
                        ks = kbot - ns + 1;

                        // ==== Small-bulge multi-shift QR sweep: 
                        // .    split workspace under the subdiagonal into 
                        // .    - a KDU-by-KDU work array U in the lower 
                        // .      left-hand-corner, 
                        // .    - a KDU-by-at-least-KDU-but-more-is-better 
                        // .      (KDU-by-NHo) horizontal work array WH aint 
                        // .      the bottom edge, 
                        // .    - and an at-least-KDU-but-more-is-better-by-KDU 
                        // .      (NVE-by-KDU) vertical work WV arrow aint 
                        // .      the left-hand-edge. ==== 

                        kdu = ns * 3 - 3;
                        ku = *n - kdu + 1;
                        kwh = kdu + 1;
                        nho = *n - kdu - 3 - (kdu + 1) + 1;
                        kwv = kdu + 4;
                        nve = *n - kdu - kwv + 1;

                        // ==== Small-bulge multi-shift QR sweep ==== 

                        zlaqr5(wantt, wantz, &kacc22, n, &ktop, &kbot, &ns, &w[ks], &
                            h[h_offset], ldh, iloz, ihiz, &z[z_offset], ldz, &
                            work[1], &c__3, &h[ku + h_dim1], ldh, &nve, &h[
                            kwv + h_dim1], ldh, &nho, &h[ku + kwh * h_dim1],
                            ldh);
                    }

                    // ==== Note progress (or the lack of it). ==== 

                    if (ld > 0)
                    {
                        ndfl = 1;
                    }
                    else
                    {
                        ++ndfl;
                    }

                    // ==== End of main loop ==== 
                }

                // ==== Iteration limit exceeded.  Set INFO to show where 
                // .    the problem occurred and exit. ==== 

                *info = kbot;
            L80:
                ;
            }

            // ==== Return the optimal value of LWORK. ==== 

            d__1 = (double)lwkopt;
            z__1.r = d__1;
            z__1.i = 0.0;

            work[1].r = z__1.r;
            work[1].i = z__1.i;

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zlaqr5(bool* wantt, bool* wantz, int* kacc22,
            int* n, int* ktop, int* kbot, int* nshfts,
            complex16* s, complex16* h, int* ldh, int* iloz,
            int* ihiz, complex16* z, int* ldz, complex16* v,
            int* ldv, complex16* u, int* ldu, int* nv,
            complex16* wv, int* ldwv, int* nh, complex16* wh, int* ldwh)
        {
            //  -- LAPACK auxiliary routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd.. 
            //     November 2006 

            //     This auxiliary subroutine called by ZLAQR0 performs a 
            //     single small-bulge multi-shift QR sweep. 

            //      WANTT  (input) bool scalar 
            //             WANTT = .true. if the triangular Schur factor 
            //             is being computed.  WANTT is set to .false. otherwise. 

            //      WANTZ  (input) bool scalar 
            //             WANTZ = .true. if the unitary Schur factor is being 
            //             computed.  WANTZ is set to .false. otherwise. 

            //      KACC22 (input) int with value 0, 1, or 2. 
            //             Specifies the computation mode of far-from-diagonal 
            //             orthogonal updates. 
            //        = 0: ZLAQR5 does not accumulate reflections and does not 
            //             use matrix-matrix multiply to update far-from-diagonal 
            //             matrix entries. 
            //        = 1: ZLAQR5 accumulates reflections and uses matrix-matrix 
            //             multiply to update the far-from-diagonal matrix entries. 
            //        = 2: ZLAQR5 accumulates reflections, uses matrix-matrix 
            //             multiply to update the far-from-diagonal matrix entries, 
            //             and takes advantage of 2-by-2 block structure during 
            //             matrix multiplies. 

            //      N      (input) int scalar 
            //             N is the order of the Hessenberg matrix H upon which this 
            //             subroutine operates. 

            //      KTOP   (input) int scalar 
            //      KBOT   (input) int scalar 
            //             These are the first and last rows and columns of an 
            //             isolated diagonal block upon which the QR sweep is to be 
            //             applied. It is assumed without a check that 
            //                       either KTOP = 1  or   H(KTOP,KTOP-1) = 0 
            //             and 
            //                       either KBOT = N  or   H(KBOT+1,KBOT) = 0. 

            //      NSHFTS (input) int scalar 
            //             NSHFTS gives the number of simultaneous shifts.  NSHFTS 
            //             must be positive and even. 

            //      S      (input/output) COMPLEX*16 array of size (NSHFTS) 
            //             S contains the shifts of origin that define the multi- 
            //             shift QR sweep.  On output S may be reordered. 

            //      H      (input/output) COMPLEX*16 array of size (LDH,N) 
            //             On input H contains a Hessenberg matrix.  On output a 
            //             multi-shift QR sweep with shifts SR(J)+i*SI(J) is applied 
            //             to the isolated diagonal block in rows and columns KTOP 
            //             through KBOT. 

            //      LDH    (input) int scalar 
            //             LDH is the leading dimension of H just as declared in the 
            //             calling procedure.  LDH.GE.MAX(1,N). 

            //      ILOZ   (input) int 
            //      IHIZ   (input) int 
            //             Specify the rows of Z to which transformations must be 
            //             applied if WANTZ is .TRUE.. 1 .LE. ILOZ .LE. IHIZ .LE. N 

            //      Z      (input/output) COMPLEX*16 array of size (LDZ,IHI) 
            //             If WANTZ = .TRUE., then the QR Sweep unitary 
            //             similarity transformation is accumulated into 
            //             Z(ILOZ:IHIZ,ILO:IHI) from the right. 
            //             If WANTZ = .FALSE., then Z is unreferenced. 

            //      LDZ    (input) int scalar 
            //             LDA is the leading dimension of Z just as declared in 
            //             the calling procedure. LDZ.GE.N. 

            //      V      (workspace) COMPLEX*16 array of size (LDV,NSHFTS/2) 

            //      LDV    (input) int scalar 
            //             LDV is the leading dimension of V as declared in the 
            //             calling procedure.  LDV.GE.3. 

            //      U      (workspace) COMPLEX*16 array of size 
            //             (LDU,3*NSHFTS-3) 

            //      LDU    (input) int scalar 
            //             LDU is the leading dimension of U just as declared in the 
            //             in the calling subroutine.  LDU.GE.3*NSHFTS-3. 

            //      NH     (input) int scalar 
            //             NH is the number of columns in array WH available for 
            //             workspace. NH.GE.1. 

            //      WH     (workspace) COMPLEX*16 array of size (LDWH,NH) 

            //      LDWH   (input) int scalar 
            //             Leading dimension of WH just as declared in the 
            //             calling procedure.  LDWH.GE.3*NSHFTS-3. 

            //      NV     (input) int scalar 
            //             NV is the number of rows in WV agailable for workspace. 
            //             NV.GE.1. 

            //      WV     (workspace) COMPLEX*16 array of size 
            //             (LDWV,3*NSHFTS-3) 

            //      LDWV   (input) int scalar 
            //             LDWV is the leading dimension of WV as declared in the 
            //             in the calling subroutine.  LDWV.GE.NV. 

            //     ================================================================ 
            //     Based on contributions by 
            //        Karen Braman and Ralph Byers, Department of Mathematics, 
            //        University of Kansas, USA 

            //     ================================================================ 
            //     Reference: 

            //     K. Braman, R. Byers and R. Mathias, The Multi-Shift QR 
            //     Algorithm Part I: Maintaining Well Focused Shifts, and 
            //     Level 3 Performance, SIAM Journal of Matrix Analysis, 
            //     volume 23, pages 929--947, 2002. 

            //     ================================================================ 

            //     ==== If there are no shifts, then there is nothing to do. ==== 

            // System generated locals 
            int h_dim1, h_offset, u_dim1, u_offset, v_dim1, v_offset, wh_dim1,
                wh_offset, wv_dim1, wv_offset, z_dim1, z_offset, i__1, i__2, i__3,
                 i__4, i__5, i__6, i__7, i__8, i__9, i__10, i__11;
            double d__1, d__2, d__3, d__4, d__5, d__6;
            complex16 z__1, z__2, z__3, z__4, z__5, z__6, z__7, z__8;

            // Table of constant values
            complex16 c_b1 = new complex16(0.0, 0.0);
            complex16 c_b2 = new complex16(1.0, 0.0);
            int c__3 = 3;
            int c__1 = 1;
            int c__2 = 2;

            // Local variables 
            int j, k, m, i2, j2, i4, j4, k1;
            double h11, h12, h21, h22;
            int m22, ns, nu;
            complex16[] vt = new complex16[3];
            double scl;
            int kdu, kms;
            double ulp;
            int knz, kzs;
            double tst1, tst2;
            complex16 beta;
            bool blk22, bmp22;
            int mend, jcol, jlen, jbot, mbot, jtop, jrow, mtop;
            complex16 alpha;
            bool accum;
            int ndcol, incol, krcol, nbmps;
            double safmin, safmax;
            complex16 refsum;
            int mstart;
            double smlnum;

            // Parameter adjustments 
            --s;
            h_dim1 = *ldh;
            h_offset = 1 + h_dim1;
            h -= h_offset;
            z_dim1 = *ldz;
            z_offset = 1 + z_dim1;
            z -= z_offset;
            v_dim1 = *ldv;
            v_offset = 1 + v_dim1;
            v -= v_offset;
            u_dim1 = *ldu;
            u_offset = 1 + u_dim1;
            u -= u_offset;
            wv_dim1 = *ldwv;
            wv_offset = 1 + wv_dim1;
            wv -= wv_offset;
            wh_dim1 = *ldwh;
            wh_offset = 1 + wh_dim1;
            wh -= wh_offset;

            // Function Body 
            if (*nshfts < 2)
            {
                return 0;
            }

            // ==== If the active block is empty or 1-by-1, then there 
            // .    is nothing to do. ==== 

            if (*ktop >= *kbot)
            {
                return 0;
            }

            // ==== NSHFTS is supposed to be even, but if it is odd, 
            // .    then simply reduce it by one.  ==== 

            ns = *nshfts - *nshfts % 2;

            // ==== Machine constants for deflation ==== 

            safmin = dlamch("SAFE MINIMUM");
            safmax = 1.0 / safmin;
            dlabad(&safmin, &safmax);
            ulp = dlamch("PRECISION");
            smlnum = safmin * ((double)(*n) / ulp);

            // ==== Use accumulated reflections to update far-from-diagonal 
            // .    entries ? ==== 

            accum = *kacc22 == 1 || *kacc22 == 2;

            // ==== If so, exploit the 2-by-2 block structure? ==== 

            blk22 = ns > 2 && *kacc22 == 2;

            // ==== clear trash ==== 

            if (*ktop + 2 <= *kbot)
            {
                i__1 = *ktop + 2 + *ktop * h_dim1;

                h[i__1].r = 0.0;
                h[i__1].i = 0.0;
            }

            // ==== NBMPS = number of 2-shift bulges in the chain ==== 

            nbmps = ns / 2;

            // ==== KDU = width of slab ==== 

            kdu = nbmps * 6 - 3;

            // ==== Create and chase chains of NBMPS bulges ==== 

            i__1 = *kbot - 2;
            i__2 = nbmps * 3 - 2;

            for (incol = (1 - nbmps) * 3 + *ktop - 1; i__2 < 0 ? incol >= i__1 : incol <= i__1; incol += i__2)
            {
                ndcol = incol + kdu;
                if (accum)
                {
                    zlaset("ALL", &kdu, &kdu, &c_b1, &c_b2, &u[u_offset], ldu);
                }

                // ==== Near-the-diagonal bulge chase.  The following loop 
                // .    performs the near-the-diagonal part of a small bulge 
                // .    multi-shift QR sweep.  Each 6*NBMPS-2 column diagonal 
                // .    chunk extends from column INCOL to column NDCOL 
                // .    (including both column INCOL and column NDCOL). The 
                // .    following loop chases a 3*NBMPS column int chain of 
                // .    NBMPS bulges 3*NBMPS-2 columns to the right.  (INCOL 
                // .    may be less than KTOP and and NDCOL may be greater than 
                // .    KBOT indicating phantom columns from which to chase 
                // .    bulges before they are actually introduced or to which 
                // .    to chase bulges beyond column KBOT.)  ==== 

                // Computing MIN 
                i__4 = incol + nbmps * 3 - 3;
                i__5 = *kbot - 2;

                i__3 = Math.Min(i__4, i__5);
                for (krcol = incol; krcol <= i__3; ++krcol)
                {
                    // ==== Bulges number MTOP to MBOT are active double implicit 
                    // .    shift bulges.  There may or may not also be small 
                    // .    2-by-2 bulge, if there is room.  The inactive bulges 
                    // .    (if any) must wait until the active bulges have moved 
                    // .    down the diagonal to make room.  The phantom matrix 
                    // .    paradigm described above helps keep track.  ==== 

                    // Computing MAX 
                    i__4 = 1;
                    i__5 = (*ktop - 1 - krcol + 2) / 3 + 1;
                    mtop = Math.Max(i__4, i__5);
                    // Computing MIN 
                    i__4 = nbmps;
                    i__5 = (*kbot - krcol) / 3;
                    mbot = Math.Min(i__4, i__5);
                    m22 = mbot + 1;
                    bmp22 = mbot < nbmps && krcol + (m22 - 1) * 3 == *kbot - 2;

                    // ==== Generate reflections to chase the chain right 
                    // .    one column.  (The minimum value of K is KTOP-1.) ==== 

                    i__4 = mbot;
                    for (m = mtop; m <= i__4; ++m)
                    {
                        k = krcol + (m - 1) * 3;
                        if (k == *ktop - 1)
                        {
                            zlaqr1(&c__3, &h[*ktop + *ktop * h_dim1], ldh, &s[(m << 1) - 1], &s[m * 2], &v[m * v_dim1 + 1]);
                            i__5 = m * v_dim1 + 1;

                            alpha.r = v[i__5].r;
                            alpha.i = v[i__5].i;

                            zlarfg(&c__3, &alpha, &v[m * v_dim1 + 2], &c__1, &v[m * v_dim1 + 1]);

                        }
                        else
                        {
                            i__5 = k + 1 + k * h_dim1;

                            beta.r = h[i__5].r;
                            beta.i = h[i__5].i;

                            i__5 = m * v_dim1 + 2;
                            i__6 = k + 2 + k * h_dim1;

                            v[i__5].r = h[i__6].r;
                            v[i__5].i = h[i__6].i;

                            i__5 = m * v_dim1 + 3;
                            i__6 = k + 3 + k * h_dim1;

                            v[i__5].r = h[i__6].r;
                            v[i__5].i = h[i__6].i;

                            zlarfg(&c__3, &beta, &v[m * v_dim1 + 2], &c__1, &v[m * v_dim1 + 1]);

                            // ==== A Bulge may collapse because of vigilant 
                            // .    deflation or destructive underflow.  In the 
                            // .    underflow case, try the two-small-subdiagonals 
                            // .    trick to try to reinflate the bulge.  ==== 

                            i__5 = k + 3 + k * h_dim1;
                            i__6 = k + 3 + (k + 1) * h_dim1;
                            i__7 = k + 3 + (k + 2) * h_dim1;
                            if (h[i__5].r != 0.0 || h[i__5].i != 0.0 || (h[i__6].r != 0.0 ||
                                h[i__6].i != 0.0) || h[i__7].r == 0.0 && h[i__7].i == 0.0)
                            {
                                // ==== Typical case: not collapsed (yet). ==== 

                                i__5 = k + 1 + k * h_dim1;

                                h[i__5].r = beta.r;
                                h[i__5].i = beta.i;

                                i__5 = k + 2 + k * h_dim1;

                                h[i__5].r = 0.0;
                                h[i__5].i = 0.0;

                                i__5 = k + 3 + k * h_dim1;
                                h[i__5].r = 0.0;
                                h[i__5].i = 0.0;
                            }
                            else
                            {
                                // ==== Atypical case: collapsed.  Attempt to 
                                // .    reintroduce ignoring H(K+1,K) and H(K+2,K). 
                                // .    If the fill resulting from the new 
                                // .    reflector is too large, then abandon it. 
                                // .    Otherwise, use the new one. ==== 

                                zlaqr1(&c__3, &h[k + 1 + (k + 1) * h_dim1], ldh, &s[(m << 1) - 1], &s[m * 2], vt);

                                alpha.r = vt[0].r;
                                alpha.i = vt[0].i;

                                zlarfg(&c__3, &alpha, &vt[1], &c__1, vt);
                                d_cnjg(&z__2, vt);

                                i__5 = k + 1 + k * h_dim1;
                                d_cnjg(&z__5, &vt[1]);
                                i__6 = k + 2 + k * h_dim1;

                                z__4.r = z__5.r * h[i__6].r - z__5.i * h[i__6].i;
                                z__4.i = z__5.r * h[i__6].i + z__5.i * h[i__6].r;

                                z__3.r = h[i__5].r + z__4.r;
                                z__3.i = h[i__5].i + z__4.i;

                                z__1.r = z__2.r * z__3.r - z__2.i * z__3.i;
                                z__1.i = z__2.r * z__3.i + z__2.i * z__3.r;

                                refsum.r = z__1.r;
                                refsum.i = z__1.i;

                                i__5 = k + 2 + k * h_dim1;

                                z__3.r = refsum.r * vt[1].r - refsum.i * vt[1].i;
                                z__3.i = refsum.r * vt[1].i + refsum.i * vt[1].r;

                                z__2.r = h[i__5].r - z__3.r;
                                z__2.i = h[i__5].i - z__3.i;

                                z__1.r = z__2.r;
                                z__1.i = z__2.i;

                                z__5.r = refsum.r * vt[2].r - refsum.i * vt[2].i;
                                z__5.i = refsum.r * vt[2].i + refsum.i * vt[2].r;

                                z__4.r = z__5.r;
                                z__4.i = z__5.i;

                                i__6 = k + k * h_dim1;
                                i__7 = k + 1 + (k + 1) * h_dim1;
                                i__8 = k + 2 + (k + 2) * h_dim1;

                                if (Math.Abs(z__1.r) + Math.Abs(d_imag(&z__1)) + (Math.Abs(z__4.r) + Math.Abs(d_imag(&z__4))) > ulp * (Math.Abs(h[i__6].r) +
                                    Math.Abs(d_imag(&h[k + k * h_dim1])) + (Math.Abs(h[i__7].r) +
                                    Math.Abs(d_imag(&h[k + 1 + (k + 1) * h_dim1]))) +
                                    (Math.Abs(h[i__8].r) + Math.Abs(d_imag(&h[k + 2 + (k + 2) * h_dim1])))))
                                {
                                    // ==== Starting a new bulge here would 
                                    // .    create non-negligible fill.  Use 
                                    // .    the old one with trepidation. ==== 

                                    i__5 = k + 1 + k * h_dim1;
                                    h[i__5].r = beta.r;
                                    h[i__5].i = beta.i;

                                    i__5 = k + 2 + k * h_dim1;

                                    h[i__5].r = 0.0;
                                    h[i__5].i = 0.0;

                                    i__5 = k + 3 + k * h_dim1;

                                    h[i__5].r = 0.0;
                                    h[i__5].i = 0.0;
                                }
                                else
                                {
                                    // ==== Stating a new bulge here would 
                                    // .    create only negligible fill. 
                                    // .    Replace the old reflector with 
                                    // .    the new one. ==== 

                                    i__5 = k + 1 + k * h_dim1;
                                    i__6 = k + 1 + k * h_dim1;

                                    z__1.r = h[i__6].r - refsum.r;
                                    z__1.i = h[i__6].i - refsum.i;

                                    h[i__5].r = z__1.r;
                                    h[i__5].i = z__1.i;

                                    i__5 = k + 2 + k * h_dim1;

                                    h[i__5].r = 0.0;
                                    h[i__5].i = 0.0;

                                    i__5 = k + 3 + k * h_dim1;

                                    h[i__5].r = 0.0;
                                    h[i__5].i = 0.0;

                                    i__5 = m * v_dim1 + 1;

                                    v[i__5].r = vt[0].r;
                                    v[i__5].i = vt[0].i;

                                    i__5 = m * v_dim1 + 2;

                                    v[i__5].r = vt[1].r;
                                    v[i__5].i = vt[1].i;

                                    i__5 = m * v_dim1 + 3;

                                    v[i__5].r = vt[2].r;
                                    v[i__5].i = vt[2].i;
                                }
                            }
                        }
                    }

                    // ==== Generate a 2-by-2 reflection, if needed. ==== 

                    k = krcol + (m22 - 1) * 3;
                    if (bmp22)
                    {
                        if (k == *ktop - 1)
                        {
                            zlaqr1(&c__2, &h[k + 1 + (k + 1) * h_dim1], ldh, &s[(m22 << 1) - 1], &s[m22 * 2], &v[m22 * v_dim1 + 1]);
                            i__4 = m22 * v_dim1 + 1;

                            beta.r = v[i__4].r;
                            beta.i = v[i__4].i;

                            zlarfg(&c__2, &beta, &v[m22 * v_dim1 + 2], &c__1, &v[m22 * v_dim1 + 1]);
                        }
                        else
                        {
                            i__4 = k + 1 + k * h_dim1;

                            beta.r = h[i__4].r;
                            beta.i = h[i__4].i;

                            i__4 = m22 * v_dim1 + 2;
                            i__5 = k + 2 + k * h_dim1;

                            v[i__4].r = h[i__5].r;
                            v[i__4].i = h[i__5].i;

                            zlarfg(&c__2, &beta, &v[m22 * v_dim1 + 2], &c__1, &v[m22 * v_dim1 + 1]);
                            i__4 = k + 1 + k * h_dim1;

                            h[i__4].r = beta.r;
                            h[i__4].i = beta.i;

                            i__4 = k + 2 + k * h_dim1;

                            h[i__4].r = 0.0;
                            h[i__4].i = 0.0;
                        }
                    }

                    // ==== Multiply H by reflections from the left ==== 

                    if (accum)
                    {
                        jbot = Math.Min(ndcol, *kbot);
                    }
                    else if (*wantt)
                    {
                        jbot = *n;
                    }
                    else
                    {
                        jbot = *kbot;
                    }
                    i__4 = jbot;
                    for (j = Math.Max(*ktop, krcol); j <= i__4; ++j)
                    {
                        // Computing MIN 
                        i__5 = mbot;
                        i__6 = (j - krcol + 2) / 3;
                        mend = Math.Min(i__5, i__6);
                        i__5 = mend;
                        for (m = mtop; m <= i__5; ++m)
                        {
                            k = krcol + (m - 1) * 3;
                            d_cnjg(&z__2, &v[m * v_dim1 + 1]);
                            i__6 = k + 1 + j * h_dim1;
                            d_cnjg(&z__6, &v[m * v_dim1 + 2]);
                            i__7 = k + 2 + j * h_dim1;

                            z__5.r = z__6.r * h[i__7].r - z__6.i * h[i__7].i;
                            z__5.i = z__6.r * h[i__7].i + z__6.i * h[i__7].r;

                            z__4.r = h[i__6].r + z__5.r;
                            z__4.i = h[i__6].i + z__5.i;

                            d_cnjg(&z__8, &v[m * v_dim1 + 3]);
                            i__8 = k + 3 + j * h_dim1;

                            z__7.r = z__8.r * h[i__8].r - z__8.i * h[i__8].i;
                            z__7.i = z__8.r * h[i__8].i + z__8.i * h[i__8].r;

                            z__3.r = z__4.r + z__7.r;
                            z__3.i = z__4.i + z__7.i;

                            z__1.r = z__2.r * z__3.r - z__2.i * z__3.i;
                            z__1.i = z__2.r * z__3.i + z__2.i * z__3.r;

                            refsum.r = z__1.r;
                            refsum.i = z__1.i;

                            i__6 = k + 1 + j * h_dim1;
                            i__7 = k + 1 + j * h_dim1;

                            z__1.r = h[i__7].r - refsum.r;
                            z__1.i = h[i__7].i - refsum.i;

                            h[i__6].r = z__1.r;
                            h[i__6].i = z__1.i;

                            i__6 = k + 2 + j * h_dim1;
                            i__7 = k + 2 + j * h_dim1;
                            i__8 = m * v_dim1 + 2;

                            z__2.r = refsum.r * v[i__8].r - refsum.i * v[i__8].i;
                            z__2.i = refsum.r * v[i__8].i + refsum.i * v[i__8].r;

                            z__1.r = h[i__7].r - z__2.r;
                            z__1.i = h[i__7].i - z__2.i;

                            h[i__6].r = z__1.r;
                            h[i__6].i = z__1.i;

                            i__6 = k + 3 + j * h_dim1;
                            i__7 = k + 3 + j * h_dim1;
                            i__8 = m * v_dim1 + 3;

                            z__2.r = refsum.r * v[i__8].r - refsum.i * v[i__8].i;
                            z__2.i = refsum.r * v[i__8].i + refsum.i * v[i__8].r;

                            z__1.r = h[i__7].r - z__2.r;
                            z__1.i = h[i__7].i - z__2.i;

                            h[i__6].r = z__1.r;
                            h[i__6].i = z__1.i;
                        }
                    }
                    if (bmp22)
                    {
                        k = krcol + (m22 - 1) * 3;
                        // Computing MAX 
                        i__4 = k + 1;
                        i__5 = jbot;
                        for (j = Math.Max(i__4, *ktop); j <= i__5; ++j)
                        {
                            d_cnjg(&z__2, &v[m22 * v_dim1 + 1]);
                            i__4 = k + 1 + j * h_dim1;
                            d_cnjg(&z__5, &v[m22 * v_dim1 + 2]);

                            i__6 = k + 2 + j * h_dim1;

                            z__4.r = z__5.r * h[i__6].r - z__5.i * h[i__6].i;
                            z__4.i = z__5.r * h[i__6].i + z__5.i * h[i__6].r;

                            z__3.r = h[i__4].r + z__4.r;
                            z__3.i = h[i__4].i + z__4.i;

                            z__1.r = z__2.r * z__3.r - z__2.i * z__3.i;
                            z__1.i = z__2.r * z__3.i + z__2.i * z__3.r;

                            refsum.r = z__1.r;
                            refsum.i = z__1.i;

                            i__4 = k + 1 + j * h_dim1;
                            i__6 = k + 1 + j * h_dim1;

                            z__1.r = h[i__6].r - refsum.r;
                            z__1.i = h[i__6].i - refsum.i;

                            h[i__4].r = z__1.r;
                            h[i__4].i = z__1.i;

                            i__4 = k + 2 + j * h_dim1;
                            i__6 = k + 2 + j * h_dim1;
                            i__7 = m22 * v_dim1 + 2;

                            z__2.r = refsum.r * v[i__7].r - refsum.i * v[i__7].i;
                            z__2.i = refsum.r * v[i__7].i + refsum.i * v[i__7].r;

                            z__1.r = h[i__6].r - z__2.r;
                            z__1.i = h[i__6].i - z__2.i;

                            h[i__4].r = z__1.r;
                            h[i__4].i = z__1.i;
                        }
                    }

                    // ==== Multiply H by reflections from the right. 
                    // .    Delay filling in the last row until the 
                    // .    vigilant deflation check is complete. ==== 

                    if (accum)
                    {
                        jtop = Math.Max(*ktop, incol);
                    }
                    else if (*wantt)
                    {
                        jtop = 1;
                    }
                    else
                    {
                        jtop = *ktop;
                    }
                    i__5 = mbot;

                    for (m = mtop; m <= i__5; ++m)
                    {
                        i__4 = m * v_dim1 + 1;

                        if (v[i__4].r != 0.0 || v[i__4].i != 0.0)
                        {
                            k = krcol + (m - 1) * 3;
                            // Computing MIN 
                            i__6 = *kbot;
                            i__7 = k + 3;
                            i__4 = Math.Min(i__6, i__7);

                            for (j = jtop; j <= i__4; ++j)
                            {
                                i__6 = m * v_dim1 + 1;
                                i__7 = j + (k + 1) * h_dim1;
                                i__8 = m * v_dim1 + 2;
                                i__9 = j + (k + 2) * h_dim1;

                                z__4.r = v[i__8].r * h[i__9].r - v[i__8].i * h[i__9].i;
                                z__4.i = v[i__8].r * h[i__9].i + v[i__8].i * h[i__9].r;

                                z__3.r = h[i__7].r + z__4.r;
                                z__3.i = h[i__7].i + z__4.i;

                                i__10 = m * v_dim1 + 3;

                                i__11 = j + (k + 3) * h_dim1;

                                z__5.r = v[i__10].r * h[i__11].r - v[i__10].i * h[i__11].i;
                                z__5.i = v[i__10].r * h[i__11].i + v[i__10].i * h[i__11].r;

                                z__2.r = z__3.r + z__5.r;
                                z__2.i = z__3.i + z__5.i;

                                z__1.r = v[i__6].r * z__2.r - v[i__6].i * z__2.i;
                                z__1.i = v[i__6].r * z__2.i + v[i__6].i * z__2.r;

                                refsum.r = z__1.r;
                                refsum.i = z__1.i;

                                i__6 = j + (k + 1) * h_dim1;
                                i__7 = j + (k + 1) * h_dim1;

                                z__1.r = h[i__7].r - refsum.r;
                                z__1.i = h[i__7].i - refsum.i;

                                h[i__6].r = z__1.r;
                                h[i__6].i = z__1.i;

                                i__6 = j + (k + 2) * h_dim1;
                                i__7 = j + (k + 2) * h_dim1;
                                d_cnjg(&z__3, &v[m * v_dim1 + 2]);

                                z__2.r = refsum.r * z__3.r - refsum.i * z__3.i;
                                z__2.i = refsum.r * z__3.i + refsum.i * z__3.r;

                                z__1.r = h[i__7].r - z__2.r;
                                z__1.i = h[i__7].i - z__2.i;

                                h[i__6].r = z__1.r;
                                h[i__6].i = z__1.i;

                                i__6 = j + (k + 3) * h_dim1;
                                i__7 = j + (k + 3) * h_dim1;
                                d_cnjg(&z__3, &v[m * v_dim1 + 3]);

                                z__2.r = refsum.r * z__3.r - refsum.i * z__3.i;
                                z__2.i = refsum.r * z__3.i + refsum.i * z__3.r;

                                z__1.r = h[i__7].r - z__2.r;
                                z__1.i = h[i__7].i - z__2.i;

                                h[i__6].r = z__1.r;
                                h[i__6].i = z__1.i;
                            }

                            if (accum)
                            {
                                // ==== Accumulate U. (If necessary, update Z later 
                                // .    with with an efficient matrix-matrix 
                                // .    multiply.) ==== 

                                kms = k - incol;
                                // Computing MAX 
                                i__4 = 1;
                                i__6 = *ktop - incol;
                                i__7 = kdu;
                                for (j = Math.Max(i__4, i__6); j <= i__7; ++j)
                                {
                                    i__4 = m * v_dim1 + 1;
                                    i__6 = j + (kms + 1) * u_dim1;
                                    i__8 = m * v_dim1 + 2;
                                    i__9 = j + (kms + 2) * u_dim1;

                                    z__4.r = v[i__8].r * u[i__9].r - v[i__8].i * u[i__9].i;
                                    z__4.i = v[i__8].r * u[i__9].i + v[i__8].i * u[i__9].r;

                                    z__3.r = u[i__6].r + z__4.r;
                                    z__3.i = u[i__6].i + z__4.i;

                                    i__10 = m * v_dim1 + 3;

                                    i__11 = j + (kms + 3) * u_dim1;

                                    z__5.r = v[i__10].r * u[i__11].r - v[i__10].i * u[i__11].i;
                                    z__5.i = v[i__10].r * u[i__11].i + v[i__10].i * u[i__11].r;

                                    z__2.r = z__3.r + z__5.r;
                                    z__2.i = z__3.i + z__5.i;

                                    z__1.r = v[i__4].r * z__2.r - v[i__4].i * z__2.i;
                                    z__1.i = v[i__4].r * z__2.i + v[i__4].i * z__2.r;

                                    refsum.r = z__1.r;
                                    refsum.i = z__1.i;

                                    i__4 = j + (kms + 1) * u_dim1;
                                    i__6 = j + (kms + 1) * u_dim1;

                                    z__1.r = u[i__6].r - refsum.r;
                                    z__1.i = u[i__6].i - refsum.i;

                                    u[i__4].r = z__1.r;
                                    u[i__4].i = z__1.i;

                                    i__4 = j + (kms + 2) * u_dim1;
                                    i__6 = j + (kms + 2) * u_dim1;
                                    d_cnjg(&z__3, &v[m * v_dim1 + 2]);

                                    z__2.r = refsum.r * z__3.r - refsum.i * z__3.i;
                                    z__2.i = refsum.r * z__3.i + refsum.i * z__3.r;

                                    z__1.r = u[i__6].r - z__2.r;
                                    z__1.i = u[i__6].i - z__2.i;

                                    u[i__4].r = z__1.r;
                                    u[i__4].i = z__1.i;

                                    i__4 = j + (kms + 3) * u_dim1;
                                    i__6 = j + (kms + 3) * u_dim1;
                                    d_cnjg(&z__3, &v[m * v_dim1 + 3]);

                                    z__2.r = refsum.r * z__3.r - refsum.i * z__3.i;
                                    z__2.i = refsum.r * z__3.i + refsum.i * z__3.r;

                                    z__1.r = u[i__6].r - z__2.r;
                                    z__1.i = u[i__6].i - z__2.i;

                                    u[i__4].r = z__1.r;
                                    u[i__4].i = z__1.i;
                                }
                            }
                            else if (*wantz)
                            {
                                // ==== U is not accumulated, so update Z 
                                // .    now by multiplying by reflections 
                                // .    from the right. ==== 

                                i__7 = *ihiz;
                                for (j = *iloz; j <= i__7; ++j)
                                {
                                    i__4 = m * v_dim1 + 1;
                                    i__6 = j + (k + 1) * z_dim1;
                                    i__8 = m * v_dim1 + 2;
                                    i__9 = j + (k + 2) * z_dim1;

                                    z__4.r = v[i__8].r * z[i__9].r - v[i__8].i * z[i__9].i;
                                    z__4.i = v[i__8].r * z[i__9].i + v[i__8].i * z[i__9].r;

                                    z__3.r = z[i__6].r + z__4.r;
                                    z__3.i = z[i__6].i + z__4.i;

                                    i__10 = m * v_dim1 + 3;
                                    i__11 = j + (k + 3) * z_dim1;

                                    z__5.r = v[i__10].r * z[i__11].r - v[i__10].i * z[i__11].i;
                                    z__5.i = v[i__10].r * z[i__11].i + v[i__10].i * z[i__11].r;

                                    z__2.r = z__3.r + z__5.r;
                                    z__2.i = z__3.i + z__5.i;

                                    z__1.r = v[i__4].r * z__2.r - v[i__4].i * z__2.i;
                                    z__1.i = v[i__4].r * z__2.i + v[i__4].i * z__2.r;

                                    refsum.r = z__1.r;
                                    refsum.i = z__1.i;

                                    i__4 = j + (k + 1) * z_dim1;
                                    i__6 = j + (k + 1) * z_dim1;

                                    z__1.r = z[i__6].r - refsum.r;
                                    z__1.i = z[i__6].i - refsum.i;

                                    z[i__4].r = z__1.r;
                                    z[i__4].i = z__1.i;

                                    i__4 = j + (k + 2) * z_dim1;
                                    i__6 = j + (k + 2) * z_dim1;

                                    d_cnjg(&z__3, &v[m * v_dim1 + 2]);

                                    z__2.r = refsum.r * z__3.r - refsum.i * z__3.i;
                                    z__2.i = refsum.r * z__3.i + refsum.i * z__3.r;

                                    z__1.r = z[i__6].r - z__2.r;
                                    z__1.i = z[i__6].i - z__2.i;

                                    z[i__4].r = z__1.r;
                                    z[i__4].i = z__1.i;

                                    i__4 = j + (k + 3) * z_dim1;
                                    i__6 = j + (k + 3) * z_dim1;
                                    d_cnjg(&z__3, &v[m * v_dim1 + 3]);

                                    z__2.r = refsum.r * z__3.r - refsum.i * z__3.i;
                                    z__2.i = refsum.r * z__3.i + refsum.i * z__3.r;

                                    z__1.r = z[i__6].r - z__2.r;
                                    z__1.i = z[i__6].i - z__2.i;

                                    z[i__4].r = z__1.r;
                                    z[i__4].i = z__1.i;
                                }
                            }
                        }
                    }

                    // ==== Special case: 2-by-2 reflection (if needed) ==== 

                    k = krcol + (m22 - 1) * 3;
                    i__5 = m22 * v_dim1 + 1;
                    if (bmp22 && (v[i__5].r != 0.0 || v[i__5].i != 0.0))
                    {
                        // Computing MIN 
                        i__7 = *kbot;
                        i__4 = k + 3;
                        i__5 = Math.Min(i__7, i__4);
                        for (j = jtop; j <= i__5; ++j)
                        {
                            i__7 = m22 * v_dim1 + 1;
                            i__4 = j + (k + 1) * h_dim1;
                            i__6 = m22 * v_dim1 + 2;
                            i__8 = j + (k + 2) * h_dim1;

                            z__3.r = v[i__6].r * h[i__8].r - v[i__6].i * h[i__8].i;
                            z__3.i = v[i__6].r * h[i__8].i + v[i__6].i * h[i__8].r;

                            z__2.r = h[i__4].r + z__3.r;
                            z__2.i = h[i__4].i + z__3.i;

                            z__1.r = v[i__7].r * z__2.r - v[i__7].i * z__2.i;
                            z__1.i = v[i__7].r * z__2.i + v[i__7].i * z__2.r;

                            refsum.r = z__1.r;
                            refsum.i = z__1.i;

                            i__7 = j + (k + 1) * h_dim1;
                            i__4 = j + (k + 1) * h_dim1;

                            z__1.r = h[i__4].r - refsum.r;
                            z__1.i = h[i__4].i - refsum.i;

                            h[i__7].r = z__1.r;
                            h[i__7].i = z__1.i;

                            i__7 = j + (k + 2) * h_dim1;
                            i__4 = j + (k + 2) * h_dim1;
                            d_cnjg(&z__3, &v[m22 * v_dim1 + 2]);

                            z__2.r = refsum.r * z__3.r - refsum.i * z__3.i;
                            z__2.i = refsum.r * z__3.i + refsum.i * z__3.r;

                            z__1.r = h[i__4].r - z__2.r;
                            z__1.i = h[i__4].i - z__2.i;

                            h[i__7].r = z__1.r;
                            h[i__7].i = z__1.i;
                        }

                        if (accum)
                        {
                            kms = k - incol;
                            // Computing MAX 
                            i__5 = 1;
                            i__7 = *ktop - incol;
                            i__4 = kdu;

                            for (j = Math.Max(i__5, i__7); j <= i__4; ++j)
                            {
                                i__5 = m22 * v_dim1 + 1;
                                i__7 = j + (kms + 1) * u_dim1;
                                i__6 = m22 * v_dim1 + 2;
                                i__8 = j + (kms + 2) * u_dim1;

                                z__3.r = v[i__6].r * u[i__8].r - v[i__6].i * u[i__8].i;
                                z__3.i = v[i__6].r * u[i__8].i + v[i__6].i * u[i__8].r;

                                z__2.r = u[i__7].r + z__3.r;
                                z__2.i = u[i__7].i + z__3.i;

                                z__1.r = v[i__5].r * z__2.r - v[i__5].i * z__2.i;
                                z__1.i = v[i__5].r * z__2.i + v[i__5].i * z__2.r;

                                refsum.r = z__1.r;
                                refsum.i = z__1.i;

                                i__5 = j + (kms + 1) * u_dim1;
                                i__7 = j + (kms + 1) * u_dim1;

                                z__1.r = u[i__7].r - refsum.r;
                                z__1.i = u[i__7].i - refsum.i;

                                u[i__5].r = z__1.r;
                                u[i__5].i = z__1.i;

                                i__5 = j + (kms + 2) * u_dim1;
                                i__7 = j + (kms + 2) * u_dim1;
                                d_cnjg(&z__3, &v[m22 * v_dim1 + 2]);

                                z__2.r = refsum.r * z__3.r - refsum.i * z__3.i;
                                z__2.i = refsum.r * z__3.i + refsum.i * z__3.r;

                                z__1.r = u[i__7].r - z__2.r;
                                z__1.i = u[i__7].i - z__2.i;

                                u[i__5].r = z__1.r;
                                u[i__5].i = z__1.i;
                            }

                        }
                        else if (*wantz)
                        {
                            i__4 = *ihiz;
                            for (j = *iloz; j <= i__4; ++j)
                            {
                                i__5 = m22 * v_dim1 + 1;
                                i__7 = j + (k + 1) * z_dim1;
                                i__6 = m22 * v_dim1 + 2;
                                i__8 = j + (k + 2) * z_dim1;

                                z__3.r = v[i__6].r * z[i__8].r - v[i__6].i * z[i__8].i;
                                z__3.i = v[i__6].r * z[i__8].i + v[i__6].i * z[i__8].r;

                                z__2.r = z[i__7].r + z__3.r;
                                z__2.i = z[i__7].i + z__3.i;

                                z__1.r = v[i__5].r * z__2.r - v[i__5].i * z__2.i;
                                z__1.i = v[i__5].r * z__2.i + v[i__5].i * z__2.r;

                                refsum.r = z__1.r;
                                refsum.i = z__1.i;

                                i__5 = j + (k + 1) * z_dim1;
                                i__7 = j + (k + 1) * z_dim1;

                                z__1.r = z[i__7].r - refsum.r;
                                z__1.i = z[i__7].i - refsum.i;

                                z[i__5].r = z__1.r;
                                z[i__5].i = z__1.i;

                                i__5 = j + (k + 2) * z_dim1;
                                i__7 = j + (k + 2) * z_dim1;
                                d_cnjg(&z__3, &v[m22 * v_dim1 + 2]);

                                z__2.r = refsum.r * z__3.r - refsum.i * z__3.i;
                                z__2.i = refsum.r * z__3.i + refsum.i * z__3.r;

                                z__1.r = z[i__7].r - z__2.r;
                                z__1.i = z[i__7].i - z__2.i;

                                z[i__5].r = z__1.r;
                                z[i__5].i = z__1.i;
                            }
                        }
                    }

                    // ==== Vigilant deflation check ==== 

                    mstart = mtop;
                    if (krcol + (mstart - 1) * 3 < *ktop)
                    {
                        ++mstart;
                    }
                    mend = mbot;
                    if (bmp22)
                    {
                        ++mend;
                    }
                    if (krcol == *kbot - 2)
                    {
                        ++mend;
                    }
                    i__4 = mend;
                    for (m = mstart; m <= i__4; ++m)
                    {
                        // Computing MIN 
                        i__5 = *kbot - 1;
                        i__7 = krcol + (m - 1) * 3;
                        k = Math.Min(i__5, i__7);

                        // ==== The following convergence test requires that 
                        // .    the tradition small-compared-to-nearby-diagonals 
                        // .    criterion and the Ahues & Tisseur (LAWN 122, 1997) 
                        // .    criteria both be satisfied.  The latter improves 
                        // .    accuracy in some examples. Falling back on an 
                        // .    alternate convergence criterion when TST1 or TST2 
                        // .    is zero (as done here) is traditional but probably 
                        // .    unnecessary. ==== 

                        i__5 = k + 1 + k * h_dim1;
                        if (h[i__5].r != 0.0 || h[i__5].i != 0.0)
                        {
                            i__5 = k + k * h_dim1;
                            i__7 = k + 1 + (k + 1) * h_dim1;
                            tst1 = Math.Abs(h[i__5].r) + Math.Abs(d_imag(&h[k + k * h_dim1])) +
                                (Math.Abs(h[i__7].r) + Math.Abs(d_imag(&h[k + 1 + (k + 1) * h_dim1])));

                            if (tst1 == 0.0)
                            {
                                if (k >= *ktop + 1)
                                {
                                    i__5 = k + (k - 1) * h_dim1;
                                    tst1 += Math.Abs(h[i__5].r) + Math.Abs(d_imag(&h[k + (k - 1) * h_dim1]));
                                }
                                if (k >= *ktop + 2)
                                {
                                    i__5 = k + (k - 2) * h_dim1;
                                    tst1 += Math.Abs(h[i__5].r) + Math.Abs(d_imag(&h[k + (k - 2) * h_dim1]));
                                }
                                if (k >= *ktop + 3)
                                {
                                    i__5 = k + (k - 3) * h_dim1;
                                    tst1 += Math.Abs(h[i__5].r) + Math.Abs(d_imag(&h[k + (k - 3) * h_dim1]));
                                }
                                if (k <= *kbot - 2)
                                {
                                    i__5 = k + 2 + (k + 1) * h_dim1;
                                    tst1 += Math.Abs(h[i__5].r) + Math.Abs(d_imag(&h[k + 2 + (k + 1) * h_dim1]));
                                }
                                if (k <= *kbot - 3)
                                {
                                    i__5 = k + 3 + (k + 1) * h_dim1;
                                    tst1 += Math.Abs(h[i__5].r) + Math.Abs(d_imag(&h[k + 3 + (k + 1) * h_dim1]));
                                }
                                if (k <= *kbot - 4)
                                {
                                    i__5 = k + 4 + (k + 1) * h_dim1;
                                    tst1 += Math.Abs(h[i__5].r) + Math.Abs(d_imag(&h[k + 4 + (k + 1) * h_dim1]));
                                }
                            }
                            i__5 = k + 1 + k * h_dim1;
                            // Computing MAX 
                            d__3 = smlnum;
                            d__4 = ulp * tst1;

                            if (Math.Abs(h[i__5].r) + Math.Abs(d_imag(&h[k + 1 + k * h_dim1])) <= Math.Max(d__3, d__4))
                            {
                                // Computing MAX 
                                i__5 = k + 1 + k * h_dim1;
                                i__7 = k + (k + 1) * h_dim1;

                                d__5 = Math.Abs(h[i__5].r) + Math.Abs(d_imag(&h[k + 1 + k * h_dim1]));
                                d__6 = Math.Abs(h[i__7].r) + Math.Abs(d_imag(&h[k + (k + 1) * h_dim1]));

                                h12 = Math.Max(d__5, d__6);
                                // Computing MIN 
                                i__5 = k + 1 + k * h_dim1;
                                i__7 = k + (k + 1) * h_dim1;

                                d__5 = Math.Abs(h[i__5].r) + Math.Abs(d_imag(&h[k + 1 + k * h_dim1]));
                                d__6 = Math.Abs(h[i__7].r) + Math.Abs(d_imag(&h[k + (k + 1) * h_dim1]));

                                h21 = Math.Min(d__5, d__6);
                                i__5 = k + k * h_dim1;
                                i__7 = k + 1 + (k + 1) * h_dim1;

                                z__2.r = h[i__5].r - h[i__7].r;
                                z__2.i = h[i__5].i - h[i__7].i;

                                z__1.r = z__2.r;
                                z__1.i = z__2.i;
                                // Computing MAX 
                                i__6 = k + 1 + (k + 1) * h_dim1;

                                d__5 = Math.Abs(h[i__6].r) + Math.Abs(d_imag(&h[k + 1 + (k + 1) * h_dim1]));
                                d__6 = Math.Abs(z__1.r) + Math.Abs(d_imag(&z__1));
                                h11 = Math.Max(d__5, d__6);
                                i__5 = k + k * h_dim1;
                                i__7 = k + 1 + (k + 1) * h_dim1;

                                z__2.r = h[i__5].r - h[i__7].r;
                                z__2.i = h[i__5].i - h[i__7].i;
                                z__1.r = z__2.r;
                                z__1.i = z__2.i;
                                // Computing MIN 
                                i__6 = k + 1 + (k + 1) * h_dim1;

                                d__5 = Math.Abs(h[i__6].r) + Math.Abs(d_imag(&h[k + 1 + (k + 1) * h_dim1]));
                                d__6 = Math.Abs(z__1.r) + Math.Abs(d_imag(&z__1));
                                h22 = Math.Min(d__5, d__6);
                                scl = h11 + h12;
                                tst2 = h22 * (h11 / scl);

                                // Computing MAX 
                                d__1 = smlnum;
                                d__2 = ulp * tst2;
                                if (tst2 == 0.0 || h21 * (h12 / scl) <= Math.Max(d__1, d__2))
                                {
                                    i__5 = k + 1 + k * h_dim1;

                                    h[i__5].r = 0.0;
                                    h[i__5].i = 0.0;
                                }
                            }
                        }
                    }

                    // ==== Fill in the last row of each bulge. ==== 

                    // Computing MIN 
                    i__4 = nbmps;
                    i__5 = (*kbot - krcol - 1) / 3;
                    mend = Math.Min(i__4, i__5);
                    i__4 = mend;
                    for (m = mtop; m <= i__4; ++m)
                    {
                        k = krcol + (m - 1) * 3;
                        i__5 = m * v_dim1 + 1;
                        i__7 = m * v_dim1 + 3;

                        z__2.r = v[i__5].r * v[i__7].r - v[i__5].i * v[i__7].i;
                        z__2.i = v[i__5].r * v[i__7].i + v[i__5].i * v[i__7].r;

                        i__6 = k + 4 + (k + 3) * h_dim1;

                        z__1.r = z__2.r * h[i__6].r - z__2.i * h[i__6].i;
                        z__1.i = z__2.r * h[i__6].i + z__2.i * h[i__6].r;

                        refsum.r = z__1.r;
                        refsum.i = z__1.i;

                        i__5 = k + 4 + (k + 1) * h_dim1;

                        z__1.r = -refsum.r;
                        z__1.i = -refsum.i;

                        h[i__5].r = z__1.r;
                        h[i__5].i = z__1.i;

                        i__5 = k + 4 + (k + 2) * h_dim1;

                        z__2.r = -refsum.r;
                        z__2.i = -refsum.i;

                        d_cnjg(&z__3, &v[m * v_dim1 + 2]);

                        z__1.r = z__2.r * z__3.r - z__2.i * z__3.i;
                        z__1.i = z__2.r * z__3.i + z__2.i * z__3.r;

                        h[i__5].r = z__1.r;
                        h[i__5].i = z__1.i;

                        i__5 = k + 4 + (k + 3) * h_dim1;
                        i__7 = k + 4 + (k + 3) * h_dim1;
                        d_cnjg(&z__3, &v[m * v_dim1 + 3]);

                        z__2.r = refsum.r * z__3.r - refsum.i * z__3.i;
                        z__2.i = refsum.r * z__3.i + refsum.i * z__3.r;

                        z__1.r = h[i__7].r - z__2.r;
                        z__1.i = h[i__7].i - z__2.i;

                        h[i__5].r = z__1.r;
                        h[i__5].i = z__1.i;
                    }

                    // ==== End of near-the-diagonal bulge chase. ==== 

                }

                // ==== Use U (if accumulated) to update far-from-diagonal 
                // .    entries in H.  If required, use U to update Z as 
                // .    well. ==== 

                if (accum)
                {
                    if (*wantt)
                    {
                        jtop = 1;
                        jbot = *n;
                    }
                    else
                    {
                        jtop = *ktop;
                        jbot = *kbot;
                    }
                    if (!blk22 || incol < *ktop || ndcol > *kbot || ns <= 2)
                    {
                        // ==== Updates not exploiting the 2-by-2 block 
                        // .    structure of U.  K1 and NU keep track of 
                        // .    the location and size of U in the special 
                        // .    cases of introducing bulges and chasing 
                        // .    bulges off the bottom.  In these special 
                        // .    cases and in case the number of shifts 
                        // .    is NS = 2, there is no 2-by-2 block 
                        // .    structure to exploit.  ==== 

                        // Computing MAX 
                        i__3 = 1;
                        i__4 = *ktop - incol;
                        k1 = Math.Max(i__3, i__4);
                        // Computing MAX 
                        i__3 = 0;
                        i__4 = ndcol - *kbot;
                        nu = kdu - Math.Max(i__3, i__4) - k1 + 1;

                        // ==== Horizontal Multiply ==== 

                        i__3 = jbot;
                        i__4 = *nh;
                        for (jcol = Math.Min(ndcol, *kbot) + 1; i__4 < 0 ? jcol >= i__3 : jcol <= i__3; jcol += i__4)
                        {
                            // Computing MIN 
                            i__5 = *nh;
                            i__7 = jbot - jcol + 1;
                            jlen = Math.Min(i__5, i__7);
                            zgemm("C", "N", &nu, &jlen, &nu, &c_b2, &u[k1 + k1 * u_dim1], ldu, &h[incol + k1 + jcol * h_dim1],
                                ldh, &c_b1, &wh[wh_offset], ldwh);
                            zlacpy("ALL", &nu, &jlen, &wh[wh_offset], ldwh, &h[incol + k1 + jcol * h_dim1], ldh);
                        }

                        // ==== Vertical multiply ==== 

                        i__4 = Math.Max(*ktop, incol) - 1;
                        i__3 = *nv;
                        for (jrow = jtop; i__3 < 0 ? jrow >= i__4 : jrow <= i__4; jrow += i__3)
                        {
                            // Computing MIN 
                            i__5 = *nv;
                            i__7 = Math.Max(*ktop, incol) - jrow;
                            jlen = Math.Min(i__5, i__7);
                            zgemm("N", "N", &jlen, &nu, &nu, &c_b2, &h[jrow + (incol + k1) * h_dim1], ldh, &u[k1 + k1 * u_dim1],
                                ldu, &c_b1, &wv[wv_offset], ldwv);
                            zlacpy("ALL", &jlen, &nu, &wv[wv_offset], ldwv, &h[jrow + (incol + k1) * h_dim1], ldh);
                        }

                        // ==== Z multiply (also vertical) ==== 

                        if (*wantz)
                        {
                            i__3 = *ihiz;
                            i__4 = *nv;
                            for (jrow = *iloz; i__4 < 0 ? jrow >= i__3 : jrow <= i__3; jrow += i__4)
                            {
                                // Computing MIN 
                                i__5 = *nv;
                                i__7 = *ihiz - jrow + 1;
                                jlen = Math.Min(i__5, i__7);
                                zgemm("N", "N", &jlen, &nu, &nu, &c_b2, &z[jrow + (incol + k1) * z_dim1], ldz,
                                    &u[k1 + k1 * u_dim1], ldu, &c_b1, &wv[wv_offset], ldwv);
                                zlacpy("ALL", &jlen, &nu, &wv[wv_offset], ldwv, &z[jrow + (incol + k1) * z_dim1], ldz);
                            }
                        }
                    }
                    else
                    {
                        // ==== Updates exploiting U's 2-by-2 block structure. 
                        // .    (I2, I4, J2, J4 are the last rows and columns 
                        // .    of the blocks.) ==== 

                        i2 = (kdu + 1) / 2;
                        i4 = kdu;
                        j2 = i4 - i2;
                        j4 = kdu;

                        // ==== KZS and KNZ deal with the band of zeros 
                        // .    aint the diagonal of one of the triangular 
                        // .    blocks. ==== 

                        kzs = j4 - j2 - (ns + 1);
                        knz = ns + 1;

                        // ==== Horizontal multiply ==== 

                        i__4 = jbot;
                        i__3 = *nh;
                        for (jcol = Math.Min(ndcol, *kbot) + 1; i__3 < 0 ? jcol >= i__4 : jcol <= i__4; jcol += i__3)
                        {
                            // Computing MIN 
                            i__5 = *nh;
                            i__7 = jbot - jcol + 1;
                            jlen = Math.Min(i__5, i__7);

                            // ==== Copy bottom of H to top+KZS of scratch ==== 
                            // (The first KZS rows get multiplied by zero.) ==== 

                            zlacpy("ALL", &knz, &jlen, &h[incol + 1 + j2 + jcol * h_dim1], ldh, &wh[kzs + 1 + wh_dim1], ldwh);

                            // ==== Multiply by U21' ==== 

                            zlaset("ALL", &kzs, &jlen, &c_b1, &c_b1, &wh[wh_offset], ldwh);
                            ztrmm("L", "U", "C", "N", &knz, &jlen, &c_b2, &u[j2 + 1 + (kzs + 1) * u_dim1], ldu, &wh[kzs + 1 + wh_dim1], ldwh);

                            // ==== Multiply top of H by U11' ==== 

                            zgemm("C", "N", &i2, &jlen, &j2, &c_b2, &u[u_offset], ldu,
                                &h[incol + 1 + jcol * h_dim1], ldh, &c_b2, &wh[wh_offset], ldwh);

                            // ==== Copy top of H to bottom of WH ==== 

                            zlacpy("ALL", &j2, &jlen, &h[incol + 1 + jcol * h_dim1], ldh, &wh[i2 + 1 + wh_dim1], ldwh);

                            // ==== Multiply by U21' ==== 

                            ztrmm("L", "L", "C", "N", &j2, &jlen, &c_b2, &u[(i2 + 1)
                                * u_dim1 + 1], ldu, &wh[i2 + 1 + wh_dim1], ldwh);

                            // ==== Multiply by U22 ==== 

                            i__5 = i4 - i2;
                            i__7 = j4 - j2;
                            zgemm("C", "N", &i__5, &jlen, &i__7, &c_b2, &u[j2 + 1 + (i2 + 1) * u_dim1], ldu,
                                &h[incol + 1 + j2 + jcol * h_dim1], ldh, &c_b2, &wh[i2 + 1 + wh_dim1], ldwh);

                            // ==== Copy it back ==== 

                            zlacpy("ALL", &kdu, &jlen, &wh[wh_offset], ldwh, &h[incol + 1 + jcol * h_dim1], ldh);
                        }

                        // ==== Vertical multiply ==== 

                        i__3 = Math.Max(incol, *ktop) - 1;
                        i__4 = *nv;
                        for (jrow = jtop; i__4 < 0 ? jrow >= i__3 : jrow <= i__3; jrow += i__4)
                        {
                            // Computing MIN 
                            i__5 = *nv;
                            i__7 = Math.Max(incol, *ktop) - jrow;
                            jlen = Math.Min(i__5, i__7);

                            // ==== Copy right of H to scratch (the first KZS 
                            // .    columns get multiplied by zero) ==== 

                            zlacpy("ALL", &jlen, &knz, &h[jrow + (incol + 1 + j2) * h_dim1], ldh, &wv[(kzs + 1) * wv_dim1 + 1], ldwv);

                            // ==== Multiply by U21 ==== 

                            zlaset("ALL", &jlen, &kzs, &c_b1, &c_b1, &wv[wv_offset], ldwv);
                            ztrmm("R", "U", "N", "N", &jlen, &knz, &c_b2, &u[j2 + 1 + (kzs + 1) * u_dim1],
                                ldu, &wv[(kzs + 1) * wv_dim1 + 1], ldwv);

                            // ==== Multiply by U11 ==== 

                            zgemm("N", "N", &jlen, &i2, &j2, &c_b2, &h[jrow + (incol + 1) * h_dim1],
                                ldh, &u[u_offset], ldu, &c_b2, &wv[wv_offset], ldwv);

                            // ==== Copy left of H to right of scratch ==== 

                            zlacpy("ALL", &jlen, &j2, &h[jrow + (incol + 1) * h_dim1], ldh, &wv[(i2 + 1) * wv_dim1 + 1], ldwv);

                            // ==== Multiply by U21 ==== 

                            i__5 = i4 - i2;
                            ztrmm("R", "L", "N", "N", &jlen, &i__5, &c_b2, &u[(i2 + 1) * u_dim1 + 1],
                                ldu, &wv[(i2 + 1) * wv_dim1 + 1], ldwv);

                            // ==== Multiply by U22 ==== 

                            i__5 = i4 - i2;
                            i__7 = j4 - j2;
                            zgemm("N", "N", &jlen, &i__5, &i__7, &c_b2, &h[jrow + (incol + 1 + j2) * h_dim1],
                                ldh, &u[j2 + 1 + (i2 + 1) * u_dim1], ldu, &c_b2, &wv[(i2 + 1) * wv_dim1 + 1], ldwv);

                            // ==== Copy it back ==== 

                            zlacpy("ALL", &jlen, &kdu, &wv[wv_offset], ldwv, &h[jrow + (incol + 1) * h_dim1], ldh);
                        }

                        // ==== Multiply Z (also vertical) ==== 

                        if (*wantz)
                        {
                            i__4 = *ihiz;
                            i__3 = *nv;
                            for (jrow = *iloz; i__3 < 0 ? jrow >= i__4 : jrow <= i__4; jrow += i__3)
                            {
                                // Computing MIN 
                                i__5 = *nv;
                                i__7 = *ihiz - jrow + 1;
                                jlen = Math.Min(i__5, i__7);

                                // ==== Copy right of Z to left of scratch (first 
                                // .     KZS columns get multiplied by zero) ==== 

                                zlacpy("ALL", &jlen, &knz, &z[jrow + (incol + 1 + j2) * z_dim1], ldz, &wv[(kzs + 1) * wv_dim1 + 1], ldwv);

                                // ==== Multiply by U12 ==== 

                                zlaset("ALL", &jlen, &kzs, &c_b1, &c_b1, &wv[wv_offset], ldwv);
                                ztrmm("R", "U", "N", "N", &jlen, &knz, &c_b2, &u[j2 + 1 + (kzs + 1) * u_dim1],
                                    ldu, &wv[(kzs + 1) * wv_dim1 + 1], ldwv);

                                // ==== Multiply by U11 ==== 

                                zgemm("N", "N", &jlen, &i2, &j2, &c_b2, &z[jrow + (incol + 1) * z_dim1],
                                    ldz, &u[u_offset], ldu, &c_b2, &wv[wv_offset], ldwv);

                                // ==== Copy left of Z to right of scratch ==== 

                                zlacpy("ALL", &jlen, &j2, &z[jrow + (incol + 1) * z_dim1], ldz, &wv[(i2 + 1) * wv_dim1 + 1], ldwv);

                                // ==== Multiply by U21 ==== 

                                i__5 = i4 - i2;
                                ztrmm("R", "L", "N", "N", &jlen, &i__5, &c_b2, &u[(i2 + 1) * u_dim1 + 1],
                                    ldu, &wv[(i2 + 1) * wv_dim1 + 1], ldwv);

                                // ==== Multiply by U22 ==== 

                                i__5 = i4 - i2;
                                i__7 = j4 - j2;
                                zgemm("N", "N", &jlen, &i__5, &i__7, &c_b2, &z[jrow + (incol + 1 + j2) * z_dim1],
                                    ldz, &u[j2 + 1 + (i2 + 1) * u_dim1], ldu, &c_b2, &wv[(i2 + 1) * wv_dim1 + 1], ldwv);

                                // ==== Copy the result back to Z ==== 

                                zlacpy("ALL", &jlen, &kdu, &wv[wv_offset], ldwv, &z[jrow + (incol + 1) * z_dim1], ldz);
                            }
                        }
                    }
                }
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zlarcm(int* m, int* n, double* a, int* lda,
            complex16* b, int* ldb, complex16* c, int* ldc, double* rwork)
        {
            //  -- LAPACK auxiliary routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     November 2006

            //  Purpose
            //  =======

            //  ZLARCM performs a very simple matrix-matrix multiplication:
            //           C := A * B,
            //  where A is M by M and real; B is M by N and complex;
            //  C is M by N and complex.

            //  Arguments
            //  =========

            //  M       (input) int
            //          The number of rows of the matrix A and of the matrix C.
            //          M >= 0.

            //  N       (input) int
            //          The number of columns and rows of the matrix B and
            //          the number of columns of the matrix C.
            //          N >= 0.

            //  A       (input) DOUBLE PRECISION array, dimension (LDA, M)
            //          A contains the M by M matrix A.

            //  LDA     (input) int
            //          The leading dimension of the array A. LDA >=max(1,M).

            //  B       (input) DOUBLE PRECISION array, dimension (LDB, N)
            //          B contains the M by N matrix B.

            //  LDB     (input) int
            //          The leading dimension of the array B. LDB >=max(1,M).

            //  C       (input) COMPLEX*16 array, dimension (LDC, N)
            //          C contains the M by N matrix C.

            //  LDC     (input) int
            //          The leading dimension of the array C. LDC >=max(1,M).

            //  RWORK   (workspace) DOUBLE PRECISION array, dimension (2*M*N)

            //  =====================================================================

            // System generated locals
            int a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, i__1, i__2, i__3, i__4, i__5;
            double d__1;
            complex16 z__1;

            // Table of constant values
            double c_b6 = 1.0;
            double c_b7 = 0.0;

            // Local variables
            int i, j, l;

            // Parameter adjustments
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;
            b_dim1 = *ldb;
            b_offset = 1 + b_dim1;
            b -= b_offset;
            c_dim1 = *ldc;
            c_offset = 1 + c_dim1;
            c -= c_offset;
            --rwork;

            // Function Body
            if (*m == 0 || *n == 0)
            {
                return 0;
            }

            i__1 = *n;
            for (j = 1; j <= i__1; ++j)
            {
                i__2 = *m;
                for (i = 1; i <= i__2; ++i)
                {
                    i__3 = i + j * b_dim1;
                    rwork[(j - 1) * *m + i] = b[i__3].r;
                }
            }

            l = *m * *n + 1;
            dgemm("N", "N", m, n, m, &c_b6, &a[a_offset], lda, &rwork[1], m, &c_b7, &rwork[l], m);
            i__1 = *n;
            for (j = 1; j <= i__1; ++j)
            {
                i__2 = *m;
                for (i = 1; i <= i__2; ++i)
                {
                    i__3 = i + j * c_dim1;
                    i__4 = l + (j - 1) * *m + i - 1;
                    c[i__3].r = rwork[i__4];
                    c[i__3].i = 0.0;
                }
            }

            i__1 = *n;
            for (j = 1; j <= i__1; ++j)
            {
                i__2 = *m;
                for (i = 1; i <= i__2; ++i)
                {
                    rwork[(j - 1) * *m + i] = d_imag(&b[i + j * b_dim1]);
                }
            }

            dgemm("N", "N", m, n, m, &c_b6, &a[a_offset], lda, &rwork[1], m, &c_b7, &rwork[l], m);
            i__1 = *n;
            for (j = 1; j <= i__1; ++j)
            {
                i__2 = *m;
                for (i = 1; i <= i__2; ++i)
                {
                    i__3 = i + j * c_dim1;
                    i__4 = i + j * c_dim1;

                    d__1 = c[i__4].r;
                    i__5 = l + (j - 1) * *m + i - 1;
                    z__1.r = d__1;
                    z__1.i = rwork[i__5];

                    c[i__3].r = z__1.r;
                    c[i__3].i = z__1.i;
                }
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zlarf(string side, int* m, int* n, complex16* v, int* incv,
            complex16* tau, complex16* c, int* ldc, complex16* work)
        {
            //  -- LAPACK auxiliary routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. 
            //     November 2006 

            //  Purpose 
            //  ======= 

            //  ZLARF applies a complex elementary reflector H to a complex M-by-N 
            //  matrix C, from either the left or the right. H is represented in the 
            //  form 

            //        H = I - tau * v * v' 

            //  where tau is a complex scalar and v is a complex vector. 

            //  If tau = 0, then H is taken to be the unit matrix. 

            //  To apply H' (the conjugate transpose of H), supply conjg(tau) instead 
            //  tau. 

            //  Arguments 
            //  ========= 

            //  SIDE    (input) CHARACTER*1 
            //          = 'L': form  H * C 
            //          = 'R': form  C * H 

            //  M       (input) int 
            //          The number of rows of the matrix C. 

            //  N       (input) int 
            //          The number of columns of the matrix C. 

            //  V       (input) COMPLEX*16 array, dimension 
            //                     (1 + (M-1)*abs(INCV)) if SIDE = 'L' 
            //                  or (1 + (N-1)*abs(INCV)) if SIDE = 'R' 
            //          The vector v in the representation of H. V is not used if 
            //          TAU = 0. 

            //  INCV    (input) int 
            //          The increment between elements of v. INCV <> 0. 

            //  TAU     (input) COMPLEX*16 
            //          The value tau in the representation of H. 

            //  C       (input/output) COMPLEX*16 array, dimension (LDC,N) 
            //          On entry, the M-by-N matrix C. 
            //          On exit, C is overwritten by the matrix H * C if SIDE = 'L', 
            //          or C * H if SIDE = 'R'. 

            //  LDC     (input) int 
            //          The leading dimension of the array C. LDC >= max(1,M). 

            //  WORK    (workspace) COMPLEX*16 array, dimension 
            //                         (N) if SIDE = 'L' 
            //                      or (M) if SIDE = 'R' 

            //  ===================================================================== 

            // System generated locals 
            int c_dim1, c_offset, i__1;
            complex16 z__1;

            // Table of constant values
            complex16 c_b1 = new complex16(1.0, 0.0);
            complex16 c_b2 = new complex16(0.0, 0.0);
            int c__1 = 1;

            // Local variables 
            int i;
            bool applyleft;
            int lastc;
            int lastv;

            // Parameter adjustments 
            --v;
            c_dim1 = *ldc;
            c_offset = 1 + c_dim1;
            c -= c_offset;
            --work;

            // Function Body 
            applyleft = lsame(side, "L");
            lastv = 0;
            lastc = 0;

            if (tau.r != 0.0 || tau.i != 0.0)
            {
                // Set up variables for scanning V.  LASTV begins pointing to the end 
                // of V. 
                if (applyleft)
                {
                    lastv = *m;
                }
                else
                {
                    lastv = *n;
                }
                if (*incv > 0)
                {
                    i = (lastv - 1) * *incv + 1;
                }
                else
                {
                    i = 1;
                }
                // Look for the last non-zero row in V. 
                for (; ; )
                {
                    // while(complicated condition) 
                    i__1 = i;
                    if (!(lastv > 0 && (v[i__1].r == 0.0 && v[i__1].i == 0.0)))
                        break;
                    --lastv;
                    i -= *incv;
                }

                if (applyleft)
                {
                    // Scan for the last non-zero column in C(1:lastv,:). 
                    lastc = ilazlc(&lastv, n, &c[c_offset], ldc);
                }
                else
                {
                    // Scan for the last non-zero row in C(:,1:lastv). 
                    lastc = ilazlr(m, &lastv, &c[c_offset], ldc);
                }
            }

            // Note that lastc.eq.0 renders the BLAS operations null; no special 
            // case is needed at this level. 
            if (applyleft)
            {
                // Form  H * C 

                if (lastv > 0)
                {
                    // w(1:lastc,1) := C(1:lastv,1:lastc)' * v(1:lastv,1) 

                    zgemv("Conjugate transpose", &lastv, &lastc, &c_b1, &c[c_offset],
                        ldc, &v[1], incv, &c_b2, &work[1], &c__1);

                    // C(1:lastv,1:lastc) := C(...) - v(1:lastv,1) * w(1:lastc,1)' 

                    z__1.r = -tau.r;
                    z__1.i = -tau.i;
                    zgerc(&lastv, &lastc, &z__1, &v[1], incv, &work[1], &c__1, &c[c_offset], ldc);
                }
            }
            else
            {
                // Form  C * H 

                if (lastv > 0)
                {
                    // w(1:lastc,1) := C(1:lastc,1:lastv) * v(1:lastv,1) 

                    zgemv("No transpose", &lastc, &lastv, &c_b1, &c[c_offset], ldc,
                         &v[1], incv, &c_b2, &work[1], &c__1);

                    // C(1:lastc,1:lastv) := C(...) - w(1:lastc,1) * v(1:lastv,1)' 

                    z__1.r = -tau.r;
                    z__1.i = -tau.i;

                    zgerc(&lastc, &lastv, &z__1, &work[1], &c__1, &v[1], incv, &c[c_offset], ldc);
                }
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zlarfb(string side, string trans, string direct, string storev,
            int* m, int* n, int* k, complex16* v, int* ldv,
            complex16* t, int* ldt, complex16* c, int* ldc,
            complex16* work, int* ldwork)
        {
            //  -- LAPACK auxiliary routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. 
            //     November 2006 

            //  Purpose 
            //  ======= 

            //  ZLARFB applies a complex block reflector H or its transpose H' to a 
            //  complex M-by-N matrix C, from either the left or the right. 

            //  Arguments 
            //  ========= 

            //  SIDE    (input) CHARACTER*1 
            //          = 'L': apply H or H' from the Left 
            //          = 'R': apply H or H' from the Right 

            //  TRANS   (input) CHARACTER*1 
            //          = 'N': apply H (No transpose) 
            //          = 'C': apply H' (Conjugate transpose) 

            //  DIRECT  (input) CHARACTER*1 
            //          Indicates how H is formed from a product of elementary 
            //          reflectors 
            //          = 'F': H = H(1) H(2) . . . H(k) (Forward) 
            //          = 'B': H = H(k) . . . H(2) H(1) (Backward) 

            //  STOREV  (input) CHARACTER*1 
            //          Indicates how the vectors which define the elementary 
            //          reflectors are stored: 
            //          = 'C': Columnwise 
            //          = 'R': Rowwise 

            //  M       (input) int 
            //          The number of rows of the matrix C. 

            //  N       (input) int 
            //          The number of columns of the matrix C. 

            //  K       (input) int 
            //          The order of the matrix T (= the number of elementary 
            //          reflectors whose product defines the block reflector). 

            //  V       (input) COMPLEX*16 array, dimension 
            //                                (LDV,K) if STOREV = 'C' 
            //                                (LDV,M) if STOREV = 'R' and SIDE = 'L' 
            //                                (LDV,N) if STOREV = 'R' and SIDE = 'R' 
            //          The matrix V. See further details. 

            //  LDV     (input) int 
            //          The leading dimension of the array V. 
            //          If STOREV = 'C' and SIDE = 'L', LDV >= max(1,M); 
            //          if STOREV = 'C' and SIDE = 'R', LDV >= max(1,N); 
            //          if STOREV = 'R', LDV >= K. 

            //  T       (input) COMPLEX*16 array, dimension (LDT,K) 
            //          The triangular K-by-K matrix T in the representation of the 
            //          block reflector. 

            //  LDT     (input) int 
            //          The leading dimension of the array T. LDT >= K. 

            //  C       (input/output) COMPLEX*16 array, dimension (LDC,N) 
            //          On entry, the M-by-N matrix C. 
            //          On exit, C is overwritten by H*C or H'*C or C*H or C*H'. 

            //  LDC     (input) int 
            //          The leading dimension of the array C. LDC >= max(1,M). 

            //  WORK    (workspace) COMPLEX*16 array, dimension (LDWORK,K) 

            //  LDWORK  (input) int 
            //          The leading dimension of the array WORK. 
            //          If SIDE = 'L', LDWORK >= max(1,N); 
            //          if SIDE = 'R', LDWORK >= max(1,M). 

            //  ===================================================================== 

            // System generated locals 
            int c_dim1, c_offset, t_dim1, t_offset, v_dim1, v_offset, work_dim1,
                work_offset, i__1, i__2, i__3, i__4, i__5;
            complex16 z__1, z__2;

            // Table of constant values
            complex16 c_b1 = new complex16(1.0, 0.0);
            int c__1 = 1;

            // Local variables 
            int i, j;
            int lastc;
            int lastv;
            string transt;

            // Parameter adjustments 
            v_dim1 = *ldv;
            v_offset = 1 + v_dim1;
            v -= v_offset;
            t_dim1 = *ldt;
            t_offset = 1 + t_dim1;
            t -= t_offset;
            c_dim1 = *ldc;
            c_offset = 1 + c_dim1;
            c -= c_offset;
            work_dim1 = *ldwork;
            work_offset = 1 + work_dim1;
            work -= work_offset;

            // Function Body 
            if (*m <= 0 || *n <= 0)
            {
                return 0;
            }

            if (lsame(trans, "N"))
            {
                transt = "C";
            }
            else
            {
                transt = "N";
            }

            if (lsame(storev, "C"))
            {

                if (lsame(direct, "F"))
                {
                    // Let  V =  ( V1 )    (first K rows) 
                    //           ( V2 ) 
                    // where  V1  is unit lower triangular. 

                    if (lsame(side, "L"))
                    {
                        // Form  H * C  or  H' * C  where  C = ( C1 ) 
                        //                                     ( C2 ) 

                        // Computing MAX 
                        i__1 = *k;
                        i__2 = ilazlr(m, k, &v[v_offset], ldv);
                        lastv = Math.Max(i__1, i__2);
                        lastc = ilazlc(&lastv, n, &c[c_offset], ldc);

                        // W := C' * V  =  (C1'*V1 + C2'*V2)  (stored in WORK) 

                        // W := C1' 

                        i__1 = *k;
                        for (j = 1; j <= i__1; ++j)
                        {
                            zcopy(&lastc, &c[j + c_dim1], ldc, &work[j * work_dim1 + 1], &c__1);
                            zlacgv(&lastc, &work[j * work_dim1 + 1], &c__1);
                        }

                        // W := W * V1 

                        ztrmm("Right", "Lower", "No transpose", "Unit", &lastc, k,
                            &c_b1, &v[v_offset], ldv, &work[work_offset], ldwork);

                        if (lastv > *k)
                        {
                            // W := W + C2'*V2 

                            i__1 = lastv - *k;
                            zgemm("Conjugate transpose", "No transpose", &lastc, k, &i__1, &c_b1, &c[*k + 1 + c_dim1],
                                ldc, &v[*k + 1 + v_dim1], ldv, &c_b1, &work[work_offset], ldwork);
                        }

                        // W := W * T'  or  W * T 

                        ztrmm("Right", "Upper", transt, "Non-unit", &lastc, k, &c_b1,
                             &t[t_offset], ldt, &work[work_offset], ldwork);

                        // C := C - V * W' 

                        if (*m > *k)
                        {
                            // C2 := C2 - V2 * W' 

                            i__1 = lastv - *k;
                            z__1.r = -1.0;
                            z__1.i = -0.0;
                            zgemm("No transpose", "Conjugate transpose", &i__1, &lastc, k, &z__1, &v[*k + 1 + v_dim1],
                                ldv, &work[work_offset], ldwork, &c_b1, &c[*k + 1 + c_dim1], ldc);
                        }

                        // W := W * V1' 

                        ztrmm("Right", "Lower", "Conjugate transpose", "Unit", &lastc, k, &c_b1,
                            &v[v_offset], ldv, &work[work_offset], ldwork);

                        // C1 := C1 - W' 

                        i__1 = *k;
                        for (j = 1; j <= i__1; ++j)
                        {
                            i__2 = lastc;
                            for (i = 1; i <= i__2; ++i)
                            {
                                i__3 = j + i * c_dim1;
                                i__4 = j + i * c_dim1;
                                d_cnjg(&z__2, &work[i + j * work_dim1]);

                                z__1.r = c[i__4].r - z__2.r;
                                z__1.i = c[i__4].i - z__2.i;

                                c[i__3].r = z__1.r;
                                c[i__3].i = z__1.i;
                            }
                        }

                    }
                    else if (lsame(side, "R"))
                    {
                        // Form  C * H  or  C * H'  where  C = ( C1  C2 ) 

                        // Computing MAX 
                        i__1 = *k;
                        i__2 = ilazlr(n, k, &v[v_offset], ldv);
                        lastv = Math.Max(i__1, i__2);
                        lastc = ilazlr(m, &lastv, &c[c_offset], ldc);

                        // W := C * V  =  (C1*V1 + C2*V2)  (stored in WORK) 

                        // W := C1 

                        i__1 = *k;
                        for (j = 1; j <= i__1; ++j)
                        {
                            zcopy(&lastc, &c[j * c_dim1 + 1], &c__1, &work[j * work_dim1 + 1], &c__1);
                        }

                        // W := W * V1 

                        ztrmm("Right", "Lower", "No transpose", "Unit", &lastc, k, &
                            c_b1, &v[v_offset], ldv, &work[work_offset], ldwork);

                        if (lastv > *k)
                        {
                            // W := W + C2 * V2 

                            i__1 = lastv - *k;
                            zgemm("No transpose", "No transpose", &lastc, k, &i__1, &c_b1, &c[(*k + 1) * c_dim1 + 1],
                                ldc, &v[*k + 1 + v_dim1], ldv, &c_b1, &work[work_offset], ldwork);
                        }

                        // W := W * T  or  W * T' 

                        ztrmm("Right", "Upper", trans, "Non-unit", &lastc, k, &c_b1,
                            &t[t_offset], ldt, &work[work_offset], ldwork);

                        // C := C - W * V' 

                        if (lastv > *k)
                        {
                            // C2 := C2 - W * V2' 

                            i__1 = lastv - *k;
                            z__1.r = -1.0;
                            z__1.i = -0.0;
                            zgemm("No transpose", "Conjugate transpose", &lastc, &
                                i__1, k, &z__1, &work[work_offset], ldwork, &v[*k
                                + 1 + v_dim1], ldv, &c_b1, &c[(*k + 1) * c_dim1 + 1], ldc);
                        }

                        // W := W * V1' 

                        ztrmm("Right", "Lower", "Conjugate transpose", "Unit", &lastc, k, &c_b1,
                            &v[v_offset], ldv, &work[work_offset], ldwork);

                        // C1 := C1 - W 

                        i__1 = *k;
                        for (j = 1; j <= i__1; ++j)
                        {
                            i__2 = lastc;
                            for (i = 1; i <= i__2; ++i)
                            {
                                i__3 = i + j * c_dim1;
                                i__4 = i + j * c_dim1;
                                i__5 = i + j * work_dim1;

                                z__1.r = c[i__4].r - work[i__5].r;
                                z__1.i = c[i__4].i - work[i__5].i;

                                c[i__3].r = z__1.r;
                                c[i__3].i = z__1.i;
                            }
                        }
                    }

                }
                else
                {
                    // Let  V =  ( V1 ) 
                    //           ( V2 )    (last K rows) 
                    // where  V2  is unit upper triangular. 

                    if (lsame(side, "L"))
                    {
                        // Form  H * C  or  H' * C  where  C = ( C1 ) 
                        //                                     ( C2 ) 

                        // Computing MAX 
                        i__1 = *k;
                        i__2 = ilazlr(m, k, &v[v_offset], ldv);
                        lastv = Math.Max(i__1, i__2);
                        lastc = ilazlc(&lastv, n, &c[c_offset], ldc);

                        // W := C' * V  =  (C1'*V1 + C2'*V2)  (stored in WORK) 

                        // W := C2' 

                        i__1 = *k;
                        for (j = 1; j <= i__1; ++j)
                        {
                            zcopy(&lastc, &c[lastv - *k + j + c_dim1], ldc, &work[j * work_dim1 + 1], &c__1);
                            zlacgv(&lastc, &work[j * work_dim1 + 1], &c__1);
                        }

                        // W := W * V2 

                        ztrmm("Right", "Upper", "No transpose", "Unit", &lastc, k, &c_b1,
                            &v[lastv - *k + 1 + v_dim1], ldv, &work[work_offset], ldwork);

                        if (lastv > *k)
                        {
                            // W := W + C1'*V1 

                            i__1 = lastv - *k;
                            zgemm("Conjugate transpose", "No transpose", &lastc, k, &i__1, &c_b1, &c[c_offset],
                                ldc, &v[v_offset], ldv, &c_b1, &work[work_offset], ldwork);
                        }

                        // W := W * T'  or  W * T 

                        ztrmm("Right", "Lower", transt, "Non-unit", &lastc, k, &c_b1,
                             &t[t_offset], ldt, &work[work_offset], ldwork);

                        // C := C - V * W' 

                        if (lastv > *k)
                        {
                            // C1 := C1 - V1 * W' 

                            i__1 = lastv - *k;
                            z__1.r = -1.0;
                            z__1.i = -0.0;
                            zgemm("No transpose", "Conjugate transpose", &i__1, &lastc, k, &z__1, &v[v_offset],
                                ldv, &work[work_offset], ldwork, &c_b1, &c[c_offset], ldc);
                        }

                        // W := W * V2' 

                        ztrmm("Right", "Upper", "Conjugate transpose", "Unit", &lastc, k, &c_b1,
                            &v[lastv - *k + 1 + v_dim1], ldv, &work[work_offset], ldwork);

                        // C2 := C2 - W' 

                        i__1 = *k;
                        for (j = 1; j <= i__1; ++j)
                        {
                            i__2 = lastc;
                            for (i = 1; i <= i__2; ++i)
                            {
                                i__3 = lastv - *k + j + i * c_dim1;
                                i__4 = lastv - *k + j + i * c_dim1;
                                d_cnjg(&z__2, &work[i + j * work_dim1]);

                                z__1.r = c[i__4].r - z__2.r;
                                z__1.i = c[i__4].i - z__2.i;

                                c[i__3].r = z__1.r;
                                c[i__3].i = z__1.i;
                            }
                        }

                    }
                    else if (lsame(side, "R"))
                    {
                        // Form  C * H  or  C * H'  where  C = ( C1  C2 ) 

                        // Computing MAX 
                        i__1 = *k;
                        i__2 = ilazlr(n, k, &v[v_offset], ldv);
                        lastv = Math.Max(i__1, i__2);
                        lastc = ilazlr(m, &lastv, &c[c_offset], ldc);

                        // W := C * V  =  (C1*V1 + C2*V2)  (stored in WORK) 

                        // W := C2 

                        i__1 = *k;
                        for (j = 1; j <= i__1; ++j)
                        {
                            zcopy(&lastc, &c[(lastv - *k + j) * c_dim1 + 1], &c__1, &work[j * work_dim1 + 1], &c__1);
                        }

                        // W := W * V2 

                        ztrmm("Right", "Upper", "No transpose", "Unit", &lastc, k, &
                            c_b1, &v[lastv - *k + 1 + v_dim1], ldv, &work[work_offset], ldwork);

                        if (lastv > *k)
                        {
                            // W := W + C1 * V1 

                            i__1 = lastv - *k;
                            zgemm("No transpose", "No transpose", &lastc, k, &i__1, &
                                c_b1, &c[c_offset], ldc, &v[v_offset], ldv, &
                                c_b1, &work[work_offset], ldwork);
                        }

                        // W := W * T  or  W * T' 

                        ztrmm("Right", "Lower", trans, "Non-unit", &lastc, k, &c_b1,
                            &t[t_offset], ldt, &work[work_offset], ldwork);

                        // C := C - W * V' 

                        if (lastv > *k)
                        {
                            // C1 := C1 - W * V1' 

                            i__1 = lastv - *k;
                            z__1.r = -1.0;
                            z__1.i = -0.0;
                            zgemm("No transpose", "Conjugate transpose", &lastc, &i__1, k, &z__1,
                                &work[work_offset], ldwork, &v[v_offset], ldv, &c_b1, &c[c_offset], ldc);
                        }

                        // W := W * V2' 

                        ztrmm("Right", "Upper", "Conjugate transpose", "Unit", &lastc, k, &c_b1,
                            &v[lastv - *k + 1 + v_dim1], ldv, &work[work_offset], ldwork);

                        // C2 := C2 - W 

                        i__1 = *k;
                        for (j = 1; j <= i__1; ++j)
                        {
                            i__2 = lastc;
                            for (i = 1; i <= i__2; ++i)
                            {
                                i__3 = i + (lastv - *k + j) * c_dim1;
                                i__4 = i + (lastv - *k + j) * c_dim1;
                                i__5 = i + j * work_dim1;

                                z__1.r = c[i__4].r - work[i__5].r;
                                z__1.i = c[i__4].i - work[i__5].i;

                                c[i__3].r = z__1.r;
                                c[i__3].i = z__1.i;
                            }
                        }
                    }
                }

            }
            else if (lsame(storev, "R"))
            {
                if (lsame(direct, "F"))
                {
                    // Let  V =  ( V1  V2 )    (V1: first K columns) 
                    // where  V1  is unit upper triangular. 

                    if (lsame(side, "L"))
                    {
                        // Form  H * C  or  H' * C  where  C = ( C1 ) 
                        //                                     ( C2 ) 

                        // Computing MAX 
                        i__1 = *k;
                        i__2 = ilazlc(k, m, &v[v_offset], ldv);
                        lastv = Math.Max(i__1, i__2);
                        lastc = ilazlc(&lastv, n, &c[c_offset], ldc);

                        // W := C' * V'  =  (C1'*V1' + C2'*V2') (stored in WORK) 

                        // W := C1' 

                        i__1 = *k;
                        for (j = 1; j <= i__1; ++j)
                        {
                            zcopy(&lastc, &c[j + c_dim1], ldc, &work[j * work_dim1 + 1], &c__1);
                            zlacgv(&lastc, &work[j * work_dim1 + 1], &c__1);
                        }

                        // W := W * V1' 

                        ztrmm("Right", "Upper", "Conjugate transpose", "Unit", &
                            lastc, k, &c_b1, &v[v_offset], ldv, &work[work_offset], ldwork);

                        if (lastv > *k)
                        {
                            // W := W + C2'*V2' 

                            i__1 = lastv - *k;
                            zgemm("Conjugate transpose", "Conjugate transpose", &
                                lastc, k, &i__1, &c_b1, &c[*k + 1 + c_dim1],
                                ldc, &v[(*k + 1) * v_dim1 + 1], ldv, &c_b1, &work[work_offset], ldwork);
                        }

                        // W := W * T'  or  W * T 

                        ztrmm("Right", "Upper", transt, "Non-unit", &lastc, k, &c_b1,
                             &t[t_offset], ldt, &work[work_offset], ldwork);

                        // C := C - V' * W' 

                        if (lastv > *k)
                        {
                            // C2 := C2 - V2' * W' 

                            i__1 = lastv - *k;
                            z__1.r = -1.0;
                            z__1.i = -0.0;
                            zgemm("Conjugate transpose", "Conjugate transpose", &i__1, &lastc, k, &z__1, &v[(*k + 1) * v_dim1 + 1],
                                ldv, &work[work_offset], ldwork, &c_b1, &c[*k + 1 + c_dim1], ldc);
                        }

                        // W := W * V1 

                        ztrmm("Right", "Upper", "No transpose", "Unit", &lastc, k,
                            &c_b1, &v[v_offset], ldv, &work[work_offset], ldwork);

                        // C1 := C1 - W' 

                        i__1 = *k;
                        for (j = 1; j <= i__1; ++j)
                        {
                            i__2 = lastc;
                            for (i = 1; i <= i__2; ++i)
                            {
                                i__3 = j + i * c_dim1;
                                i__4 = j + i * c_dim1;
                                d_cnjg(&z__2, &work[i + j * work_dim1]);

                                z__1.r = c[i__4].r - z__2.r;
                                z__1.i = c[i__4].i - z__2.i;

                                c[i__3].r = z__1.r;
                                c[i__3].i = z__1.i;
                            }
                        }

                    }
                    else if (lsame(side, "R"))
                    {
                        // Form  C * H  or  C * H'  where  C = ( C1  C2 ) 

                        // Computing MAX 
                        i__1 = *k;
                        i__2 = ilazlc(k, n, &v[v_offset], ldv);
                        lastv = Math.Max(i__1, i__2);
                        lastc = ilazlr(m, &lastv, &c[c_offset], ldc);

                        // W := C * V'  =  (C1*V1' + C2*V2')  (stored in WORK) 

                        // W := C1 

                        i__1 = *k;
                        for (j = 1; j <= i__1; ++j)
                        {
                            zcopy(&lastc, &c[j * c_dim1 + 1], &c__1, &work[j * work_dim1 + 1], &c__1);
                        }

                        // W := W * V1' 

                        ztrmm("Right", "Upper", "Conjugate transpose", "Unit",
                            &lastc, k, &c_b1, &v[v_offset], ldv, &work[work_offset], ldwork);

                        if (lastv > *k)
                        {
                            // W := W + C2 * V2' 

                            i__1 = lastv - *k;
                            zgemm("No transpose", "Conjugate transpose", &lastc, k, &i__1, &c_b1, &c[(*k + 1) * c_dim1 + 1],
                                ldc, &v[(*k + 1) * v_dim1 + 1], ldv, &c_b1, &work[work_offset], ldwork);
                        }

                        // W := W * T  or  W * T' 

                        ztrmm("Right", "Upper", trans, "Non-unit", &lastc, k, &c_b1,
                            &t[t_offset], ldt, &work[work_offset], ldwork);

                        // C := C - W * V 

                        if (lastv > *k)
                        {
                            // C2 := C2 - W * V2 

                            i__1 = lastv - *k;
                            z__1.r = -1.0;
                            z__1.i = -0.0;
                            zgemm("No transpose", "No transpose", &lastc, &i__1, k, &z__1, &work[work_offset],
                                ldwork, &v[(*k + 1) * v_dim1 + 1], ldv, &c_b1, &c[(*k + 1) * c_dim1 + 1], ldc);
                        }

                        // W := W * V1 

                        ztrmm("Right", "Upper", "No transpose", "Unit", &lastc, k,
                            &c_b1, &v[v_offset], ldv, &work[work_offset], ldwork);

                        // C1 := C1 - W 

                        i__1 = *k;
                        for (j = 1; j <= i__1; ++j)
                        {
                            i__2 = lastc;
                            for (i = 1; i <= i__2; ++i)
                            {
                                i__3 = i + j * c_dim1;
                                i__4 = i + j * c_dim1;
                                i__5 = i + j * work_dim1;

                                z__1.r = c[i__4].r - work[i__5].r;
                                z__1.i = c[i__4].i - work[i__5].i;

                                c[i__3].r = z__1.r;
                                c[i__3].i = z__1.i;
                            }
                        }

                    }

                }
                else
                {
                    // Let  V =  ( V1  V2 )    (V2: last K columns) 
                    // where  V2  is unit lower triangular. 

                    if (lsame(side, "L"))
                    {
                        // Form  H * C  or  H' * C  where  C = ( C1 ) 
                        //                                     ( C2 ) 

                        // Computing MAX 
                        i__1 = *k;
                        i__2 = ilazlc(k, m, &v[v_offset], ldv);
                        lastv = Math.Max(i__1, i__2);
                        lastc = ilazlc(&lastv, n, &c[c_offset], ldc);

                        // W := C' * V'  =  (C1'*V1' + C2'*V2') (stored in WORK) 

                        // W := C2' 

                        i__1 = *k;
                        for (j = 1; j <= i__1; ++j)
                        {
                            zcopy(&lastc, &c[lastv - *k + j + c_dim1], ldc, &work[j * work_dim1 + 1], &c__1);
                            zlacgv(&lastc, &work[j * work_dim1 + 1], &c__1);
                        }

                        // W := W * V2' 

                        ztrmm("Right", "Lower", "Conjugate transpose", "Unit", &lastc, k, &c_b1,
                            &v[(lastv - *k + 1) * v_dim1 + 1], ldv, &work[work_offset], ldwork);

                        if (lastv > *k)
                        {
                            // W := W + C1'*V1' 

                            i__1 = lastv - *k;
                            zgemm("Conjugate transpose", "Conjugate transpose", &lastc, k, &i__1, &c_b1,
                                &c[c_offset], ldc, &v[v_offset], ldv, &c_b1, &work[work_offset], ldwork);
                        }

                        // W := W * T'  or  W * T 

                        ztrmm("Right", "Lower", transt, "Non-unit", &lastc, k, &c_b1,
                             &t[t_offset], ldt, &work[work_offset], ldwork);

                        // C := C - V' * W' 

                        if (lastv > *k)
                        {
                            // C1 := C1 - V1' * W' 

                            i__1 = lastv - *k;
                            z__1.r = -1.0;
                            z__1.i = -0.0;
                            zgemm("Conjugate transpose", "Conjugate transpose", &
                                i__1, &lastc, k, &z__1, &v[v_offset], ldv, &work[
                                work_offset], ldwork, &c_b1, &c[c_offset], ldc);
                        }

                        // W := W * V2 

                        ztrmm("Right", "Lower", "No transpose", "Unit", &lastc, k,
                            &c_b1, &v[(lastv - *k + 1) * v_dim1 + 1], ldv, &work[work_offset], ldwork);

                        // C2 := C2 - W' 

                        i__1 = *k;
                        for (j = 1; j <= i__1; ++j)
                        {
                            i__2 = lastc;
                            for (i = 1; i <= i__2; ++i)
                            {
                                i__3 = lastv - *k + j + i * c_dim1;
                                i__4 = lastv - *k + j + i * c_dim1;
                                d_cnjg(&z__2, &work[i + j * work_dim1]);

                                z__1.r = c[i__4].r - z__2.r;
                                z__1.i = c[i__4].i - z__2.i;

                                c[i__3].r = z__1.r;
                                c[i__3].i = z__1.i;
                            }
                        }

                    }
                    else if (lsame(side, "R"))
                    {
                        // Form  C * H  or  C * H'  where  C = ( C1  C2 ) 

                        // Computing MAX 
                        i__1 = *k;
                        i__2 = ilazlc(k, n, &v[v_offset], ldv);
                        lastv = Math.Max(i__1, i__2);
                        lastc = ilazlr(m, &lastv, &c[c_offset], ldc);

                        // W := C * V'  =  (C1*V1' + C2*V2')  (stored in WORK) 

                        // W := C2 

                        i__1 = *k;
                        for (j = 1; j <= i__1; ++j)
                        {
                            zcopy(&lastc, &c[(lastv - *k + j) * c_dim1 + 1], &c__1,
                                 &work[j * work_dim1 + 1], &c__1);
                        }

                        // W := W * V2' 

                        ztrmm("Right", "Lower", "Conjugate transpose", "Unit", &lastc, k, &c_b1,
                            &v[(lastv - *k + 1) * v_dim1 + 1], ldv, &work[work_offset], ldwork);

                        if (lastv > *k)
                        {
                            // W := W + C1 * V1' 

                            i__1 = lastv - *k;
                            zgemm("No transpose", "Conjugate transpose", &lastc, k, &i__1, &c_b1, &c[c_offset],
                                ldc, &v[v_offset], ldv, &c_b1, &work[work_offset], ldwork);
                        }

                        // W := W * T  or  W * T' 

                        ztrmm("Right", "Lower", trans, "Non-unit", &lastc, k, &c_b1,
                            &t[t_offset], ldt, &work[work_offset], ldwork);

                        // C := C - W * V 

                        if (lastv > *k)
                        {
                            // C1 := C1 - W * V1 

                            i__1 = lastv - *k;
                            z__1.r = -1.0;
                            z__1.i = -0.0;
                            zgemm("No transpose", "No transpose", &lastc, &i__1, k, &z__1, &work[work_offset],
                                ldwork, &v[v_offset], ldv, &c_b1, &c[c_offset], ldc);
                        }

                        // W := W * V2 

                        ztrmm("Right", "Lower", "No transpose", "Unit", &lastc, k, &c_b1,
                            &v[(lastv - *k + 1) * v_dim1 + 1], ldv, &work[work_offset], ldwork);

                        // C1 := C1 - W 

                        i__1 = *k;
                        for (j = 1; j <= i__1; ++j)
                        {
                            i__2 = lastc;
                            for (i = 1; i <= i__2; ++i)
                            {
                                i__3 = i + (lastv - *k + j) * c_dim1;
                                i__4 = i + (lastv - *k + j) * c_dim1;
                                i__5 = i + j * work_dim1;

                                z__1.r = c[i__4].r - work[i__5].r;
                                z__1.i = c[i__4].i - work[i__5].i;

                                c[i__3].r = z__1.r;
                                c[i__3].i = z__1.i;
                            }
                        }

                    }

                }
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zlarfg(int* n, complex16* alpha, complex16* x, int* incx, complex16* tau)
        {
            //  -- LAPACK auxiliary routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. 
            //     November 2006 

            //  Purpose 
            //  ======= 

            //  ZLARFG generates a complex elementary reflector H of order n, such 
            //  that 

            //        H' * ( alpha ) = ( beta ),   H' * H = I. 
            //             (   x   )   (   0  ) 

            //  where alpha and beta are scalars, with beta real, and x is an 
            //  (n-1)-element complex vector. H is represented in the form 

            //        H = I - tau * ( 1 ) * ( 1 v' ) , 
            //                      ( v ) 

            //  where tau is a complex scalar and v is a complex (n-1)-element 
            //  vector. Note that H is not hermitian. 

            //  If the elements of x are all zero and alpha is real, then tau = 0 
            //  and H is taken to be the unit matrix. 

            //  Otherwise  1 <= real(tau) <= 2  and  abs(tau-1) <= 1 . 

            //  Arguments 
            //  ========= 

            //  N       (input) int 
            //          The order of the elementary reflector. 

            //  ALPHA   (input/output) COMPLEX*16 
            //          On entry, the value alpha. 
            //          On exit, it is overwritten with the value beta. 

            //  X       (input/output) COMPLEX*16 array, dimension 
            //                         (1+(N-2)*abs(INCX)) 
            //          On entry, the vector x. 
            //          On exit, it is overwritten with the vector v. 

            //  INCX    (input) int 
            //          The increment between elements of X. INCX > 0. 

            //  TAU     (output) COMPLEX*16 
            //          The value tau. 

            //  ===================================================================== 

            // System generated locals 
            int i__1;
            double d__1, d__2;
            complex16 z__1, z__2;

            // Table of constant values
            complex16 c_b5 = new complex16(1.0, 0.0);

            // Local variables 
            int j, knt;
            double beta, alphi, alphr;
            double xnorm;
            double safmin;
            double rsafmn;

            // Parameter adjustments 
            --x;

            // Function Body 
            if (*n <= 0)
            {
                tau.r = 0.0;
                tau.i = 0.0;
                return 0;
            }

            i__1 = *n - 1;
            xnorm = dznrm2(&i__1, &x[1], incx);
            alphr = alpha.r;
            alphi = d_imag(alpha);

            if (xnorm == 0.0 && alphi == 0.0)
            {
                // H  =  I 
                tau.r = 0.0;
                tau.i = 0.0;
            }
            else
            {
                // general case 

                d__1 = dlapy3(&alphr, &alphi, &xnorm);
                beta = -d_sign(&d__1, &alphr);
                safmin = dlamch("S") / dlamch("E");
                rsafmn = 1.0 / safmin;

                knt = 0;
                if (Math.Abs(beta) < safmin)
                {
                    // XNORM, BETA may be inaccurate; scale X and recompute them 

                L10:
                    ++knt;
                    i__1 = *n - 1;
                    zdscal(&i__1, &rsafmn, &x[1], incx);
                    beta *= rsafmn;
                    alphi *= rsafmn;
                    alphr *= rsafmn;
                    if (Math.Abs(beta) < safmin)
                    {
                        goto L10;
                    }

                    // New BETA is at most 1, at least SAFMIN 

                    i__1 = *n - 1;
                    xnorm = dznrm2(&i__1, &x[1], incx);

                    z__1.r = alphr;
                    z__1.i = alphi;

                    alpha.r = z__1.r;
                    alpha.i = z__1.i;

                    d__1 = dlapy3(&alphr, &alphi, &xnorm);
                    beta = -d_sign(&d__1, &alphr);
                }

                d__1 = (beta - alphr) / beta;
                d__2 = -alphi / beta;

                z__1.r = d__1;
                z__1.i = d__2;

                tau.r = z__1.r;
                tau.i = z__1.i;

                z__2.r = alpha.r - beta;
                z__2.i = alpha.i;

                zladiv(&z__1, &c_b5, &z__2);

                alpha.r = z__1.r;
                alpha.i = z__1.i;
                i__1 = *n - 1;

                zscal(&i__1, alpha, &x[1], incx);

                // If ALPHA is subnormal, it may lose relative accuracy 

                i__1 = knt;
                for (j = 1; j <= i__1; ++j)
                {
                    beta *= safmin;
                }

                alpha.r = beta;
                alpha.i = 0.0;
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zlarfp(int* n, complex16* alpha, complex16* x, int* incx, complex16* tau)
        {
            //  -- LAPACK auxiliary routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     November 2006

            //  Purpose
            //  =======

            //  ZLARFP generates a complex elementary reflector H of order n, such
            //  that

            //        H' * ( alpha ) = ( beta ),   H' * H = I.
            //             (   x   )   (   0  )

            //  where alpha and beta are scalars, beta is real and non-negative, and
            //  x is an (n-1)-element complex vector.  H is represented in the form

            //        H = I - tau * ( 1 ) * ( 1 v' ) ,
            //                      ( v )

            //  where tau is a complex scalar and v is a complex (n-1)-element
            //  vector. Note that H is not hermitian.

            //  If the elements of x are all zero and alpha is real, then tau = 0
            //  and H is taken to be the unit matrix.

            //  Otherwise  1 <= real(tau) <= 2  and  abs(tau-1) <= 1 .

            //  Arguments
            //  =========

            //  N       (input) int
            //          The order of the elementary reflector.

            //  ALPHA   (input/output) COMPLEX*16
            //          On entry, the value alpha.
            //          On exit, it is overwritten with the value beta.

            //  X       (input/output) COMPLEX*16 array, dimension
            //                         (1+(N-2)*abs(INCX))
            //          On entry, the vector x.
            //          On exit, it is overwritten with the vector v.

            //  INCX    (input) int
            //          The increment between elements of X. INCX > 0.

            //  TAU     (output) COMPLEX*16
            //          The value tau.

            //  =====================================================================

            // System generated locals
            int i__1, i__2;
            double d__1, d__2;
            complex16 z__1, z__2;

            // Table of constant values
            complex16 c_b5 = new complex16(1.0, 0.0);

            // Local variables
            int j, knt;
            double beta, alphi, alphr;
            double xnorm;
            double safmin;
            double rsafmn;

            // Parameter adjustments
            --x;

            // Function Body
            if (*n <= 0)
            {
                tau.r = 0.0;
                tau.i = 0.0;
                return 0;
            }

            i__1 = *n - 1;
            xnorm = dznrm2(&i__1, &x[1], incx);
            alphr = alpha.r;
            alphi = d_imag(alpha);

            if (xnorm == 0.0 && alphi == 0.0)
            {
                // H  =  [1-alpha/abs(alpha) 0; 0 I], sign chosen so ALPHA >= 0.

                if (alphi == 0.0)
                {
                    if (alphr >= 0.0)
                    {
                        // When TAU.eq.ZERO, the vector is special-cased to be
                        // all zeros in the application routines.  We do not need
                        // to clear it.
                        tau.r = 0.0;
                        tau.i = 0.0;
                    }
                    else
                    {
                        // However, the application routines rely on explicit
                        // zero checks when TAU.ne.ZERO, and we must clear X.
                        tau.r = 2.0;
                        tau.i = 0.0;

                        i__1 = *n - 1;
                        for (j = 1; j <= i__1; ++j)
                        {
                            i__2 = (j - 1) * *incx + 1;
                            x[i__2].r = 0.0;
                            x[i__2].i = 0.0;
                        }
                        z__1.r = -alpha.r;
                        z__1.i = -alpha.i;

                        alpha.r = z__1.r;
                        alpha.i = z__1.i;
                    }
                }
                else
                {
                    // Only "reflecting" the diagonal entry to be real and non-negative.
                    xnorm = dlapy2(&alphr, &alphi);
                    d__1 = 1.0 - alphr / xnorm;
                    d__2 = -alphi / xnorm;

                    z__1.r = d__1;
                    z__1.i = d__2;

                    tau.r = z__1.r;
                    tau.i = z__1.i;

                    i__1 = *n - 1;
                    for (j = 1; j <= i__1; ++j)
                    {
                        i__2 = (j - 1) * *incx + 1;
                        x[i__2].r = 0.0;
                        x[i__2].i = 0.0;
                    }

                    alpha.r = xnorm;
                    alpha.i = 0.0;
                }
            }
            else
            {
                // general case
                d__1 = dlapy3(&alphr, &alphi, &xnorm);
                beta = d_sign(&d__1, &alphr);
                safmin = dlamch("S") / dlamch("E");
                rsafmn = 1.0 / safmin;

                knt = 0;
                if (Math.Abs(beta) < safmin)
                {
                // XNORM, BETA may be inaccurate; scale X and recompute them

                    L10:
                    ++knt;
                    i__1 = *n - 1;
                    zdscal(&i__1, &rsafmn, &x[1], incx);
                    beta *= rsafmn;
                    alphi *= rsafmn;
                    alphr *= rsafmn;

                    if (Math.Abs(beta) < safmin)
                    {
                        goto L10;
                    }

                    // New BETA is at most 1, at least SAFMIN

                    i__1 = *n - 1;
                    xnorm = dznrm2(&i__1, &x[1], incx);
                    z__1.r = alphr;
                    z__1.i = alphi;
                    alpha.r = z__1.r;
                    alpha.i = z__1.i;
                    d__1 = dlapy3(&alphr, &alphi, &xnorm);
                    beta = d_sign(&d__1, &alphr);
                }
                z__1.r = alpha.r + beta;
                z__1.i = alpha.i;

                alpha.r = z__1.r;
                alpha.i = z__1.i;

                if (beta < 0.0)
                {
                    beta = -beta;

                    z__2.r = -alpha.r;
                    z__2.i = -alpha.i;

                    z__1.r = z__2.r / beta;
                    z__1.i = z__2.i / beta;

                    tau.r = z__1.r;
                    tau.i = z__1.i;
                }
                else
                {
                    alphr = alphi * (alphi / alpha.r);
                    alphr += xnorm * (xnorm / alpha.r);

                    d__1 = alphr / beta;
                    d__2 = -alphi / beta;

                    z__1.r = d__1;
                    z__1.i = d__2;

                    tau.r = z__1.r;
                    tau.i = z__1.i;

                    d__1 = -alphr;

                    z__1.r = d__1;
                    z__1.i = alphi;

                    alpha.r = z__1.r;
                    alpha.i = z__1.i;
                }
                zladiv(&z__1, &c_b5, alpha);

                alpha.r = z__1.r;
                alpha.i = z__1.i;

                i__1 = *n - 1;
                zscal(&i__1, alpha, &x[1], incx);

                // If BETA is subnormal, it may lose relative accuracy

                i__1 = knt;
                for (j = 1; j <= i__1; ++j)
                {
                    beta *= safmin;
                }
                alpha.r = beta;
                alpha.i = 0.0;
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zlarft(string direct, string storev, int* n, int* k,
            complex16* v, int* ldv, complex16* tau, complex16* t, int* ldt)
        {
            //  -- LAPACK auxiliary routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. 
            //     November 2006 

            //  Purpose 
            //  ======= 

            //  ZLARFT forms the triangular factor T of a complex block reflector H 
            //  of order n, which is defined as a product of k elementary reflectors. 

            //  If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular; 

            //  If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular. 

            //  If STOREV = 'C', the vector which defines the elementary reflector 
            //  H(i) is stored in the i-th column of the array V, and 

            //     H  =  I - V * T * V' 

            //  If STOREV = 'R', the vector which defines the elementary reflector 
            //  H(i) is stored in the i-th row of the array V, and 

            //     H  =  I - V' * T * V 

            //  Arguments 
            //  ========= 

            //  DIRECT  (input) CHARACTER*1 
            //          Specifies the order in which the elementary reflectors are 
            //          multiplied to form the block reflector: 
            //          = 'F': H = H(1) H(2) . . . H(k) (Forward) 
            //          = 'B': H = H(k) . . . H(2) H(1) (Backward) 

            //  STOREV  (input) CHARACTER*1 
            //          Specifies how the vectors which define the elementary 
            //          reflectors are stored (see also Further Details): 
            //          = 'C': columnwise 
            //          = 'R': rowwise 

            //  N       (input) int 
            //          The order of the block reflector H. N >= 0. 

            //  K       (input) int 
            //          The order of the triangular factor T (= the number of 
            //          elementary reflectors). K >= 1. 

            //  V       (input/output) COMPLEX*16 array, dimension 
            //                               (LDV,K) if STOREV = 'C' 
            //                               (LDV,N) if STOREV = 'R' 
            //          The matrix V. See further details. 

            //  LDV     (input) int 
            //          The leading dimension of the array V. 
            //          If STOREV = 'C', LDV >= max(1,N); if STOREV = 'R', LDV >= K. 

            //  TAU     (input) COMPLEX*16 array, dimension (K) 
            //          TAU(i) must contain the scalar factor of the elementary 
            //          reflector H(i). 

            //  T       (output) COMPLEX*16 array, dimension (LDT,K) 
            //          The k by k triangular factor T of the block reflector. 
            //          If DIRECT = 'F', T is upper triangular; if DIRECT = 'B', T is 
            //          lower triangular. The rest of the array is not used. 

            //  LDT     (input) int 
            //          The leading dimension of the array T. LDT >= K. 

            //  Further Details 
            //  =============== 

            //  The shape of the matrix V and the storage of the vectors which define 
            //  the H(i) is best illustrated by the following example with n = 5 and 
            //  k = 3. The elements equal to 1 are not stored; the corresponding 
            //  array elements are modified but restored on exit. The rest of the 
            //  array is not used. 

            //  DIRECT = 'F' and STOREV = 'C':         DIRECT = 'F' and STOREV = 'R': 

            //               V = (  1       )                 V = (  1 v1 v1 v1 v1 ) 
            //                   ( v1  1    )                     (     1 v2 v2 v2 ) 
            //                   ( v1 v2  1 )                     (        1 v3 v3 ) 
            //                   ( v1 v2 v3 ) 
            //                   ( v1 v2 v3 ) 

            //  DIRECT = 'B' and STOREV = 'C':         DIRECT = 'B' and STOREV = 'R': 

            //               V = ( v1 v2 v3 )                 V = ( v1 v1  1       ) 
            //                   ( v1 v2 v3 )                     ( v2 v2 v2  1    ) 
            //                   (  1 v2 v3 )                     ( v3 v3 v3 v3  1 ) 
            //                   (     1 v3 ) 
            //                   (        1 ) 

            //  ===================================================================== 

            // System generated locals 
            int t_dim1, t_offset, v_dim1, v_offset, i__1, i__2, i__3, i__4;
            complex16 z__1;

            // Table of constant values
            complex16 c_b2 = new complex16(0.0, 0.0);
            int c__1 = 1;

            // Local variables 
            int i, j, prevlastv;
            complex16 vii;
            int lastv;

            // Parameter adjustments 
            v_dim1 = *ldv;
            v_offset = 1 + v_dim1;
            v -= v_offset;
            --tau;
            t_dim1 = *ldt;
            t_offset = 1 + t_dim1;
            t -= t_offset;

            // Function Body 
            if (*n == 0)
            {
                return 0;
            }

            if (lsame(direct, "F"))
            {
                prevlastv = *n;
                i__1 = *k;

                for (i = 1; i <= i__1; ++i)
                {
                    prevlastv = Math.Max(prevlastv, i);
                    i__2 = i;
                    if (tau[i__2].r == 0.0 && tau[i__2].i == 0.0)
                    {
                        // H(i)  =  I 
                        i__2 = i;
                        for (j = 1; j <= i__2; ++j)
                        {
                            i__3 = j + i * t_dim1;

                            t[i__3].r = 0.0;
                            t[i__3].i = 0.0;
                        }
                    }
                    else
                    {
                        // general case 

                        i__2 = i + i * v_dim1;

                        vii.r = v[i__2].r;
                        vii.i = v[i__2].i;

                        i__2 = i + i * v_dim1;

                        v[i__2].r = 1.0;
                        v[i__2].i = 0.0;

                        if (lsame(storev, "C"))
                        {
                            // Skip any trailing zeros. 
                            i__2 = i + 1;

                            for (lastv = *n; lastv >= i__2; --lastv)
                            {
                                i__3 = lastv + i * v_dim1;

                                if (v[i__3].r != 0.0 || v[i__3].i != 0.0)
                                {
                                    break;
                                }
                            }

                            j = Math.Min(lastv, prevlastv);

                            // T(1:i-1,i) := - tau(i) * V(i:j,1:i-1)' * V(i:j,i) 

                            i__2 = j - i + 1;
                            i__3 = i - 1;
                            i__4 = i;

                            z__1.r = -tau[i__4].r;
                            z__1.i = -tau[i__4].i;

                            zgemv("Conjugate transpose", &i__2, &i__3, &z__1, &v[i
                                + v_dim1], ldv, &v[i + i * v_dim1], &c__1, &
                                c_b2, &t[i * t_dim1 + 1], &c__1);
                        }
                        else
                        {
                            // Skip any trailing zeros. 
                            i__2 = i + 1;

                            for (lastv = *n; lastv >= i__2; --lastv)
                            {
                                i__3 = i + lastv * v_dim1;
                                if (v[i__3].r != 0.0 || v[i__3].i != 0.0)
                                {
                                    break;
                                }
                            }
                            j = Math.Min(lastv, prevlastv);

                            // T(1:i-1,i) := - tau(i) * V(1:i-1,i:j) * V(i,i:j)' 

                            if (i < j)
                            {
                                i__2 = j - i;
                                zlacgv(&i__2, &v[i + (i + 1) * v_dim1], ldv);
                            }

                            i__2 = i - 1;
                            i__3 = j - i + 1;
                            i__4 = i;

                            z__1.r = -tau[i__4].r;
                            z__1.i = -tau[i__4].i;

                            zgemv("No transpose", &i__2, &i__3, &z__1, &v[i *
                                v_dim1 + 1], ldv, &v[i + i * v_dim1], ldv, &
                                c_b2, &t[i * t_dim1 + 1], &c__1);

                            if (i < j)
                            {
                                i__2 = j - i;
                                zlacgv(&i__2, &v[i + (i + 1) * v_dim1], ldv);
                            }
                        }

                        i__2 = i + i * v_dim1;
                        v[i__2].r = vii.r;
                        v[i__2].i = vii.i;

                        // T(1:i-1,i) := T(1:i-1,1:i-1) * T(1:i-1,i) 

                        i__2 = i - 1;
                        ztrmv("Upper", "No transpose", "Non-unit", &i__2,
                            &t[t_offset], ldt, &t[i * t_dim1 + 1], &c__1);

                        i__2 = i + i * t_dim1;
                        i__3 = i;

                        t[i__2].r = tau[i__3].r;
                        t[i__2].i = tau[i__3].i;

                        if (i > 1)
                        {
                            prevlastv = Math.Max(prevlastv, lastv);
                        }
                        else
                        {
                            prevlastv = lastv;
                        }
                    }
                }
            }
            else
            {
                prevlastv = 1;
                for (i = *k; i >= 1; --i)
                {
                    i__1 = i;

                    if (tau[i__1].r == 0.0 && tau[i__1].i == 0.0)
                    {
                        // H(i)  =  I 
                        i__1 = *k;
                        for (j = i; j <= i__1; ++j)
                        {
                            i__2 = j + i * t_dim1;
                            t[i__2].r = 0.0;
                            t[i__2].i = 0.0;
                        }
                    }
                    else
                    {
                        // general case 
                        if (i < *k)
                        {
                            if (lsame(storev, "C"))
                            {
                                i__1 = *n - *k + i + i * v_dim1;

                                vii.r = v[i__1].r;
                                vii.i = v[i__1].i;

                                i__1 = *n - *k + i + i * v_dim1;


                                v[i__1].r = 1.0;
                                v[i__1].i = 0.0;

                                // Skip any leading zeros. 
                                i__1 = i - 1;

                                for (lastv = 1; lastv <= i__1; ++lastv)
                                {
                                    i__2 = lastv + i * v_dim1;

                                    if (v[i__2].r != 0.0 || v[i__2].i != 0.0)
                                    {
                                        break;
                                    }
                                }

                                j = Math.Max(lastv, prevlastv);

                                // T(i+1:k,i) := 
                                // - tau(i) * V(j:n-k+i,i+1:k)' * V(j:n-k+i,i) 

                                i__1 = *n - *k + i - j + 1;
                                i__2 = *k - i;
                                i__3 = i;

                                z__1.r = -tau[i__3].r;
                                z__1.i = -tau[i__3].i;

                                zgemv("Conjugate transpose", &i__1, &i__2, &z__1,
                                    &v[j + (i + 1) * v_dim1], ldv, &v[j + i *
                                    v_dim1], &c__1, &c_b2, &t[i + 1 + i * t_dim1], &c__1);

                                i__1 = *n - *k + i + i * v_dim1;

                                v[i__1].r = vii.r;
                                v[i__1].i = vii.i;
                            }
                            else
                            {
                                i__1 = i + (*n - *k + i) * v_dim1;

                                vii.r = v[i__1].r;
                                vii.i = v[i__1].i;

                                i__1 = i + (*n - *k + i) * v_dim1;

                                v[i__1].r = 1.0;
                                v[i__1].i = 0.0;

                                // Skip any leading zeros. 
                                i__1 = i - 1;

                                for (lastv = 1; lastv <= i__1; ++lastv)
                                {
                                    i__2 = i + lastv * v_dim1;

                                    if (v[i__2].r != 0.0 || v[i__2].i != 0.0)
                                    {
                                        break;
                                    }
                                }

                                j = Math.Max(lastv, prevlastv);

                                // T(i+1:k,i) := 
                                // - tau(i) * V(i+1:k,j:n-k+i) * V(i,j:n-k+i)' 

                                i__1 = *n - *k + i - 1 - j + 1;
                                zlacgv(&i__1, &v[i + j * v_dim1], ldv);
                                i__1 = *k - i;
                                i__2 = *n - *k + i - j + 1;
                                i__3 = i;

                                z__1.r = -tau[i__3].r;
                                z__1.i = -tau[i__3].i;

                                zgemv("No transpose", &i__1, &i__2, &z__1, &v[i +
                                    1 + j * v_dim1], ldv, &v[i + j * v_dim1],
                                    ldv, &c_b2, &t[i + 1 + i * t_dim1], &c__1);

                                i__1 = *n - *k + i - 1 - j + 1;
                                zlacgv(&i__1, &v[i + j * v_dim1], ldv);
                                i__1 = i + (*n - *k + i) * v_dim1;

                                v[i__1].r = vii.r;
                                v[i__1].i = vii.i;
                            }

                            // T(i+1:k,i) := T(i+1:k,i+1:k) * T(i+1:k,i) 

                            i__1 = *k - i;
                            ztrmv("Lower", "No transpose", "Non-unit", &i__1, &t[i
                                + 1 + (i + 1) * t_dim1], ldt, &t[i + 1 + i * t_dim1], &c__1);

                            if (i > 1)
                            {
                                prevlastv = Math.Min(prevlastv, lastv);
                            }
                            else
                            {
                                prevlastv = lastv;
                            }
                        }

                        i__1 = i + i * t_dim1;
                        i__2 = i;

                        t[i__1].r = tau[i__2].r;
                        t[i__1].i = tau[i__2].i;
                    }
                }
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zlartg(complex16* f, complex16* g, double* cs, complex16* sn, complex16* r)
        {
            //  -- LAPACK auxiliary routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. 
            //     November 2006 

            //  Purpose 
            //  ======= 

            //  ZLARTG generates a plane rotation so that 

            //     [  CS  SN  ]     [ F ]     [ R ] 
            //     [  __      ]  .  [   ]  =  [   ]   where CS**2 + |SN|**2 = 1. 
            //     [ -SN  CS  ]     [ G ]     [ 0 ] 

            //  This is a faster version of the BLAS1 routine ZROTG, except for 
            //  the following differences: 
            //     F and G are unchanged on return. 
            //     If G=0, then CS=1 and SN=0. 
            //     If F=0, then CS=0 and SN is chosen so that R is real. 

            //  Arguments 
            //  ========= 

            //  F       (input) COMPLEX*16 
            //          The first component of vector to be rotated. 

            //  G       (input) COMPLEX*16 
            //          The second component of vector to be rotated. 

            //  CS      (output) DOUBLE PRECISION 
            //          The cosine of the rotation. 

            //  SN      (output) COMPLEX*16 
            //          The sine of the rotation. 

            //  R       (output) COMPLEX*16 
            //          The nonzero component of the rotated vector. 

            //  Further Details 
            //  ======= ======= 

            //  3-5-96 - Modified with a new algorithm by W. Kahan and J. Demmel 

            //  This version has a few statements commented out for thread safety 
            //  (machine parameters are computed on each entry). 10 feb 03, SJH. 

            //  ===================================================================== 

            // System generated locals 
            int i__1;
            double d__1, d__2, d__3, d__4, d__5, d__6, d__7, d__8, d__9, d__10;
            complex16 z__1, z__2, z__3;

            // Local variables 
            double d;
            int i;
            double f2, g2;
            complex16 ff;
            double di, dr;
            complex16 fs, gs;
            double f2s, g2s, eps, scale;
            int count;
            double safmn2;
            double safmx2;
            double safmin;

            // IF( FIRST ) THEN 
            safmin = dlamch("S");
            eps = dlamch("E");
            d__1 = dlamch("B");
            i__1 = (int)(Math.Log(safmin / eps) / Math.Log(dlamch("B")) / 2.0);
            safmn2 = pow_di(&d__1, &i__1);
            safmx2 = 1.0 / safmn2;

            // FIRST = .FALSE. 
            // END IF 
            // Computing MAX 
            // Computing MAX 

            d__7 = Math.Abs(f.r);
            d__8 = Math.Abs(d_imag(f));
            // Computing MAX 
            d__9 = Math.Abs(g.r);
            d__10 = Math.Abs(d_imag(g));

            d__5 = Math.Max(d__7, d__8);
            d__6 = Math.Max(d__9, d__10);
            scale = Math.Max(d__5, d__6);

            fs.r = f.r;
            fs.i = f.i;

            gs.r = g.r;
            gs.i = g.i;
            count = 0;

            if (scale >= safmx2)
            {
            L10:
                ++count;
                z__1.r = safmn2 * fs.r;
                z__1.i = safmn2 * fs.i;

                fs.r = z__1.r;
                fs.i = z__1.i;

                z__1.r = safmn2 * gs.r;
                z__1.i = safmn2 * gs.i;

                gs.r = z__1.r;
                gs.i = z__1.i;

                scale *= safmn2;

                if (scale >= safmx2)
                {
                    goto L10;
                }
            }
            else if (scale <= safmn2)
            {
                if (g.r == 0.0 && g.i == 0.0)
                {
                    *cs = 1.0;
                    sn.r = 0.0;
                    sn.i = 0.0;

                    r.r = f.r;
                    r.i = f.i;
                    return 0;
                }
            L20:
                --count;
                z__1.r = safmx2 * fs.r;
                z__1.i = safmx2 * fs.i;

                fs.r = z__1.r;
                fs.i = z__1.i;

                z__1.r = safmx2 * gs.r;
                z__1.i = safmx2 * gs.i;

                gs.r = z__1.r;
                gs.i = z__1.i;

                scale *= safmx2;

                if (scale <= safmn2)
                {
                    goto L20;
                }
            }

            // Computing 2nd power 
            d__1 = fs.r;
            // Computing 2nd power 
            d__2 = d_imag(&fs);
            f2 = d__1 * d__1 + d__2 * d__2;
            // Computing 2nd power 
            d__1 = gs.r;
            // Computing 2nd power 
            d__2 = d_imag(&gs);
            g2 = d__1 * d__1 + d__2 * d__2;

            if (f2 <= Math.Max(g2, 1.0) * safmin)
            {
                // This is a rare case: F is very small. 

                if (f.r == 0.0 && f.i == 0.0)
                {
                    *cs = 0.0;
                    d__2 = g.r;
                    d__3 = d_imag(g);
                    d__1 = dlapy2(&d__2, &d__3);

                    r.r = d__1;
                    r.i = 0.0;

                    // Do complex/real division explicitly with two real divisions 
                    d__1 = gs.r;
                    d__2 = d_imag(&gs);
                    d = dlapy2(&d__1, &d__2);
                    d__1 = gs.r / d;
                    d__2 = -d_imag(&gs) / d;

                    z__1.r = d__1;
                    z__1.i = d__2;

                    sn.r = z__1.r;
                    sn.i = z__1.i;
                    return 0;
                }

                d__1 = fs.r;
                d__2 = d_imag(&fs);
                f2s = dlapy2(&d__1, &d__2);

                // G2 and G2S are accurate 
                // G2 is at least SAFMIN, and G2S is at least SAFMN2 
                g2s = Math.Sqrt(g2);
                // Error in CS from underflow in F2S is at most 
                // UNFL / SAFMN2 .lt. sqrt(UNFL*EPS) .lt. EPS 
                // If MAX(G2,ONE)=G2, then F2 .lt. G2*SAFMIN, 
                // and so CS .lt. sqrt(SAFMIN) 
                // If MAX(G2,ONE)=ONE, then F2 .lt. SAFMIN 
                // and so CS .lt. sqrt(SAFMIN)/SAFMN2 = sqrt(EPS) 
                // Therefore, CS = F2S/G2S / sqrt( 1 + (F2S/G2S)**2 ) = F2S/G2S 
                *cs = f2s / g2s;
                // Make sure abs(FF) = 1 
                // Do complex/real division explicitly with 2 real divisions 
                // Computing MAX 
                d__3 = Math.Abs(f.r);
                d__4 = Math.Abs(d_imag(f));

                if (Math.Max(d__3, d__4) > 1.0)
                {
                    d__1 = f.r;
                    d__2 = d_imag(f);
                    d = dlapy2(&d__1, &d__2);
                    d__1 = f.r / d;
                    d__2 = d_imag(f) / d;

                    z__1.r = d__1;
                    z__1.i = d__2;

                    ff.r = z__1.r;
                    ff.i = z__1.i;
                }
                else
                {
                    dr = safmx2 * f.r;
                    di = safmx2 * d_imag(f);
                    d = dlapy2(&dr, &di);

                    d__1 = dr / d;
                    d__2 = di / d;

                    z__1.r = d__1;
                    z__1.i = d__2;

                    ff.r = z__1.r;
                    ff.i = z__1.i;
                }

                d__1 = gs.r / g2s;
                d__2 = -d_imag(&gs) / g2s;

                z__2.r = d__1;
                z__2.i = d__2;

                z__1.r = ff.r * z__2.r - ff.i * z__2.i;
                z__1.i = ff.r * z__2.i + ff.i * z__2.r;

                sn.r = z__1.r;
                sn.i = z__1.i;

                z__2.r = *cs * f.r;
                z__2.i = *cs * f.i;

                z__3.r = sn.r * g.r - sn.i * g.i;
                z__3.i = sn.r * g.i + sn.i * g.r;

                z__1.r = z__2.r + z__3.r;
                z__1.i = z__2.i + z__3.i;

                r.r = z__1.r;
                r.i = z__1.i;
            }
            else
            {
                // This is the most common case. 
                // Neither F2 nor F2/G2 are less than SAFMIN 
                // F2S cannot overflow, and it is accurate 

                f2s = Math.Sqrt(g2 / f2 + 1.0);
                // Do the F2S(real)*FS(complex) multiply with two real multiplies 
                d__1 = f2s * fs.r;
                d__2 = f2s * d_imag(&fs);

                z__1.r = d__1;
                z__1.i = d__2;

                r.r = z__1.r;
                r.i = z__1.i;

                *cs = 1.0 / f2s;
                d = f2 + g2;
                // Do complex/real division explicitly with two real divisions 
                d__1 = r.r / d;
                d__2 = d_imag(r) / d;

                z__1.r = d__1;
                z__1.i = d__2;

                sn.r = z__1.r;
                sn.i = z__1.i;

                d_cnjg(&z__2, &gs);

                z__1.r = sn.r * z__2.r - sn.i * z__2.i;
                z__1.i = sn.r * z__2.i + sn.i * z__2.r;

                sn.r = z__1.r;
                sn.i = z__1.i;

                if (count != 0)
                {
                    if (count > 0)
                    {
                        i__1 = count;
                        for (i = 1; i <= i__1; ++i)
                        {
                            z__1.r = safmx2 * r.r;
                            z__1.i = safmx2 * r.i;

                            r.r = z__1.r;
                            r.i = z__1.i;
                        }
                    }
                    else
                    {
                        i__1 = -count;
                        for (i = 1; i <= i__1; ++i)
                        {
                            z__1.r = safmn2 * r.r;
                            z__1.i = safmn2 * r.i;

                            r.r = z__1.r;
                            r.i = z__1.i;
                        }
                    }
                }
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zlascl(string type, int* kl, int* ku, double* cfrom,
            double* cto, int* m, int* n, complex16* a, int* lda, int* info)
        {
            //  -- LAPACK auxiliary routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. 
            //     November 2006 

            //  Purpose 
            //  ======= 

            //  ZLASCL multiplies the M by N complex matrix A by the real scalar 
            //  CTO/CFROM.  This is done without over/underflow as int as the final 
            //  result CTO*A(I,J)/CFROM does not over/underflow. TYPE specifies that 
            //  A may be full, upper triangular, lower triangular, upper Hessenberg, 
            //  or banded. 

            //  Arguments 
            //  ========= 

            //  TYPE    (input) CHARACTER*1 
            //          TYPE indices the storage type of the input matrix. 
            //          = 'G':  A is a full matrix. 
            //          = 'L':  A is a lower triangular matrix. 
            //          = 'U':  A is an upper triangular matrix. 
            //          = 'H':  A is an upper Hessenberg matrix. 
            //          = 'B':  A is a symmetric band matrix with lower bandwidth KL 
            //                  and upper bandwidth KU and with the only the lower 
            //                  half stored. 
            //          = 'Q':  A is a symmetric band matrix with lower bandwidth KL 
            //                  and upper bandwidth KU and with the only the upper 
            //                  half stored. 
            //          = 'Z':  A is a band matrix with lower bandwidth KL and upper 
            //                  bandwidth KU. 

            //  KL      (input) int 
            //          The lower bandwidth of A.  Referenced only if TYPE = 'B', 
            //          'Q' or 'Z'. 

            //  KU      (input) int 
            //          The upper bandwidth of A.  Referenced only if TYPE = 'B', 
            //          'Q' or 'Z'. 

            //  CFROM   (input) DOUBLE PRECISION 
            //  CTO     (input) DOUBLE PRECISION 
            //          The matrix A is multiplied by CTO/CFROM. A(I,J) is computed 
            //          without over/underflow if the final result CTO*A(I,J)/CFROM 
            //          can be represented without over/underflow.  CFROM must be 
            //          nonzero. 

            //  M       (input) int 
            //          The number of rows of the matrix A.  M >= 0. 

            //  N       (input) int 
            //          The number of columns of the matrix A.  N >= 0. 

            //  A       (input/output) COMPLEX*16 array, dimension (LDA,N) 
            //          The matrix to be multiplied by CTO/CFROM.  See TYPE for the 
            //          storage type. 

            //  LDA     (input) int 
            //          The leading dimension of the array A.  LDA >= max(1,M). 

            //  INFO    (output) int 
            //          0  - successful exit 
            //          <0 - if INFO = -i, the i-th argument had an illegal value. 

            //  ===================================================================== 

            // System generated locals 
            int a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5;
            complex16 z__1;

            // Local variables 
            int i, j, k1, k2, k3, k4;
            double mul, cto1;
            bool done;
            double ctoc;
            int itype;
            double cfrom1;
            double cfromc;
            double bignum, smlnum;

            // Parameter adjustments 
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;

            // Function Body 
            *info = 0;

            if (lsame(type, "G"))
            {
                itype = 0;
            }
            else if (lsame(type, "L"))
            {
                itype = 1;
            }
            else if (lsame(type, "U"))
            {
                itype = 2;
            }
            else if (lsame(type, "H"))
            {
                itype = 3;
            }
            else if (lsame(type, "B"))
            {
                itype = 4;
            }
            else if (lsame(type, "Q"))
            {
                itype = 5;
            }
            else if (lsame(type, "Z"))
            {
                itype = 6;
            }
            else
            {
                itype = -1;
            }

            if (itype == -1)
            {
                *info = -1;
            }
            else if (*cfrom == 0.0 || disnan(cfrom))
            {
                *info = -4;
            }
            else if (disnan(cto))
            {
                *info = -5;
            }
            else if (*m < 0)
            {
                *info = -6;
            }
            else if (*n < 0 || itype == 4 && *n != *m || itype == 5 && *n != *m)
            {
                *info = -7;
            }
            else if (itype <= 3 && *lda < Math.Max(1, *m))
            {
                *info = -9;
            }
            else if (itype >= 4)
            {
                // Computing MAX 
                i__1 = *m - 1;
                if (*kl < 0 || *kl > Math.Max(i__1, 0))
                {
                    *info = -2;
                }
                else // if(complicated condition) 
                {
                    // Computing MAX 
                    i__1 = *n - 1;
                    if (*ku < 0 || *ku > Math.Max(i__1, 0) || (itype == 4 || itype == 5) && *kl != *ku)
                    {
                        *info = -3;
                    }
                    else if (itype == 4 && *lda < *kl + 1 || itype == 5 && *lda < *ku + 1 || itype == 6 && *lda < (*kl << 1) + *ku + 1)
                    {
                        *info = -9;
                    }
                }
            }

            if (*info != 0)
            {
                i__1 = -(*info);
                xerbla("ZLASCL", &i__1);
                return 0;
            }

            // Quick return if possible 

            if (*n == 0 || *m == 0)
            {
                return 0;
            }

            // Get machine parameters 

            smlnum = dlamch("S");
            bignum = 1.0 / smlnum;

            cfromc = *cfrom;
            ctoc = *cto;

        L10:
            cfrom1 = cfromc * smlnum;
            if (cfrom1 == cfromc)
            {
                // CFROMC is an inf.  Multiply by a correctly signed zero for 
                // finite CTOC, or a NaN if CTOC is infinite. 
                mul = ctoc / cfromc;
                done = true;
                cto1 = ctoc;
            }
            else
            {
                cto1 = ctoc / bignum;
                if (cto1 == ctoc)
                {
                    // CTOC is either 0 or an inf.  In both cases, CTOC itself 
                    // serves as the correct multiplication factor. 
                    mul = ctoc;
                    done = true;
                    cfromc = 1.0;
                }
                else if (Math.Abs(cfrom1) > Math.Abs(ctoc) && ctoc != 0.0)
                {
                    mul = smlnum;
                    done = false;
                    cfromc = cfrom1;
                }
                else if (Math.Abs(cto1) > Math.Abs(cfromc))
                {
                    mul = bignum;
                    done = false;
                    ctoc = cto1;
                }
                else
                {
                    mul = ctoc / cfromc;
                    done = true;
                }
            }

            if (itype == 0)
            {
                // Full matrix 
                i__1 = *n;
                for (j = 1; j <= i__1; ++j)
                {
                    i__2 = *m;
                    for (i = 1; i <= i__2; ++i)
                    {
                        i__3 = i + j * a_dim1;
                        i__4 = i + j * a_dim1;

                        z__1.r = mul * a[i__4].r;
                        z__1.i = mul * a[i__4].i;

                        a[i__3].r = z__1.r;
                        a[i__3].i = z__1.i;
                    }
                }
            }
            else if (itype == 1)
            {
                // Lower triangular matrix 
                i__1 = *n;
                for (j = 1; j <= i__1; ++j)
                {
                    i__2 = *m;
                    for (i = j; i <= i__2; ++i)
                    {
                        i__3 = i + j * a_dim1;
                        i__4 = i + j * a_dim1;

                        z__1.r = mul * a[i__4].r;
                        z__1.i = mul * a[i__4].i;

                        a[i__3].r = z__1.r;
                        a[i__3].i = z__1.i;
                    }
                }

            }
            else if (itype == 2)
            {
                // Upper triangular matrix 
                i__1 = *n;
                for (j = 1; j <= i__1; ++j)
                {
                    i__2 = Math.Min(j, *m);
                    for (i = 1; i <= i__2; ++i)
                    {
                        i__3 = i + j * a_dim1;
                        i__4 = i + j * a_dim1;

                        z__1.r = mul * a[i__4].r;
                        z__1.i = mul * a[i__4].i;

                        a[i__3].r = z__1.r;
                        a[i__3].i = z__1.i;
                    }
                }
            }
            else if (itype == 3)
            {
                // Upper Hessenberg matrix 
                i__1 = *n;
                for (j = 1; j <= i__1; ++j)
                {
                    // Computing MIN 
                    i__3 = j + 1;
                    i__2 = Math.Min(i__3, *m);
                    for (i = 1; i <= i__2; ++i)
                    {
                        i__3 = i + j * a_dim1;
                        i__4 = i + j * a_dim1;

                        z__1.r = mul * a[i__4].r;
                        z__1.i = mul * a[i__4].i;

                        a[i__3].r = z__1.r;
                        a[i__3].i = z__1.i;
                    }
                }
            }
            else if (itype == 4)
            {
                // Lower half of a symmetric band matrix 
                k3 = *kl + 1;
                k4 = *n + 1;
                i__1 = *n;
                for (j = 1; j <= i__1; ++j)
                {
                    // Computing MIN 
                    i__3 = k3;
                    i__4 = k4 - j;
                    i__2 = Math.Min(i__3, i__4);
                    for (i = 1; i <= i__2; ++i)
                    {
                        i__3 = i + j * a_dim1;
                        i__4 = i + j * a_dim1;

                        z__1.r = mul * a[i__4].r;
                        z__1.i = mul * a[i__4].i;

                        a[i__3].r = z__1.r;
                        a[i__3].i = z__1.i;
                    }
                }
            }
            else if (itype == 5)
            {
                // Upper half of a symmetric band matrix 
                k1 = *ku + 2;
                k3 = *ku + 1;
                i__1 = *n;
                for (j = 1; j <= i__1; ++j)
                {
                    // Computing MAX 
                    i__2 = k1 - j;
                    i__3 = k3;
                    for (i = Math.Max(i__2, 1); i <= i__3; ++i)
                    {
                        i__2 = i + j * a_dim1;
                        i__4 = i + j * a_dim1;

                        z__1.r = mul * a[i__4].r;
                        z__1.i = mul * a[i__4].i;

                        a[i__2].r = z__1.r;
                        a[i__2].i = z__1.i;
                    }
                }

            }
            else if (itype == 6)
            {
                // Band matrix 
                k1 = *kl + *ku + 2;
                k2 = *kl + 1;
                k3 = (*kl << 1) + *ku + 1;
                k4 = *kl + *ku + 1 + *m;
                i__1 = *n;
                for (j = 1; j <= i__1; ++j)
                {
                    // Computing MAX 
                    i__3 = k1 - j;
                    // Computing MIN 
                    i__4 = k3;
                    i__5 = k4 - j;
                    i__2 = Math.Min(i__4, i__5);
                    for (i = Math.Max(i__3, k2); i <= i__2; ++i)
                    {
                        i__3 = i + j * a_dim1;
                        i__4 = i + j * a_dim1;

                        z__1.r = mul * a[i__4].r;
                        z__1.i = mul * a[i__4].i;

                        a[i__3].r = z__1.r;
                        a[i__3].i = z__1.i;
                    }
                }
            }

            if (!done)
            {
                goto L10;
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zlaset(string uplo, int* m, int* n, complex16* alpha, complex16* beta, complex16* a, int* lda)
        {
            //  -- LAPACK auxiliary routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. 
            //     November 2006 

            //  Purpose 
            //  ======= 

            //  ZLASET initializes a 2-D array A to BETA on the diagonal and 
            //  ALPHA on the offdiagonals. 

            //  Arguments 
            //  ========= 

            //  UPLO    (input) CHARACTER*1 
            //          Specifies the part of the matrix A to be set. 
            //          = 'U':      Upper triangular part is set. The lower triangle 
            //                      is unchanged. 
            //          = 'L':      Lower triangular part is set. The upper triangle 
            //                      is unchanged. 
            //          Otherwise:  All of the matrix A is set. 

            //  M       (input) INTEGER 
            //          On entry, M specifies the number of rows of A. 

            //  N       (input) INTEGER 
            //          On entry, N specifies the number of columns of A. 

            //  ALPHA   (input) COMPLEX*16 
            //          All the offdiagonal array elements are set to ALPHA. 

            //  BETA    (input) COMPLEX*16 
            //          All the diagonal array elements are set to BETA. 

            //  A       (input/output) COMPLEX*16 array, dimension (LDA,N) 
            //          On entry, the m by n matrix A. 
            //          On exit, A(i,j) = ALPHA, 1 <= i <= m, 1 <= j <= n, i.ne.j; 
            //                   A(i,i) = BETA , 1 <= i <= min(m,n) 

            //  LDA     (input) INTEGER 
            //          The leading dimension of the array A.  LDA >= max(1,M). 

            //  ===================================================================== 

            // System generated locals 
            int a_dim1, a_offset, i__1, i__2, i__3;

            // Local variables 
            int i, j;

            // Parameter adjustments 
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;

            // Function Body 
            if (lsame(uplo, "U"))
            {
                // Set the diagonal to BETA and the strictly upper triangular 
                // part of the array to ALPHA. 

                i__1 = *n;
                for (j = 2; j <= i__1; ++j)
                {
                    // Computing MIN 
                    i__3 = j - 1;
                    i__2 = Math.Min(i__3, *m);
                    for (i = 1; i <= i__2; ++i)
                    {
                        i__3 = i + j * a_dim1;
                        a[i__3].r = alpha.r;
                        a[i__3].i = alpha.i;
                    }
                }

                i__1 = Math.Min(*n, *m);
                for (i = 1; i <= i__1; ++i)
                {
                    i__2 = i + i * a_dim1;
                    a[i__2].r = beta.r;
                    a[i__2].i = beta.i;
                }
            }
            else if (lsame(uplo, "L"))
            {
                // Set the diagonal to BETA and the strictly lower triangular 
                // part of the array to ALPHA. 

                i__1 = Math.Min(*m, *n);
                for (j = 1; j <= i__1; ++j)
                {
                    i__2 = *m;
                    for (i = j + 1; i <= i__2; ++i)
                    {
                        i__3 = i + j * a_dim1;
                        a[i__3].r = alpha.r;
                        a[i__3].i = alpha.i;
                    }
                }
                i__1 = Math.Min(*n, *m);
                for (i = 1; i <= i__1; ++i)
                {
                    i__2 = i + i * a_dim1;
                    a[i__2].r = beta.r;
                    a[i__2].i = beta.i;
                }

            }
            else
            {
                // Set the array to BETA on the diagonal and ALPHA on the 
                // offdiagonal. 

                i__1 = *n;
                for (j = 1; j <= i__1; ++j)
                {
                    i__2 = *m;
                    for (i = 1; i <= i__2; ++i)
                    {
                        i__3 = i + j * a_dim1;
                        a[i__3].r = alpha.r;
                        a[i__3].i = alpha.i;
                    }
                }
                i__1 = Math.Min(*m, *n);
                for (i = 1; i <= i__1; ++i)
                {
                    i__2 = i + i * a_dim1;
                    a[i__2].r = beta.r;
                    a[i__2].i = beta.i;
                }
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zlassq(int* n, complex16* x, int* incx, double* scale, double* sumsq)
        {
            //  -- LAPACK auxiliary routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. 
            //     November 2006 

            //  Purpose 
            //  ======= 

            //  ZLASSQ returns the values scl and ssq such that 

            //     ( scl**2 )*ssq = x( 1 )**2 +...+ x( n )**2 + ( scale**2 )*sumsq, 

            //  where x( i ) = abs( X( 1 + ( i - 1 )*INCX ) ). The value of sumsq is 
            //  assumed to be at least unity and the value of ssq will then satisfy 

            //     1.0 .le. ssq .le. ( sumsq + 2*n ). 

            //  scale is assumed to be non-negative and scl returns the value 

            //     scl = max( scale, abs( real( x( i ) ) ), abs( aimag( x( i ) ) ) ), 
            //            i 

            //  scale and sumsq must be supplied in SCALE and SUMSQ respectively. 
            //  SCALE and SUMSQ are overwritten by scl and ssq respectively. 

            //  The routine makes only one pass through the vector X. 

            //  Arguments 
            //  ========= 

            //  N       (input) int 
            //          The number of elements to be used from the vector X. 

            //  X       (input) COMPLEX*16 array, dimension (N) 
            //          The vector x as described above. 
            //             x( i )  = X( 1 + ( i - 1 )*INCX ), 1 <= i <= n. 

            //  INCX    (input) int 
            //          The increment between successive values of the vector X. 
            //          INCX > 0. 

            //  SCALE   (input/output) DOUBLE PRECISION 
            //          On entry, the value  scale  in the equation above. 
            //          On exit, SCALE is overwritten with the value  scl . 

            //  SUMSQ   (input/output) DOUBLE PRECISION 
            //          On entry, the value  sumsq  in the equation above. 
            //          On exit, SUMSQ is overwritten with the value  ssq . 

            // ===================================================================== 

            // System generated locals 
            int i__1, i__2, i__3;
            double d__1;

            // Local variables 
            int ix;
            double temp1;

            // Parameter adjustments 
            --x;

            // Function Body 
            if (*n > 0)
            {
                i__1 = (*n - 1) * *incx + 1;
                i__2 = *incx;
                for (ix = 1; i__2 < 0 ? ix >= i__1 : ix <= i__1; ix += i__2)
                {
                    i__3 = ix;
                    if (x[i__3].r != 0.0)
                    {
                        i__3 = ix;
                        temp1 = Math.Abs(x[i__3].r);
                        if (*scale < temp1)
                        {
                            // Computing 2nd power 
                            d__1 = *scale / temp1;
                            *sumsq = *sumsq * (d__1 * d__1) + 1;
                            *scale = temp1;
                        }
                        else
                        {
                            // Computing 2nd power 
                            d__1 = temp1 / *scale;
                            *sumsq += d__1 * d__1;
                        }
                    }
                    if (d_imag(&x[ix]) != 0.0)
                    {
                        temp1 = Math.Abs(d_imag(&x[ix]));
                        if (*scale < temp1)
                        {
                            // Computing 2nd power 
                            d__1 = *scale / temp1;
                            *sumsq = *sumsq * (d__1 * d__1) + 1;
                            *scale = temp1;
                        }
                        else
                        {
                            // Computing 2nd power 
                            d__1 = temp1 / *scale;
                            *sumsq += d__1 * d__1;
                        }
                    }
                }
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zlatrs(string uplo, string trans, string diag, string normin,
            int* n, complex16* a, int* lda, complex16* x, double* scale, double* cnorm, int* info)
        {
            //  -- LAPACK auxiliary routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. 
            //     November 2006 

            //  Purpose 
            //  ======= 

            //  ZLATRS solves one of the triangular systems 

            //     A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b, 

            //  with scaling to prevent overflow.  Here A is an upper or lower 
            //  triangular matrix, A**T denotes the transpose of A, A**H denotes the 
            //  conjugate transpose of A, x and b are n-element vectors, and s is a 
            //  scaling factor, usually less than or equal to 1, chosen so that the 
            //  components of x will be less than the overflow threshold.  If the 
            //  unscaled problem will not cause overflow, the Level 2 BLAS routine 
            //  ZTRSV is called. If the matrix A is singular (A(j,j) = 0 for some j), 
            //  then s is set to 0 and a non-trivial solution to A*x = 0 is returned. 

            //  Arguments 
            //  ========= 

            //  UPLO    (input) CHARACTER*1 
            //          Specifies whether the matrix A is upper or lower triangular. 
            //          = 'U':  Upper triangular 
            //          = 'L':  Lower triangular 

            //  TRANS   (input) CHARACTER*1 
            //          Specifies the operation applied to A. 
            //          = 'N':  Solve A * x = s*b     (No transpose) 
            //          = 'T':  Solve A**T * x = s*b  (Transpose) 
            //          = 'C':  Solve A**H * x = s*b  (Conjugate transpose) 

            //  DIAG    (input) CHARACTER*1 
            //          Specifies whether or not the matrix A is unit triangular. 
            //          = 'N':  Non-unit triangular 
            //          = 'U':  Unit triangular 

            //  NORMIN  (input) CHARACTER*1 
            //          Specifies whether CNORM has been set or not. 
            //          = 'Y':  CNORM contains the column norms on entry 
            //          = 'N':  CNORM is not set on entry.  On exit, the norms will 
            //                  be computed and stored in CNORM. 

            //  N       (input) int 
            //          The order of the matrix A.  N >= 0. 

            //  A       (input) COMPLEX*16 array, dimension (LDA,N) 
            //          The triangular matrix A.  If UPLO = 'U', the leading n by n 
            //          upper triangular part of the array A contains the upper 
            //          triangular matrix, and the strictly lower triangular part of 
            //          A is not referenced.  If UPLO = 'L', the leading n by n lower 
            //          triangular part of the array A contains the lower triangular 
            //          matrix, and the strictly upper triangular part of A is not 
            //          referenced.  If DIAG = 'U', the diagonal elements of A are 
            //          also not referenced and are assumed to be 1. 

            //  LDA     (input) int 
            //          The leading dimension of the array A.  LDA >= max (1,N). 

            //  X       (input/output) COMPLEX*16 array, dimension (N) 
            //          On entry, the right hand side b of the triangular system. 
            //          On exit, X is overwritten by the solution vector x. 

            //  SCALE   (output) DOUBLE PRECISION 
            //          The scaling factor s for the triangular system 
            //             A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b. 
            //          If SCALE = 0, the matrix A is singular or badly scaled, and 
            //          the vector x is an exact or approximate solution to A*x = 0. 

            //  CNORM   (input or output) DOUBLE PRECISION array, dimension (N) 

            //          If NORMIN = 'Y', CNORM is an input argument and CNORM(j) 
            //          contains the norm of the off-diagonal part of the j-th column 
            //          of A.  If TRANS = 'N', CNORM(j) must be greater than or equal 
            //          to the infinity-norm, and if TRANS = 'T' or 'C', CNORM(j) 
            //          must be greater than or equal to the 1-norm. 

            //          If NORMIN = 'N', CNORM is an output argument and CNORM(j) 
            //          returns the 1-norm of the offdiagonal part of the j-th column 
            //          of A. 

            //  INFO    (output) int 
            //          = 0:  successful exit 
            //          < 0:  if INFO = -k, the k-th argument had an illegal value 

            //  Further Details 
            //  ======= ======= 

            //  A rough bound on x is computed; if that is less than overflow, ZTRSV 
            //  is called, otherwise, specific code is used which checks for possible 
            //  overflow or divide-by-zero at every operation. 

            //  A columnwise scheme is used for solving A*x = b.  The basic algorithm 
            //  if A is lower triangular is 

            //       x[1:n] := b[1:n] 
            //       for j = 1, ..., n 
            //            x(j) := x(j) / A(j,j) 
            //            x[j+1:n] := x[j+1:n] - x(j) * A[j+1:n,j] 
            //       end 

            //  Define bounds on the components of x after j iterations of the loop: 
            //     M(j) = bound on x[1:j] 
            //     G(j) = bound on x[j+1:n] 
            //  Initially, let M(0) = 0 and G(0) = max{x(i), i=1,...,n}. 

            //  Then for iteration j+1 we have 
            //     M(j+1) <= G(j) / | A(j+1,j+1) | 
            //     G(j+1) <= G(j) + M(j+1) * | A[j+2:n,j+1] | 
            //            <= G(j) ( 1 + CNORM(j+1) / | A(j+1,j+1) | ) 

            //  where CNORM(j+1) is greater than or equal to the infinity-norm of 
            //  column j+1 of A, not counting the diagonal.  Hence 

            //     G(j) <= G(0) product ( 1 + CNORM(i) / | A(i,i) | ) 
            //                  1<=i<=j 
            //  and 

            //     |x(j)| <= ( G(0) / |A(j,j)| ) product ( 1 + CNORM(i) / |A(i,i)| ) 
            //                                   1<=i< j 

            //  Since |x(j)| <= M(j), we use the Level 2 BLAS routine ZTRSV if the 
            //  reciprocal of the largest M(j), j=1,..,n, is larger than 
            //  max(underflow, 1/overflow). 

            //  The bound on x(j) is also used to determine when a step in the 
            //  columnwise method can be performed without fear of overflow.  If 
            //  the computed bound is greater than a large constant, x is scaled to 
            //  prevent overflow, but if the bound overflows, x is set to 0, x(j) to 
            //  1, and scale to 0, and a non-trivial solution to A*x = 0 is found. 

            //  Similarly, a row-wise scheme is used to solve A**T *x = b  or 
            //  A**H *x = b.  The basic algorithm for A upper triangular is 

            //       for j = 1, ..., n 
            //            x(j) := ( b(j) - A[1:j-1,j]' * x[1:j-1] ) / A(j,j) 
            //       end 

            //  We simultaneously compute two bounds 
            //       G(j) = bound on ( b(i) - A[1:i-1,i]' * x[1:i-1] ), 1<=i<=j 
            //       M(j) = bound on x(i), 1<=i<=j 

            //  The initial values are G(0) = 0, M(0) = max{b(i), i=1,..,n}, and we 
            //  add the constraint G(j) >= G(j-1) and M(j) >= M(j-1) for j >= 1. 
            //  Then the bound on x(j) is 

            //       M(j) <= M(j-1) * ( 1 + CNORM(j) ) / | A(j,j) | 

            //            <= M(0) * product ( ( 1 + CNORM(i) ) / |A(i,i)| ) 
            //                      1<=i<=j 

            //  and we can safely call ZTRSV if 1/M(n) and 1/G(n) are both greater 
            //  than max(underflow, 1/overflow). 

            //  ===================================================================== 

            // System generated locals 
            int a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5;
            double d__1, d__2, d__3, d__4;
            complex16 z__1, z__2, z__3, z__4;

            // Table of constant values
            int c__1 = 1;
            double c_b36 = 0.5;

            // Local variables 
            int i, j;
            double xj, rec, tjj;
            int jinc;
            double xbnd;
            int imax;
            double tmax;
            complex16 tjjs;
            double xmax, grow;
            double tscal;
            complex16 uscal;
            int jlast;
            complex16 csumj;
            bool upper;
            double bignum;
            bool notran;
            int jfirst;
            double smlnum;
            bool nounit;

            // Parameter adjustments 
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;
            --x;
            --cnorm;

            // Function Body 
            *info = 0;
            upper = lsame(uplo, "U");
            notran = lsame(trans, "N");
            nounit = lsame(diag, "N");

            // Test the input parameters. 

            if (!upper && !lsame(uplo, "L"))
            {
                *info = -1;
            }
            else if (!notran && !lsame(trans, "T") && !lsame(trans, "C"))
            {
                *info = -2;
            }
            else if (!nounit && !lsame(diag, "U"))
            {
                *info = -3;
            }
            else if (!lsame(normin, "Y") && !lsame(normin, "N"))
            {
                *info = -4;
            }
            else if (*n < 0)
            {
                *info = -5;
            }
            else if (*lda < Math.Max(1, *n))
            {
                *info = -7;
            }

            if (*info != 0)
            {
                i__1 = -(*info);
                xerbla("ZLATRS", &i__1);
                return 0;
            }

            // Quick return if possible 

            if (*n == 0)
            {
                return 0;
            }

            // Determine machine dependent parameters to control overflow. 

            smlnum = dlamch("Safe minimum");
            bignum = 1.0 / smlnum;
            dlabad(&smlnum, &bignum);
            smlnum /= dlamch("Precision");
            bignum = 1.0 / smlnum;
            *scale = 1.0;

            if (lsame(normin, "N"))
            {
                // Compute the 1-norm of each column, not including the diagonal. 

                if (upper)
                {
                    // A is upper triangular. 

                    i__1 = *n;
                    for (j = 1; j <= i__1; ++j)
                    {
                        i__2 = j - 1;
                        cnorm[j] = dzasum(&i__2, &a[j * a_dim1 + 1], &c__1);
                    }
                }
                else
                {
                    // A is lower triangular. 

                    i__1 = *n - 1;
                    for (j = 1; j <= i__1; ++j)
                    {
                        i__2 = *n - j;
                        cnorm[j] = dzasum(&i__2, &a[j + 1 + j * a_dim1], &c__1);
                    }
                    cnorm[*n] = 0.0;
                }
            }

            // Scale the column norms by TSCAL if the maximum element in CNORM is 
            // greater than BIGNUM/2. 

            imax = idamax(n, &cnorm[1], &c__1);
            tmax = cnorm[imax];
            if (tmax <= bignum * 0.5)
            {
                tscal = 1.0;
            }
            else
            {
                tscal = 0.5 / (smlnum * tmax);
                dscal(n, &tscal, &cnorm[1], &c__1);
            }

            // Compute a bound on the computed solution vector to see if the 
            // Level 2 BLAS routine ZTRSV can be used. 

            xmax = 0.0;
            i__1 = *n;
            for (j = 1; j <= i__1; ++j)
            {
                // Computing MAX 
                i__2 = j;
                d__3 = xmax;
                d__4 = Math.Abs(x[i__2].r / 2.0) + Math.Abs(d_imag(&x[j]) / 2.0);
                xmax = Math.Max(d__3, d__4);
            }
            xbnd = xmax;

            if (notran)
            {
                // Compute the growth in A * x = b. 

                if (upper)
                {
                    jfirst = *n;
                    jlast = 1;
                    jinc = -1;
                }
                else
                {
                    jfirst = 1;
                    jlast = *n;
                    jinc = 1;
                }

                if (tscal != 1.0)
                {
                    grow = 0.0;
                    goto L60;
                }

                if (nounit)
                {
                    // A is non-unit triangular. 

                    // Compute GROW = 1/G(j) and XBND = 1/M(j). 
                    // Initially, G(0) = max{x(i), i=1,...,n}. 

                    grow = 0.5 / Math.Max(xbnd, smlnum);
                    xbnd = grow;
                    i__1 = jlast;
                    i__2 = jinc;
                    for (j = jfirst; i__2 < 0 ? j >= i__1 : j <= i__1; j += i__2)
                    {
                        // Exit the loop if the growth factor is too small. 

                        if (grow <= smlnum)
                        {
                            goto L60;
                        }

                        i__3 = j + j * a_dim1;
                        tjjs.r = a[i__3].r;
                        tjjs.i = a[i__3].i;
                        tjj = Math.Abs(tjjs.r) + Math.Abs(d_imag(&tjjs));

                        if (tjj >= smlnum)
                        {
                            // M(j) = G(j-1) / abs(A(j,j)) 

                            // Computing MIN 
                            d__1 = xbnd;
                            d__2 = Math.Min(1.0, tjj) * grow;
                            xbnd = Math.Min(d__1, d__2);
                        }
                        else
                        {
                            // M(j) could overflow, set XBND to 0. 

                            xbnd = 0.0;
                        }

                        if (tjj + cnorm[j] >= smlnum)
                        {
                            // G(j) = G(j-1)*( 1 + CNORM(j) / abs(A(j,j)) ) 

                            grow *= tjj / (tjj + cnorm[j]);
                        }
                        else
                        {
                            // G(j) could overflow, set GROW to 0. 

                            grow = 0.0;
                        }
                    }
                    grow = xbnd;
                }
                else
                {
                    // A is unit triangular. 

                    // Compute GROW = 1/G(j), where G(0) = max{x(i), i=1,...,n}. 

                    // Computing MIN 
                    d__1 = 1.0;
                    d__2 = 0.5 / Math.Max(xbnd, smlnum);
                    grow = Math.Min(d__1, d__2);
                    i__2 = jlast;
                    i__1 = jinc;
                    for (j = jfirst; i__1 < 0 ? j >= i__2 : j <= i__2; j += i__1)
                    {
                        // Exit the loop if the growth factor is too small. 

                        if (grow <= smlnum)
                        {
                            goto L60;
                        }

                        // G(j) = G(j-1)*( 1 + CNORM(j) ) 

                        grow *= 1.0 / (cnorm[j] + 1.0);
                    }
                }

            L60:
                ;
            }
            else
            {
                // Compute the growth in A**T * x = b  or  A**H * x = b. 

                if (upper)
                {
                    jfirst = 1;
                    jlast = *n;
                    jinc = 1;
                }
                else
                {
                    jfirst = *n;
                    jlast = 1;
                    jinc = -1;
                }

                if (tscal != 1.0)
                {
                    grow = 0.0;
                    goto L90;
                }

                if (nounit)
                {
                    // A is non-unit triangular. 

                    // Compute GROW = 1/G(j) and XBND = 1/M(j). 
                    // Initially, M(0) = max{x(i), i=1,...,n}. 

                    grow = 0.5 / Math.Max(xbnd, smlnum);
                    xbnd = grow;
                    i__1 = jlast;
                    i__2 = jinc;
                    for (j = jfirst; i__2 < 0 ? j >= i__1 : j <= i__1; j += i__2)
                    {
                        // Exit the loop if the growth factor is too small. 

                        if (grow <= smlnum)
                        {
                            goto L90;
                        }

                        // G(j) = max( G(j-1), M(j-1)*( 1 + CNORM(j) ) ) 

                        xj = cnorm[j] + 1.0;
                        // Computing MIN 
                        d__1 = grow;
                        d__2 = xbnd / xj;

                        grow = Math.Min(d__1, d__2);

                        i__3 = j + j * a_dim1;

                        tjjs.r = a[i__3].r;
                        tjjs.i = a[i__3].i;

                        tjj = Math.Abs(tjjs.r) + Math.Abs(d_imag(&tjjs));

                        if (tjj >= smlnum)
                        {
                            // M(j) = M(j-1)*( 1 + CNORM(j) ) / abs(A(j,j)) 

                            if (xj > tjj)
                            {
                                xbnd *= tjj / xj;
                            }
                        }
                        else
                        {
                            // M(j) could overflow, set XBND to 0. 

                            xbnd = 0.0;
                        }
                    }
                    grow = Math.Min(grow, xbnd);
                }
                else
                {
                    // A is unit triangular. 

                    // Compute GROW = 1/G(j), where G(0) = max{x(i), i=1,...,n}. 

                    // Computing MIN 
                    d__1 = 1.0;
                    d__2 = 0.5 / Math.Max(xbnd, smlnum);

                    grow = Math.Min(d__1, d__2);
                    i__2 = jlast;
                    i__1 = jinc;
                    for (j = jfirst; i__1 < 0 ? j >= i__2 : j <= i__2; j += i__1)
                    {
                        // Exit the loop if the growth factor is too small. 

                        if (grow <= smlnum)
                        {
                            goto L90;
                        }

                        // G(j) = ( 1 + CNORM(j) )*G(j-1) 

                        xj = cnorm[j] + 1.0;
                        grow /= xj;
                    }
                }

            L90:
                ;
            }

            if (grow * tscal > smlnum)
            {
                // Use the Level 2 BLAS solve if the reciprocal of the bound on 
                // elements of X is not too small. 

                ztrsv(uplo, trans, diag, n, &a[a_offset], lda, &x[1], &c__1);
            }
            else
            {
                // Use a Level 1 BLAS solve, scaling intermediate results. 

                if (xmax > bignum * 0.5)
                {
                    // Scale X so that its components are less than or equal to 
                    // BIGNUM in absolute value. 

                    *scale = bignum * 0.5 / xmax;
                    zdscal(n, scale, &x[1], &c__1);
                    xmax = bignum;
                }
                else
                {
                    xmax *= 2.0;
                }

                if (notran)
                {
                    // Solve A * x = b 

                    i__1 = jlast;
                    i__2 = jinc;
                    for (j = jfirst; i__2 < 0 ? j >= i__1 : j <= i__1; j += i__2)
                    {
                        // Compute x(j) = b(j) / A(j,j), scaling x if necessary. 

                        i__3 = j;
                        xj = Math.Abs(x[i__3].r) + Math.Abs(d_imag(&x[j]));
                        if (nounit)
                        {
                            i__3 = j + j * a_dim1;

                            z__1.r = tscal * a[i__3].r;
                            z__1.i = tscal * a[i__3].i;

                            tjjs.r = z__1.r;
                            tjjs.i = z__1.i;
                        }
                        else
                        {
                            tjjs.r = tscal;
                            tjjs.i = 0.0;

                            if (tscal == 1.0)
                            {
                                goto L110;
                            }
                        }

                        tjj = Math.Abs(tjjs.r) + Math.Abs(d_imag(&tjjs));

                        if (tjj > smlnum)
                        {
                            // abs(A(j,j)) > SMLNUM: 

                            if (tjj < 1.0)
                            {
                                if (xj > tjj * bignum)
                                {
                                    // Scale x by 1/b(j). 

                                    rec = 1.0 / xj;
                                    zdscal(n, &rec, &x[1], &c__1);
                                    *scale *= rec;
                                    xmax *= rec;
                                }
                            }
                            i__3 = j;
                            zladiv(&z__1, &x[j], &tjjs);

                            x[i__3].r = z__1.r;
                            x[i__3].i = z__1.i;

                            i__3 = j;
                            xj = Math.Abs(x[i__3].r) + Math.Abs(d_imag(&x[j]));
                        }
                        else if (tjj > 0.0)
                        {
                            // 0 < abs(A(j,j)) <= SMLNUM: 

                            if (xj > tjj * bignum)
                            {
                                // Scale x by (1/abs(x(j)))*abs(A(j,j))*BIGNUM 
                                // to avoid overflow when dividing by A(j,j). 

                                rec = tjj * bignum / xj;
                                if (cnorm[j] > 1.0)
                                {
                                    // Scale by 1/CNORM(j) to avoid overflow when 
                                    // multiplying x(j) times column j. 

                                    rec /= cnorm[j];
                                }
                                zdscal(n, &rec, &x[1], &c__1);
                                *scale *= rec;
                                xmax *= rec;
                            }
                            i__3 = j;
                            zladiv(&z__1, &x[j], &tjjs);

                            x[i__3].r = z__1.r;
                            x[i__3].i = z__1.i;

                            i__3 = j;
                            xj = Math.Abs(x[i__3].r) + Math.Abs(d_imag(&x[j]));
                        }
                        else
                        {
                            // A(j,j) = 0:  Set x(1:n) = 0, x(j) = 1, and 
                            // scale = 0, and compute a solution to A*x = 0. 

                            i__3 = *n;
                            for (i = 1; i <= i__3; ++i)
                            {
                                i__4 = i;
                                x[i__4].r = 0.0;
                                x[i__4].i = 0.0;
                            }
                            i__3 = j;

                            x[i__3].r = 1.0;
                            x[i__3].i = 0.0;

                            xj = 1.0;
                            *scale = 0.0;
                            xmax = 0.0;
                        }

                    L110:

                        // Scale x if necessary to avoid overflow when adding a 
                        // multiple of column j of A. 

                        if (xj > 1.0)
                        {
                            rec = 1.0 / xj;
                            if (cnorm[j] > (bignum - xmax) * rec)
                            {
                                // Scale x by 1/(2*abs(x(j))). 

                                rec *= 0.5;
                                zdscal(n, &rec, &x[1], &c__1);
                                *scale *= rec;
                            }
                        }
                        else if (xj * cnorm[j] > bignum - xmax)
                        {
                            // Scale x by 1/2. 

                            zdscal(n, &c_b36, &x[1], &c__1);
                            *scale *= 0.5;
                        }

                        if (upper)
                        {
                            if (j > 1)
                            {
                                // Compute the update 
                                // x(1:j-1) := x(1:j-1) - x(j) * A(1:j-1,j) 

                                i__3 = j - 1;
                                i__4 = j;

                                z__2.r = -x[i__4].r;
                                z__2.i = -x[i__4].i;

                                z__1.r = tscal * z__2.r;
                                z__1.i = tscal * z__2.i;

                                zaxpy(&i__3, &z__1, &a[j * a_dim1 + 1], &c__1, &x[1],
                                     &c__1);
                                i__3 = j - 1;
                                i = izamax(&i__3, &x[1], &c__1);
                                i__3 = i;

                                xmax = Math.Abs(x[i__3].r) + Math.Abs(d_imag(&x[i]));
                            }
                        }
                        else
                        {
                            if (j < *n)
                            {
                                // Compute the update 
                                // x(j+1:n) := x(j+1:n) - x(j) * A(j+1:n,j) 

                                i__3 = *n - j;
                                i__4 = j;

                                z__2.r = -x[i__4].r;
                                z__2.i = -x[i__4].i;

                                z__1.r = tscal * z__2.r;
                                z__1.i = tscal * z__2.i;

                                zaxpy(&i__3, &z__1, &a[j + 1 + j * a_dim1], &c__1, &x[j + 1], &c__1);
                                i__3 = *n - j;
                                i = j + izamax(&i__3, &x[j + 1], &c__1);
                                i__3 = i;
                                xmax = Math.Abs(x[i__3].r) + Math.Abs(d_imag(&x[i]));
                            }
                        }
                    }

                }
                else if (lsame(trans, "T"))
                {
                    // Solve A**T * x = b 

                    i__2 = jlast;
                    i__1 = jinc;
                    for (j = jfirst; i__1 < 0 ? j >= i__2 : j <= i__2; j += i__1)
                    {
                        // Compute x(j) = b(j) - sum A(k,j)*x(k). 
                        //                       k<>j 

                        i__3 = j;
                        xj = Math.Abs(x[i__3].r) + Math.Abs(d_imag(&x[j]));
                        uscal.r = tscal;
                        uscal.i = 0.0;
                        rec = 1.0 / Math.Max(xmax, 1.0);
                        if (cnorm[j] > (bignum - xj) * rec)
                        {
                            // If x(j) could overflow, scale x by 1/(2*XMAX). 

                            rec *= 0.5;
                            if (nounit)
                            {
                                i__3 = j + j * a_dim1;

                                z__1.r = tscal * a[i__3].r;
                                z__1.i = tscal * a[i__3].i;

                                tjjs.r = z__1.r;
                                tjjs.i = z__1.i;
                            }
                            else
                            {
                                tjjs.r = tscal;
                                tjjs.i = 0.0;
                            }
                            tjj = Math.Abs(tjjs.r) + Math.Abs(d_imag(&tjjs));
                            if (tjj > 1.0)
                            {
                                // Divide by A(j,j) when scaling x if A(j,j) > 1. 

                                // Computing MIN 
                                d__1 = 1.0;
                                d__2 = rec * tjj;

                                rec = Math.Min(d__1, d__2);
                                zladiv(&z__1, &uscal, &tjjs);

                                uscal.r = z__1.r;
                                uscal.i = z__1.i;
                            }
                            if (rec < 1.0)
                            {
                                zdscal(n, &rec, &x[1], &c__1);
                                *scale *= rec;
                                xmax *= rec;
                            }
                        }

                        csumj.r = 0.0;
                        csumj.i = 0.0;
                        if (uscal.r == 1.0 && uscal.i == 0.0)
                        {
                            // If the scaling needed for A in the dot product is 1, 
                            // call ZDOTU to perform the dot product. 

                            if (upper)
                            {
                                i__3 = j - 1;
                                zdotu(&z__1, &i__3, &a[j * a_dim1 + 1], &c__1, &x[1], &c__1);

                                csumj.r = z__1.r;
                                csumj.i = z__1.i;
                            }
                            else if (j < *n)
                            {
                                i__3 = *n - j;
                                zdotu(&z__1, &i__3, &a[j + 1 + j * a_dim1], &c__1, &
                                    x[j + 1], &c__1);
                                csumj.r = z__1.r;
                                csumj.i = z__1.i;
                            }
                        }
                        else
                        {
                            // Otherwise, use in-line code for the dot product. 

                            if (upper)
                            {
                                i__3 = j - 1;
                                for (i = 1; i <= i__3; ++i)
                                {
                                    i__4 = i + j * a_dim1;
                                    z__3.r = a[i__4].r * uscal.r - a[i__4].i * uscal.i;
                                    z__3.i = a[i__4].r * uscal.i + a[i__4].i * uscal.r;

                                    i__5 = i;
                                    z__2.r = z__3.r * x[i__5].r - z__3.i * x[i__5].i;
                                    z__2.i = z__3.r * x[i__5].i + z__3.i * x[i__5].r;

                                    z__1.r = csumj.r + z__2.r;
                                    z__1.i = csumj.i + z__2.i;

                                    csumj.r = z__1.r;
                                    csumj.i = z__1.i;
                                }
                            }
                            else if (j < *n)
                            {
                                i__3 = *n;
                                for (i = j + 1; i <= i__3; ++i)
                                {
                                    i__4 = i + j * a_dim1;

                                    z__3.r = a[i__4].r * uscal.r - a[i__4].i * uscal.i;
                                    z__3.i = a[i__4].r * uscal.i + a[i__4].i * uscal.r;

                                    i__5 = i;
                                    z__2.r = z__3.r * x[i__5].r - z__3.i * x[i__5].i;
                                    z__2.i = z__3.r * x[i__5].i + z__3.i * x[i__5].r;

                                    z__1.r = csumj.r + z__2.r;
                                    z__1.i = csumj.i + z__2.i;

                                    csumj.r = z__1.r;
                                    csumj.i = z__1.i;
                                }
                            }
                        }

                        z__1.r = tscal;
                        z__1.i = 0.0;

                        if (uscal.r == z__1.r && uscal.i == z__1.i)
                        {
                            // Compute x(j) := ( x(j) - CSUMJ ) / A(j,j) if 1/A(j,j) 
                            // was not used to scale the dotproduct. 

                            i__3 = j;
                            i__4 = j;
                            z__1.r = x[i__4].r - csumj.r;
                            z__1.i = x[i__4].i - csumj.i;

                            x[i__3].r = z__1.r;
                            x[i__3].i = z__1.i;
                            i__3 = j;

                            xj = Math.Abs(x[i__3].r) + Math.Abs(d_imag(&x[j]));
                            if (nounit)
                            {
                                i__3 = j + j * a_dim1;

                                z__1.r = tscal * a[i__3].r;
                                z__1.i = tscal * a[i__3].i;

                                tjjs.r = z__1.r;
                                tjjs.i = z__1.i;
                            }
                            else
                            {
                                tjjs.r = tscal;
                                tjjs.i = 0.0;
                                if (tscal == 1.0)
                                {
                                    goto L160;
                                }
                            }

                            // Compute x(j) = x(j) / A(j,j), scaling if necessary. 

                            tjj = Math.Abs(tjjs.r) + Math.Abs(d_imag(&tjjs));
                            if (tjj > smlnum)
                            {
                                // abs(A(j,j)) > SMLNUM: 

                                if (tjj < 1.0)
                                {
                                    if (xj > tjj * bignum)
                                    {
                                        // Scale X by 1/abs(x(j)). 

                                        rec = 1.0 / xj;
                                        zdscal(n, &rec, &x[1], &c__1);
                                        *scale *= rec;
                                        xmax *= rec;
                                    }
                                }

                                i__3 = j;
                                zladiv(&z__1, &x[j], &tjjs);
                                x[i__3].r = z__1.r;
                                x[i__3].i = z__1.i;
                            }
                            else if (tjj > 0.0)
                            {
                                // 0 < abs(A(j,j)) <= SMLNUM: 

                                if (xj > tjj * bignum)
                                {
                                    // Scale x by (1/abs(x(j)))*abs(A(j,j))*BIGNUM. 

                                    rec = tjj * bignum / xj;
                                    zdscal(n, &rec, &x[1], &c__1);
                                    *scale *= rec;
                                    xmax *= rec;
                                }

                                i__3 = j;
                                zladiv(&z__1, &x[j], &tjjs);
                                x[i__3].r = z__1.r;
                                x[i__3].i = z__1.i;
                            }
                            else
                            {
                                // A(j,j) = 0:  Set x(1:n) = 0, x(j) = 1, and 
                                // scale = 0 and compute a solution to A**T *x = 0. 

                                i__3 = *n;
                                for (i = 1; i <= i__3; ++i)
                                {
                                    i__4 = i;
                                    x[i__4].r = 0.0;
                                    x[i__4].i = 0.0;
                                }
                                i__3 = j;
                                x[i__3].r = 1.0;
                                x[i__3].i = 0.0;
                                *scale = 0.0;
                                xmax = 0.0;
                            }

                        L160:
                            ;
                        }
                        else
                        {
                            // Compute x(j) := x(j) / A(j,j) - CSUMJ if the dot 
                            // product has already been divided by 1/A(j,j). 

                            i__3 = j;
                            zladiv(&z__2, &x[j], &tjjs);

                            z__1.r = z__2.r - csumj.r;
                            z__1.i = z__2.i - csumj.i;

                            x[i__3].r = z__1.r;
                            x[i__3].i = z__1.i;
                        }

                        // Computing MAX 
                        i__3 = j;
                        d__3 = xmax;

                        d__4 = Math.Abs(x[i__3].r) + Math.Abs(d_imag(&x[j]));
                        xmax = Math.Max(d__3, d__4);
                    }

                }
                else
                {
                    // Solve A**H * x = b 

                    i__1 = jlast;
                    i__2 = jinc;
                    for (j = jfirst; i__2 < 0 ? j >= i__1 : j <= i__1; j += i__2)
                    {
                        // Compute x(j) = b(j) - sum A(k,j)*x(k). 
                        //                       k<>j 

                        i__3 = j;
                        xj = Math.Abs(x[i__3].r) + Math.Abs(d_imag(&x[j]));

                        uscal.r = tscal;
                        uscal.i = 0.0;
                        rec = 1.0 / Math.Max(xmax, 1.0);
                        if (cnorm[j] > (bignum - xj) * rec)
                        {
                            // If x(j) could overflow, scale x by 1/(2*XMAX). 

                            rec *= 0.5;
                            if (nounit)
                            {
                                d_cnjg(&z__2, &a[j + j * a_dim1]);

                                z__1.r = tscal * z__2.r;
                                z__1.i = tscal * z__2.i;

                                tjjs.r = z__1.r;
                                tjjs.i = z__1.i;
                            }
                            else
                            {
                                tjjs.r = tscal;
                                tjjs.i = 0.0;
                            }
                            tjj = Math.Abs(tjjs.r) + Math.Abs(d_imag(&tjjs));
                            if (tjj > 1.0)
                            {
                                // Divide by A(j,j) when scaling x if A(j,j) > 1. 

                                // Computing MIN 
                                d__1 = 1.0;
                                d__2 = rec * tjj;
                                rec = Math.Min(d__1, d__2);
                                zladiv(&z__1, &uscal, &tjjs);
                                uscal.r = z__1.r;
                                uscal.i = z__1.i;
                            }
                            if (rec < 1.0)
                            {
                                zdscal(n, &rec, &x[1], &c__1);
                                *scale *= rec;
                                xmax *= rec;
                            }
                        }

                        csumj.r = 0.0;
                        csumj.i = 0.0;
                        if (uscal.r == 1.0 && uscal.i == 0.0)
                        {
                            // If the scaling needed for A in the dot product is 1, 
                            // call ZDOTC to perform the dot product. 

                            if (upper)
                            {
                                i__3 = j - 1;
                                zdotc(&z__1, &i__3, &a[j * a_dim1 + 1], &c__1, &x[1],
                                     &c__1);
                                csumj.r = z__1.r;
                                csumj.i = z__1.i;
                            }
                            else if (j < *n)
                            {
                                i__3 = *n - j;
                                zdotc(&z__1, &i__3, &a[j + 1 + j * a_dim1], &c__1, &
                                    x[j + 1], &c__1);
                                csumj.r = z__1.r;
                                csumj.i = z__1.i;
                            }
                        }
                        else
                        {
                            // Otherwise, use in-line code for the dot product. 

                            if (upper)
                            {
                                i__3 = j - 1;
                                for (i = 1; i <= i__3; ++i)
                                {
                                    d_cnjg(&z__4, &a[i + j * a_dim1]);

                                    z__3.r = z__4.r * uscal.r - z__4.i * uscal.i;
                                    z__3.i = z__4.r * uscal.i + z__4.i * uscal.r;

                                    i__4 = i;

                                    z__2.r = z__3.r * x[i__4].r - z__3.i * x[i__4].i;
                                    z__2.i = z__3.r * x[i__4].i + z__3.i * x[i__4].r;

                                    z__1.r = csumj.r + z__2.r;
                                    z__1.i = csumj.i + z__2.i;

                                    csumj.r = z__1.r;
                                    csumj.i = z__1.i;
                                }
                            }
                            else if (j < *n)
                            {
                                i__3 = *n;
                                for (i = j + 1; i <= i__3; ++i)
                                {
                                    d_cnjg(&z__4, &a[i + j * a_dim1]);

                                    z__3.r = z__4.r * uscal.r - z__4.i * uscal.i;
                                    z__3.i = z__4.r * uscal.i + z__4.i * uscal.r;

                                    i__4 = i;

                                    z__2.r = z__3.r * x[i__4].r - z__3.i * x[i__4].i;
                                    z__2.i = z__3.r * x[i__4].i + z__3.i * x[i__4].r;

                                    z__1.r = csumj.r + z__2.r;
                                    z__1.i = csumj.i + z__2.i;

                                    csumj.r = z__1.r;
                                    csumj.i = z__1.i;
                                }
                            }
                        }

                        z__1.r = tscal;
                        z__1.i = 0.0;
                        if (uscal.r == z__1.r && uscal.i == z__1.i)
                        {
                            // Compute x(j) := ( x(j) - CSUMJ ) / A(j,j) if 1/A(j,j) 
                            // was not used to scale the dotproduct. 

                            i__3 = j;
                            i__4 = j;

                            z__1.r = x[i__4].r - csumj.r;
                            z__1.i = x[i__4].i - csumj.i;

                            x[i__3].r = z__1.r;
                            x[i__3].i = z__1.i;

                            i__3 = j;
                            xj = Math.Abs(x[i__3].r) + Math.Abs(d_imag(&x[j]));
                            if (nounit)
                            {
                                d_cnjg(&z__2, &a[j + j * a_dim1]);

                                z__1.r = tscal * z__2.r;
                                z__1.i = tscal * z__2.i;

                                tjjs.r = z__1.r;
                                tjjs.i = z__1.i;
                            }
                            else
                            {
                                tjjs.r = tscal;
                                tjjs.i = 0.0;
                                if (tscal == 1.0)
                                {
                                    goto L210;
                                }
                            }

                            // Compute x(j) = x(j) / A(j,j), scaling if necessary. 

                            tjj = Math.Abs(tjjs.r) + Math.Abs(d_imag(&tjjs));
                            if (tjj > smlnum)
                            {
                                // abs(A(j,j)) > SMLNUM: 

                                if (tjj < 1.0)
                                {
                                    if (xj > tjj * bignum)
                                    {
                                        // Scale X by 1/abs(x(j)). 

                                        rec = 1.0 / xj;
                                        zdscal(n, &rec, &x[1], &c__1);
                                        *scale *= rec;
                                        xmax *= rec;
                                    }
                                }
                                i__3 = j;
                                zladiv(&z__1, &x[j], &tjjs);

                                x[i__3].r = z__1.r;
                                x[i__3].i = z__1.i;
                            }
                            else if (tjj > 0.0)
                            {
                                // 0 < abs(A(j,j)) <= SMLNUM: 

                                if (xj > tjj * bignum)
                                {
                                    // Scale x by (1/abs(x(j)))*abs(A(j,j))*BIGNUM. 

                                    rec = tjj * bignum / xj;
                                    zdscal(n, &rec, &x[1], &c__1);
                                    *scale *= rec;
                                    xmax *= rec;
                                }
                                i__3 = j;
                                zladiv(&z__1, &x[j], &tjjs);
                                x[i__3].r = z__1.r;
                                x[i__3].i = z__1.i;
                            }
                            else
                            {
                                // A(j,j) = 0:  Set x(1:n) = 0, x(j) = 1, and 
                                // scale = 0 and compute a solution to A**H *x = 0. 

                                i__3 = *n;
                                for (i = 1; i <= i__3; ++i)
                                {
                                    i__4 = i;
                                    x[i__4].r = 0.0;
                                    x[i__4].i = 0.0;
                                }
                                i__3 = j;
                                x[i__3].r = 1.0;
                                x[i__3].i = 0.0;
                                *scale = 0.0;
                                xmax = 0.0;
                            }

                        L210:
                            ;
                        }
                        else
                        {
                            // Compute x(j) := x(j) / A(j,j) - CSUMJ if the dot 
                            // product has already been divided by 1/A(j,j). 

                            i__3 = j;
                            zladiv(&z__2, &x[j], &tjjs);

                            z__1.r = z__2.r - csumj.r;
                            z__1.i = z__2.i - csumj.i;

                            x[i__3].r = z__1.r;
                            x[i__3].i = z__1.i;
                        }
                        // Computing MAX 
                        i__3 = j;
                        d__3 = xmax;
                        d__4 = Math.Abs(x[i__3].r) + Math.Abs(d_imag(&x[j]));
                        xmax = Math.Max(d__3, d__4);
                    }
                }
                *scale /= tscal;
            }

            // Scale the column norms by 1/TSCAL for return. 

            if (tscal != 1.0)
            {
                d__1 = 1.0 / tscal;
                dscal(n, &d__1, &cnorm[1], &c__1);
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zrot(int* n, complex16* cx, int* incx,
            complex16* cy, int* incy, double* c, complex16* s)
        {
            //  -- LAPACK auxiliary routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. 
            //     November 2006 

            //  Purpose 
            //  ======= 

            //  ZROT   applies a plane rotation, where the cos (C) is real and the 
            //  sin (S) is complex, and the vectors CX and CY are complex. 

            //  Arguments 
            //  ========= 

            //  N       (input) int 
            //          The number of elements in the vectors CX and CY. 

            //  CX      (input/output) COMPLEX*16 array, dimension (N) 
            //          On input, the vector X. 
            //          On output, CX is overwritten with C*X + S*Y. 

            //  INCX    (input) int 
            //          The increment between successive values of CY.  INCX <> 0. 

            //  CY      (input/output) COMPLEX*16 array, dimension (N) 
            //          On input, the vector Y. 
            //          On output, CY is overwritten with -CONJG(S)*X + C*Y. 

            //  INCY    (input) int 
            //          The increment between successive values of CY.  INCX <> 0. 

            //  C       (input) DOUBLE PRECISION 
            //  S       (input) COMPLEX*16 
            //          C and S define a rotation 
            //             [  C          S  ] 
            //             [ -conjg(S)   C  ] 
            //          where C*C + S*CONJG(S) = 1.0. 

            // ===================================================================== 

            // System generated locals 
            int i__1, i__2, i__3, i__4;
            complex16 z__1, z__2, z__3, z__4;

            // Local variables 
            int i, ix, iy;
            complex16 stemp;

            // Parameter adjustments 
            --cy;
            --cx;

            // Function Body 
            if (*n <= 0)
            {
                return 0;
            }
            if (*incx == 1 && *incy == 1)
            {
                goto L20;
            }

            // Code for unequal increments or equal increments not equal to 1 

            ix = 1;
            iy = 1;
            if (*incx < 0)
            {
                ix = (-(*n) + 1) * *incx + 1;
            }

            if (*incy < 0)
            {
                iy = (-(*n) + 1) * *incy + 1;
            }

            i__1 = *n;

            for (i = 1; i <= i__1; ++i)
            {
                i__2 = ix;

                z__2.r = *c * cx[i__2].r;
                z__2.i = *c * cx[i__2].i;

                i__3 = iy;

                z__3.r = s.r * cy[i__3].r - s.i * cy[i__3].i;
                z__3.i = s.r * cy[i__3].i + s.i * cy[i__3].r;

                z__1.r = z__2.r + z__3.r;
                z__1.i = z__2.i + z__3.i;

                stemp.r = z__1.r;
                stemp.i = z__1.i;

                i__2 = iy;
                i__3 = iy;

                z__2.r = *c * cy[i__3].r;
                z__2.i = *c * cy[i__3].i;

                d_cnjg(&z__4, s);
                i__4 = ix;

                z__3.r = z__4.r * cx[i__4].r - z__4.i * cx[i__4].i;
                z__3.i = z__4.r * cx[i__4].i + z__4.i * cx[i__4].r;

                z__1.r = z__2.r - z__3.r;
                z__1.i = z__2.i - z__3.i;

                cy[i__2].r = z__1.r;
                cy[i__2].i = z__1.i;

                i__2 = ix;

                cx[i__2].r = stemp.r;
                cx[i__2].i = stemp.i;

                ix += *incx;
                iy += *incy;
            }
            return 0;

            // Code for both increments equal to 1 

        L20:
            i__1 = *n;

            for (i = 1; i <= i__1; ++i)
            {
                i__2 = i;

                z__2.r = *c * cx[i__2].r;
                z__2.i = *c * cx[i__2].i;

                i__3 = i;

                z__3.r = s.r * cy[i__3].r - s.i * cy[i__3].i;
                z__3.i = s.r * cy[i__3].i + s.i * cy[i__3].r;

                z__1.r = z__2.r + z__3.r;
                z__1.i = z__2.i + z__3.i;

                stemp.r = z__1.r;
                stemp.i = z__1.i;

                i__2 = i;
                i__3 = i;

                z__2.r = *c * cy[i__3].r;
                z__2.i = *c * cy[i__3].i;

                d_cnjg(&z__4, s);
                i__4 = i;

                z__3.r = z__4.r * cx[i__4].r - z__4.i * cx[i__4].i;
                z__3.i = z__4.r * cx[i__4].i + z__4.i * cx[i__4].r;

                z__1.r = z__2.r - z__3.r;
                z__1.i = z__2.i - z__3.i;

                cy[i__2].r = z__1.r;
                cy[i__2].i = z__1.i;

                i__2 = i;

                cx[i__2].r = stemp.r;
                cx[i__2].i = stemp.i;
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int ztrevc(string side, string howmny, bool* select,
            int* n, complex16* t, int* ldt, complex16* vl,
            int* ldvl, complex16* vr, int* ldvr, int* mm, int
            * m, complex16* work, double* rwork, int* info)
        {
            //  -- LAPACK routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. 
            //     November 2006 

            //  Purpose 
            //  ======= 

            //  ZTREVC computes some or all of the right and/or left eigenvectors of 
            //  a complex upper triangular matrix T. 
            //  Matrices of this type are produced by the Schur factorization of 
            //  a complex general matrix:  A = Q*T*Q**H, as computed by ZHSEQR. 

            //  The right eigenvector x and the left eigenvector y of T corresponding 
            //  to an eigenvalue w are defined by: 

            //               T*x = w*x,     (y**H)*T = w*(y**H) 

            //  where y**H denotes the conjugate transpose of the vector y. 
            //  The eigenvalues are not input to this_ routine, but are read directly 
            //  from the diagonal of T. 

            //  This routine returns the matrices X and/or Y of right and left 
            //  eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an 
            //  input matrix.  If Q is the unitary factor that reduces a matrix A to 
            //  Schur form T, then Q*X and Q*Y are the matrices of right and left 
            //  eigenvectors of A. 

            //  Arguments 
            //  ========= 

            //  SIDE    (input) CHARACTER*1 
            //          = 'R':  compute right eigenvectors only; 
            //          = 'L':  compute left eigenvectors only; 
            //          = 'B':  compute both right and left eigenvectors. 

            //  HOWMNY  (input) CHARACTER*1 
            //          = 'A':  compute all right and/or left eigenvectors; 
            //          = 'B':  compute all right and/or left eigenvectors, 
            //                  backtransformed using the matrices supplied in 
            //                  VR and/or VL; 
            //          = 'S':  compute selected right and/or left eigenvectors, 
            //                  as indicated by the bool array SELECT. 

            //  SELECT  (input) bool array, dimension (N) 
            //          If HOWMNY = 'S', SELECT specifies the eigenvectors to be 
            //          computed. 
            //          The eigenvector corresponding to the j-th eigenvalue is 
            //          computed if SELECT(j) = .TRUE.. 
            //          Not referenced if HOWMNY = 'A' or 'B'. 

            //  N       (input) int 
            //          The order of the matrix T. N >= 0. 

            //  T       (input/output) COMPLEX*16 array, dimension (LDT,N) 
            //          The upper triangular matrix T.  T is_ modified, but restored 
            //          on exit. 

            //  LDT     (input) int 
            //          The leading dimension of the array T. LDT >= max(1,N). 

            //  VL      (input/output) COMPLEX*16 array, dimension (LDVL,MM) 
            //          On entry, if SIDE = 'L' or 'B' and HOWMNY = 'B', VL must 
            //          contain an N-by-N matrix Q (usually the unitary matrix Q of 
            //          Schur vectors returned by ZHSEQR). 
            //          On exit, if SIDE = 'L' or 'B', VL contains: 
            //          if HOWMNY = 'A', the matrix Y of left eigenvectors of T; 
            //          if HOWMNY = 'B', the matrix Q*Y; 
            //          if HOWMNY = 'S', the left eigenvectors of T specified by 
            //                           SELECT, stored consecutively in the columns 
            //                           of VL, in the same order as their 
            //                           eigenvalues. 
            //          Not referenced if SIDE = 'R'. 

            //  LDVL    (input) int 
            //          The leading dimension of the array VL.  LDVL >= 1, and if 
            //          SIDE = 'L' or 'B', LDVL >= N. 

            //  VR      (input/output) COMPLEX*16 array, dimension (LDVR,MM) 
            //          On entry, if SIDE = 'R' or 'B' and HOWMNY = 'B', VR must 
            //          contain an N-by-N matrix Q (usually the unitary matrix Q of 
            //          Schur vectors returned by ZHSEQR). 
            //          On exit, if SIDE = 'R' or 'B', VR contains: 
            //          if HOWMNY = 'A', the matrix X of right eigenvectors of T; 
            //          if HOWMNY = 'B', the matrix Q*X; 
            //          if HOWMNY = 'S', the right eigenvectors of T specified by 
            //                           SELECT, stored consecutively in the columns 
            //                           of VR, in the same order as their 
            //                           eigenvalues. 
            //          Not referenced if SIDE = 'L'. 

            //  LDVR    (input) int 
            //          The leading dimension of the array VR.  LDVR >= 1, and if 
            //          SIDE = 'R' or 'B'; LDVR >= N. 

            //  MM      (input) int 
            //          The number of columns in the arrays VL and/or VR. MM >= M. 

            //  M       (output) int 
            //          The number of columns in the arrays VL and/or VR actually 
            //          used to store the eigenvectors.  If HOWMNY = 'A' or 'B', M 
            //          is set to N.  Each selected eigenvector occupies one 
            //          column. 

            //  WORK    (workspace) COMPLEX*16 array, dimension (2*N) 

            //  RWORK   (workspace) DOUBLE PRECis_ION array, dimension (N) 

            //  INFO    (output) int 
            //          = 0:  successful exit 
            //          < 0:  if INFO = -i, the i-th argument had an illegal value 

            //  Further Details 
            //  =============== 

            //  The algorithm used in this program is_ basically backward (forward) 
            //  substitution, with scaling to make the the code robust against 
            //  possible overflow. 

            //  Each eigenvector is_ normalized so that the element of largest 
            //  magnitude has magnitude 1; here the magnitude of a complex number 
            //  (x,y) is taken to be |x| + |y|. 

            //  ===================================================================== 

            // System generated locals 
            int t_dim1, t_offset, vl_dim1, vl_offset, vr_dim1, vr_offset, i__1, i__2, i__3, i__4, i__5;
            double d__3;
            complex16 z__1, z__2;

            // Table of constant values
            complex16 c_b2 = new complex16(1.0, 0.0);
            int c__1 = 1;

            // Local variables 
            int i, j, k, ii, ki, is_;
            double ulp;
            bool allv;
            double unfl, ovfl, smin;
            bool over;
            double scale = 0;
            double remax;
            bool leftv, bothv;
            bool somev;
            bool rightv;
            double smlnum;

            // Parameter adjustments 
            --select;
            t_dim1 = *ldt;
            t_offset = 1 + t_dim1;
            t -= t_offset;
            vl_dim1 = *ldvl;
            vl_offset = 1 + vl_dim1;
            vl -= vl_offset;
            vr_dim1 = *ldvr;
            vr_offset = 1 + vr_dim1;
            vr -= vr_offset;
            --work;
            --rwork;

            // Function Body 
            bothv = lsame(side, "B");
            rightv = lsame(side, "R") || bothv;
            leftv = lsame(side, "L") || bothv;

            allv = lsame(howmny, "A");
            over = lsame(howmny, "B");
            somev = lsame(howmny, "S");

            // Set M to the number of columns required to store the selected 
            // eigenvectors. 

            if (somev)
            {
                *m = 0;
                i__1 = *n;
                for (j = 1; j <= i__1; ++j)
                {
                    if (select[j])
                    {
                        ++(*m);
                    }
                }
            }
            else
            {
                *m = *n;
            }

            *info = 0;
            if (!rightv && !leftv)
            {
                *info = -1;
            }
            else if (!allv && !over && !somev)
            {
                *info = -2;
            }
            else if (*n < 0)
            {
                *info = -4;
            }
            else if (*ldt < Math.Max(1, *n))
            {
                *info = -6;
            }
            else if (*ldvl < 1 || leftv && *ldvl < *n)
            {
                *info = -8;
            }
            else if (*ldvr < 1 || rightv && *ldvr < *n)
            {
                *info = -10;
            }
            else if (*mm < *m)
            {
                *info = -11;
            }

            if (*info != 0)
            {
                i__1 = -(*info);
                xerbla("ZTREVC", &i__1);
                return 0;
            }

            // Quick return if possible. 

            if (*n == 0)
            {
                return 0;
            }

            // Set the constants to control overflow. 

            unfl = dlamch("Safe minimum");
            ovfl = 1.0 / unfl;
            dlabad(&unfl, &ovfl);
            ulp = dlamch("Precision");
            smlnum = unfl * (*n / ulp);

            // Store the diagonal elements of T in working array WORK. 

            i__1 = *n;
            for (i = 1; i <= i__1; ++i)
            {
                i__2 = i + *n;
                i__3 = i + i * t_dim1;

                work[i__2].r = t[i__3].r;
                work[i__2].i = t[i__3].i;
            }

            //     Compute 1-norm of each column of strictly upper triangular 
            //     part of T to control overflow in triangular solver. 

            rwork[1] = 0.0;
            i__1 = *n;
            for (j = 2; j <= i__1; ++j)
            {
                i__2 = j - 1;
                rwork[j] = dzasum(&i__2, &t[j * t_dim1 + 1], &c__1);
            }

            if (rightv)
            {
                //Compute right eigenvectors. 

                is_ = *m;
                for (ki = *n; ki >= 1; --ki)
                {

                    if (somev)
                    {
                        if (!select[ki])
                        {
                            goto L80;
                        }
                    }

                    // Computing MAX 
                    i__1 = ki + ki * t_dim1;
                    d__3 = ulp * (Math.Abs(t[i__1].r) + Math.Abs(d_imag(&t[ki + ki * t_dim1])));
                    smin = Math.Max(d__3, smlnum);

                    work[1].r = 1.0;
                    work[1].i = 0.0;

                    // Form right-hand side. 

                    i__1 = ki - 1;
                    for (k = 1; k <= i__1; ++k)
                    {
                        i__2 = k;
                        i__3 = k + ki * t_dim1;

                        z__1.r = -t[i__3].r;
                        z__1.i = -t[i__3].i;

                        work[i__2].r = z__1.r;
                        work[i__2].i = z__1.i;
                    }

                    // Solve the triangular system: 
                    // (T(1:KI-1,1:KI-1) - T(KI,KI))*X = SCALE*WORK. 

                    i__1 = ki - 1;
                    for (k = 1; k <= i__1; ++k)
                    {
                        i__2 = k + k * t_dim1;
                        i__3 = k + k * t_dim1;
                        i__4 = ki + ki * t_dim1;

                        z__1.r = t[i__3].r - t[i__4].r;
                        z__1.i = t[i__3].i - t[i__4].i;

                        t[i__2].r = z__1.r;
                        t[i__2].i = z__1.i;

                        i__2 = k + k * t_dim1;

                        if (Math.Abs(t[i__2].r) + Math.Abs(d_imag(&t[k + k * t_dim1])) < smin)
                        {
                            i__3 = k + k * t_dim1;
                            t[i__3].r = smin;
                            t[i__3].i = 0.0;
                        }
                    }

                    if (ki > 1)
                    {
                        i__1 = ki - 1;
                        zlatrs("Upper", "No transpose", "Non-unit", "Y", &i__1, &t[t_offset], ldt, &work[1], &scale, &rwork[1], info);
                        i__1 = ki;

                        work[i__1].r = scale;
                        work[i__1].i = 0.0;
                    }

                    // Copy the vector x or Q*x to VR and normalize. 

                    if (!over)
                    {
                        zcopy(&ki, &work[1], &c__1, &vr[is_ * vr_dim1 + 1], &c__1);

                        ii = izamax(&ki, &vr[is_ * vr_dim1 + 1], &c__1);
                        i__1 = ii + is_ * vr_dim1;

                        remax = 1.0 / (Math.Abs(vr[i__1].r) + Math.Abs(d_imag(&vr[ii + is_ * vr_dim1])));

                        zdscal(&ki, &remax, &vr[is_ * vr_dim1 + 1], &c__1);

                        i__1 = *n;
                        for (k = ki + 1; k <= i__1; ++k)
                        {
                            i__2 = k + is_ * vr_dim1;
                            vr[i__2].r = 0.0;
                            vr[i__2].i = 0.0;
                        }
                    }
                    else
                    {
                        if (ki > 1)
                        {
                            i__1 = ki - 1;
                            z__1.r = scale;
                            z__1.i = 0.0;
                            zgemv("N", n, &i__1, &c_b2, &vr[vr_offset], ldvr, &work[1], &c__1, &z__1, &vr[ki * vr_dim1 + 1], &c__1);
                        }

                        ii = izamax(n, &vr[ki * vr_dim1 + 1], &c__1);
                        i__1 = ii + ki * vr_dim1;
                        remax = 1.0 / (Math.Abs(vr[i__1].r) + Math.Abs(d_imag(&vr[ii + ki * vr_dim1])));
                        zdscal(n, &remax, &vr[ki * vr_dim1 + 1], &c__1);
                    }

                    // Set back the original diagonal elements of T. 

                    i__1 = ki - 1;
                    for (k = 1; k <= i__1; ++k)
                    {
                        i__2 = k + k * t_dim1;
                        i__3 = k + *n;
                        t[i__2].r = work[i__3].r;
                        t[i__2].i = work[i__3].i;
                    }

                    --is_;
                L80:
                    ;
                }
            }

            if (leftv)
            {
                // Compute left eigenvectors. 

                is_ = 1;
                i__1 = *n;
                for (ki = 1; ki <= i__1; ++ki)
                {

                    if (somev)
                    {
                        if (!select[ki])
                        {
                            goto L130;
                        }
                    }

                    // Computing MAX 
                    i__2 = ki + ki * t_dim1;
                    d__3 = ulp * (Math.Abs(t[i__2].r) + Math.Abs(d_imag(&t[ki + ki * t_dim1])));
                    smin = Math.Max(d__3, smlnum);

                    i__2 = *n;
                    work[i__2].r = 1.0;
                    work[i__2].i = 0.0;

                    // Form right-hand side. 

                    i__2 = *n;
                    for (k = ki + 1; k <= i__2; ++k)
                    {
                        i__3 = k;
                        d_cnjg(&z__2, &t[ki + k * t_dim1]);

                        z__1.r = -z__2.r;
                        z__1.i = -z__2.i;

                        work[i__3].r = z__1.r;
                        work[i__3].i = z__1.i;
                    }

                    // Solve the triangular system: 
                    // (T(KI+1:N,KI+1:N) - T(KI,KI))'*X = SCALE*WORK. 

                    i__2 = *n;
                    for (k = ki + 1; k <= i__2; ++k)
                    {
                        i__3 = k + k * t_dim1;
                        i__4 = k + k * t_dim1;
                        i__5 = ki + ki * t_dim1;

                        z__1.r = t[i__4].r - t[i__5].r;
                        z__1.i = t[i__4].i - t[i__5].i;

                        t[i__3].r = z__1.r;
                        t[i__3].i = z__1.i;

                        i__3 = k + k * t_dim1;

                        if (Math.Abs(t[i__3].r) + Math.Abs(d_imag(&t[k + k * t_dim1])) < smin)
                        {
                            i__4 = k + k * t_dim1;
                            t[i__4].r = smin;
                            t[i__4].i = 0.0;
                        }
                    }

                    if (ki < *n)
                    {
                        i__2 = *n - ki;
                        zlatrs("Upper", "Conjugate transpose", "Non-unit", "Y", &i__2, &t[ki + 1 + (ki + 1) * t_dim1], ldt, &work[ki + 1], &scale, &rwork[1], info);
                        i__2 = ki;

                        work[i__2].r = scale;
                        work[i__2].i = 0.0;
                    }

                    // Copy the vector x or Q*x to VL and normalize. 

                    if (!over)
                    {
                        i__2 = *n - ki + 1;
                        zcopy(&i__2, &work[ki], &c__1, &vl[ki + is_ * vl_dim1], &c__1);

                        i__2 = *n - ki + 1;
                        ii = izamax(&i__2, &vl[ki + is_ * vl_dim1], &c__1) + ki - 1;
                        i__2 = ii + is_ * vl_dim1;

                        remax = 1.0 / (Math.Abs(vl[i__2].r) + Math.Abs(d_imag(&vl[ii + is_ * vl_dim1])));

                        i__2 = *n - ki + 1;
                        zdscal(&i__2, &remax, &vl[ki + is_ * vl_dim1], &c__1);

                        i__2 = ki - 1;
                        for (k = 1; k <= i__2; ++k)
                        {
                            i__3 = k + is_ * vl_dim1;
                            vl[i__3].r = 0.0;
                            vl[i__3].i = 0.0;
                        }
                    }
                    else
                    {
                        if (ki < *n)
                        {
                            i__2 = *n - ki;
                            z__1.r = scale;
                            z__1.i = 0.0;

                            zgemv("N", n, &i__2, &c_b2, &vl[(ki + 1) * vl_dim1 + 1], ldvl, &work[ki + 1], &c__1, &z__1, &vl[ki * vl_dim1 + 1], &c__1);
                        }

                        ii = izamax(n, &vl[ki * vl_dim1 + 1], &c__1);
                        i__2 = ii + ki * vl_dim1;

                        remax = 1.0 / (Math.Abs(vl[i__2].r) + Math.Abs(d_imag(&vl[ii + ki * vl_dim1])));

                        zdscal(n, &remax, &vl[ki * vl_dim1 + 1], &c__1);
                    }

                    // Set back the original diagonal elements of T. 

                    i__2 = *n;
                    for (k = ki + 1; k <= i__2; ++k)
                    {
                        i__3 = k + k * t_dim1;
                        i__4 = k + *n;

                        t[i__3].r = work[i__4].r;
                        t[i__3].i = work[i__4].i;
                    }

                    ++is_;
                L130:
                    ;
                }
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int ztrexc(string compq, int* n, complex16* t,
            int* ldt, complex16* q, int* ldq, int* ifst, int* ilst, int* info)
        {
            //  -- LAPACK routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. 
            //     November 2006 

            //  Purpose 
            //  ======= 

            //  ZTREXC reorders the Schur factorization of a complex matrix 
            //  A = Q*T*Q**H, so that the diagonal element of T with row index IFST 
            //  is moved to row ILST. 

            //  The Schur form T is reordered by a unitary similarity transformation 
            //  Z**H*T*Z, and optionally the matrix Q of Schur vectors is updated by 
            //  postmultplying it with Z. 

            //  Arguments 
            //  ========= 

            //  COMPQ   (input) CHARACTER*1 
            //          = 'V':  update the matrix Q of Schur vectors; 
            //          = 'N':  do not update Q. 

            //  N       (input) int 
            //          The order of the matrix T. N >= 0. 

            //  T       (input/output) COMPLEX*16 array, dimension (LDT,N) 
            //          On entry, the upper triangular matrix T. 
            //          On exit, the reordered upper triangular matrix. 

            //  LDT     (input) int 
            //          The leading dimension of the array T. LDT >= max(1,N). 

            //  Q       (input/output) COMPLEX*16 array, dimension (LDQ,N) 
            //          On entry, if COMPQ = 'V', the matrix Q of Schur vectors. 
            //          On exit, if COMPQ = 'V', Q has been postmultiplied by the 
            //          unitary transformation matrix Z which reorders T. 
            //          If COMPQ = 'N', Q is not referenced. 

            //  LDQ     (input) int 
            //          The leading dimension of the array Q.  LDQ >= max(1,N). 

            //  IFST    (input) int 
            //  ILST    (input) int 
            //          Specify the reordering of the diagonal elements of T: 
            //          The element with row index IFST is moved to row ILST by a 
            //          sequence of transpositions between adjacent elements. 
            //          1 <= IFST <= N; 1 <= ILST <= N. 

            //  INFO    (output) int 
            //          = 0:  successful exit 
            //          < 0:  if INFO = -i, the i-th argument had an illegal value 

            //  ===================================================================== 

            // System generated locals 
            int q_dim1, q_offset, t_dim1, t_offset, i__1, i__2, i__3;
            complex16 z__1;

            // Table of constant values
            int c__1 = 1;

            // Local variables 
            int k, m1, m2, m3;
            double cs;
            complex16 t11, t22, sn, temp;
            bool wantq;

            // Parameter adjustments 
            t_dim1 = *ldt;
            t_offset = 1 + t_dim1;
            t -= t_offset;
            q_dim1 = *ldq;
            q_offset = 1 + q_dim1;
            q -= q_offset;

            // Function Body 
            *info = 0;
            wantq = lsame(compq, "V");

            if (!lsame(compq, "N") && !wantq)
            {
                *info = -1;
            }
            else if (*n < 0)
            {
                *info = -2;
            }
            else if (*ldt < Math.Max(1, *n))
            {
                *info = -4;
            }
            else if (*ldq < 1 || wantq && *ldq < Math.Max(1, *n))
            {
                *info = -6;
            }
            else if (*ifst < 1 || *ifst > *n)
            {
                *info = -7;
            }
            else if (*ilst < 1 || *ilst > *n)
            {
                *info = -8;
            }

            if (*info != 0)
            {
                i__1 = -(*info);
                xerbla("ZTREXC", &i__1);
                return 0;
            }

            // Quick return if possible 

            if (*n == 1 || *ifst == *ilst)
            {
                return 0;
            }

            if (*ifst < *ilst)
            {
                //  Move the IFST-th diagonal element forward down the diagonal. 

                m1 = 0;
                m2 = -1;
                m3 = 1;
            }
            else
            {
                // Move the IFST-th diagonal element backward up the diagonal. 

                m1 = -1;
                m2 = 0;
                m3 = -1;
            }

            i__1 = *ilst + m2;
            i__2 = m3;
            for (k = *ifst + m1; i__2 < 0 ? k >= i__1 : k <= i__1; k += i__2)
            {
                // Interchange the k-th and (k+1)-th diagonal elements. 

                i__3 = k + k * t_dim1;
                t11.r = t[i__3].r;
                t11.i = t[i__3].i;

                i__3 = k + 1 + (k + 1) * t_dim1;

                t22.r = t[i__3].r;
                t22.i = t[i__3].i;

                // Determine the transformation to perform the interchange. 

                z__1.r = t22.r - t11.r;
                z__1.i = t22.i - t11.i;

                zlartg(&t[k + (k + 1) * t_dim1], &z__1, &cs, &sn, &temp);

                // Apply transformation to the matrix T. 

                if (k + 2 <= *n)
                {
                    i__3 = *n - k - 1;
                    zrot(&i__3, &t[k + (k + 2) * t_dim1], ldt, &t[k + 1 + (k + 2) * t_dim1], ldt, &cs, &sn);
                }

                i__3 = k - 1;
                d_cnjg(&z__1, &sn);
                zrot(&i__3, &t[k * t_dim1 + 1], &c__1, &t[(k + 1) * t_dim1 + 1], &c__1, &cs, &z__1);

                i__3 = k + k * t_dim1;

                t[i__3].r = t22.r;
                t[i__3].i = t22.i;

                i__3 = k + 1 + (k + 1) * t_dim1;
                t[i__3].r = t11.r;
                t[i__3].i = t11.i;

                if (wantq)
                {
                    // Accumulate transformation in the matrix Q. 

                    d_cnjg(&z__1, &sn);
                    zrot(n, &q[k * q_dim1 + 1], &c__1, &q[(k + 1) * q_dim1 + 1], &c__1, &cs, &z__1);
                }
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int ztrsna(string job, string howmny, bool* select,
            int* n, complex16* t, int* ldt, complex16* vl,
            int* ldvl, complex16* vr, int* ldvr, double* s,
            double* sep, int* mm, int* m, complex16* work,
            int* ldwork, double* rwork, int* info)
        {
            //  -- LAPACK routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. 
            //     November 2006 

            //     Modified to call ZLACN2 in place of ZLACON, 10 Feb 03, SJH. 

            //  Purpose 
            //  ======= 

            //  ZTRSNA estimates reciprocal condition numbers for specified 
            //  eigenvalues and/or right eigenvectors of a complex upper triangular 
            //  matrix T (or of any matrix Q*T*Q**H with Q unitary). 

            //  Arguments 
            //  ========= 

            //  JOB     (input) CHARACTER*1 
            //          Specifies whether condition numbers are required for 
            //          eigenvalues (S) or eigenvectors (SEP): 
            //          = 'E': for eigenvalues only (S); 
            //          = 'V': for eigenvectors only (SEP); 
            //          = 'B': for both eigenvalues and eigenvectors (S and SEP). 

            //  HOWMNY  (input) CHARACTER*1 
            //          = 'A': compute condition numbers for all eigenpairs; 
            //          = 'S': compute condition numbers for selected eigenpairs 
            //                 specified by the array SELECT. 

            //  SELECT  (input) bool array, dimension (N) 
            //          If HOWMNY = 'S', SELECT specifies the eigenpairs for which 
            //          condition numbers are required. To select condition numbers 
            //          for the j-th eigenpair, SELECT(j) must be set to .TRUE.. 
            //          If HOWMNY = 'A', SELECT is not referenced. 

            //  N       (input) int 
            //          The order of the matrix T. N >= 0. 

            //  T       (input) COMPLEX*16 array, dimension (LDT,N) 
            //          The upper triangular matrix T. 

            //  LDT     (input) int 
            //          The leading dimension of the array T. LDT >= max(1,N). 

            //  VL      (input) COMPLEX*16 array, dimension (LDVL,M) 
            //          If JOB = 'E' or 'B', VL must contain left eigenvectors of T 
            //          (or of any Q*T*Q**H with Q unitary), corresponding to the 
            //          eigenpairs specified by HOWMNY and SELECT. The eigenvectors 
            //          must be stored in consecutive columns of VL, as returned by 
            //          ZHSEIN or ZTREVC. 
            //          If JOB = 'V', VL is not referenced. 

            //  LDVL    (input) int 
            //          The leading dimension of the array VL. 
            //          LDVL >= 1; and if JOB = 'E' or 'B', LDVL >= N. 

            //  VR      (input) COMPLEX*16 array, dimension (LDVR,M) 
            //          If JOB = 'E' or 'B', VR must contain right eigenvectors of T 
            //          (or of any Q*T*Q**H with Q unitary), corresponding to the 
            //          eigenpairs specified by HOWMNY and SELECT. The eigenvectors 
            //          must be stored in consecutive columns of VR, as returned by 
            //          ZHSEIN or ZTREVC. 
            //          If JOB = 'V', VR is not referenced. 

            //  LDVR    (input) int 
            //          The leading dimension of the array VR. 
            //          LDVR >= 1; and if JOB = 'E' or 'B', LDVR >= N. 

            //  S       (output) DOUBLE PRECISION array, dimension (MM) 
            //          If JOB = 'E' or 'B', the reciprocal condition numbers of the 
            //          selected eigenvalues, stored in consecutive elements of the 
            //          array. Thus S(j), SEP(j), and the j-th columns of VL and VR 
            //          all correspond to the same eigenpair (but not in general the 
            //          j-th eigenpair, unless all eigenpairs are selected). 
            //          If JOB = 'V', S is not referenced. 

            //  SEP     (output) DOUBLE PRECISION array, dimension (MM) 
            //          If JOB = 'V' or 'B', the estimated reciprocal condition 
            //          numbers of the selected eigenvectors, stored in consecutive 
            //          elements of the array. 
            //          If JOB = 'E', SEP is not referenced. 

            //  MM      (input) int 
            //          The number of elements in the arrays S (if JOB = 'E' or 'B') 
            //           and/or SEP (if JOB = 'V' or 'B'). MM >= M. 

            //  M       (output) int 
            //          The number of elements of the arrays S and/or SEP actually 
            //          used to store the estimated condition numbers. 
            //          If HOWMNY = 'A', M is set to N. 

            //  WORK    (workspace) COMPLEX*16 array, dimension (LDWORK,N+6) 
            //          If JOB = 'E', WORK is not referenced. 

            //  LDWORK  (input) int 
            //          The leading dimension of the array WORK. 
            //          LDWORK >= 1; and if JOB = 'V' or 'B', LDWORK >= N. 

            //  RWORK   (workspace) DOUBLE PRECISION array, dimension (N) 
            //          If JOB = 'E', RWORK is not referenced. 

            //  INFO    (output) int 
            //          = 0: successful exit 
            //          < 0: if INFO = -i, the i-th argument had an illegal value 

            //  Further Details 
            //  =============== 

            //  The reciprocal of the condition number of an eigenvalue lambda is 
            //  defined as 

            //          S(lambda) = |v'*u| / (norm(u)*norm(v)) 

            //  where u and v are the right and left eigenvectors of T corresponding 
            //  to lambda; v' denotes the conjugate transpose of v, and norm(u) 
            //  denotes the Euclidean norm. These reciprocal condition numbers always 
            //  lie between zero (very badly conditioned) and one (very well 
            //  conditioned). If n = 1, S(lambda) is defined to be 1. 

            //  An approximate error bound for a computed eigenvalue W(i) is given by 

            //                      EPS * norm(T) / S(i) 

            //  where EPS is the machine precision. 

            //  The reciprocal of the condition number of the right eigenvector u 
            //  corresponding to lambda is defined as follows. Suppose 

            //              T = ( lambda  c  ) 
            //                  (   0    T22 ) 

            //  Then the reciprocal condition number is 

            //          SEP( lambda, T22 ) = sigma-min( T22 - lambda*I ) 

            //  where sigma-min denotes the smallest singular value. We approximate 
            //  the smallest singular value by the reciprocal of an estimate of the 
            //  one-norm of the inverse of T22 - lambda*I. If n = 1, SEP(1) is 
            //  defined to be abs(T(1,1)). 

            //  An approximate error bound for a computed right eigenvector VR(i) 
            //  is given by 

            //                      EPS * norm(T) / SEP(i) 

            //  ===================================================================== 

            // System generated locals 
            int t_dim1, t_offset, vl_dim1, vl_offset, vr_dim1, vr_offset,
                work_dim1, work_offset, i__1, i__2, i__3, i__4, i__5;
            complex16 z__1;

            // Table of constant values
            int c__1 = 1;

            // Local variables 
            int i__, j, k, ks, ix;
            double eps, est;
            int kase, ierr;
            complex16 prod;
            double lnrm, rnrm, scale;
            int[] isave = new int[3];
            complex16[] dummy = new complex16[1];
            bool wants;
            double xnorm;
            double bignum;
            bool wantbh;
            bool somcon;
            string normin;
            double smlnum;
            bool wantsp;

            // Parameter adjustments 
            --select;
            t_dim1 = *ldt;
            t_offset = 1 + t_dim1;
            t -= t_offset;
            vl_dim1 = *ldvl;
            vl_offset = 1 + vl_dim1;
            vl -= vl_offset;
            vr_dim1 = *ldvr;
            vr_offset = 1 + vr_dim1;
            vr -= vr_offset;
            --s;
            --sep;
            work_dim1 = *ldwork;
            work_offset = 1 + work_dim1;
            work -= work_offset;
            --rwork;

            // Function Body 
            wantbh = lsame(job, "B");
            wants = lsame(job, "E") || wantbh;
            wantsp = lsame(job, "V") || wantbh;

            somcon = lsame(howmny, "S");

            // Set M to the number of eigenpairs for which condition numbers are 
            // to be computed. 

            if (somcon)
            {
                *m = 0;
                i__1 = *n;

                for (j = 1; j <= i__1; ++j)
                {
                    if (select[j])
                    {
                        ++(*m);
                    }
                }
            }
            else
            {
                *m = *n;
            }

            *info = 0;
            if (!wants && !wantsp)
            {
                *info = -1;
            }
            else if (!lsame(howmny, "A") && !somcon)
            {
                *info = -2;
            }
            else if (*n < 0)
            {
                *info = -4;
            }
            else if (*ldt < Math.Max(1, *n))
            {
                *info = -6;
            }
            else if (*ldvl < 1 || wants && *ldvl < *n)
            {
                *info = -8;
            }
            else if (*ldvr < 1 || wants && *ldvr < *n)
            {
                *info = -10;
            }
            else if (*mm < *m)
            {
                *info = -13;
            }
            else if (*ldwork < 1 || wantsp && *ldwork < *n)
            {
                *info = -16;
            }

            if (*info != 0)
            {
                i__1 = -(*info);
                xerbla("ZTRSNA", &i__1);
                return 0;
            }

            // Quick return if possible 

            if (*n == 0)
            {
                return 0;
            }

            if (*n == 1)
            {
                if (somcon)
                {
                    if (!select[1])
                    {
                        return 0;
                    }
                }
                if (wants)
                {
                    s[1] = 1.0;
                }
                if (wantsp)
                {
                    sep[1] = z_abs(&t[t_dim1 + 1]);
                }
                return 0;
            }

            // Get machine constants 

            eps = dlamch("P");
            smlnum = dlamch("S") / eps;
            bignum = 1.0 / smlnum;
            dlabad(&smlnum, &bignum);

            ks = 1;
            i__1 = *n;
            for (k = 1; k <= i__1; ++k)
            {
                if (somcon)
                {
                    if (!select[k])
                    {
                        goto L50;
                    }
                }

                if (wants)
                {
                    // Compute the reciprocal condition number of the k-th 
                    // eigenvalue. 

                    zdotc(&z__1, n, &vr[ks * vr_dim1 + 1], &c__1, &vl[ks * vl_dim1 + 1], &c__1);

                    prod.r = z__1.r;
                    prod.i = z__1.i;

                    rnrm = dznrm2(n, &vr[ks * vr_dim1 + 1], &c__1);
                    lnrm = dznrm2(n, &vl[ks * vl_dim1 + 1], &c__1);

                    s[ks] = z_abs(&prod) / (rnrm * lnrm);
                }

                if (wantsp)
                {
                    // Estimate the reciprocal condition number of the k-th 
                    // eigenvector. 

                    // Copy the matrix T to the array WORK and swap the k-th 
                    // diagonal element to the (1,1) position. 

                    zlacpy("Full", n, n, &t[t_offset], ldt, &work[work_offset], ldwork);
                    ztrexc("No Q", n, &work[work_offset], ldwork, dummy, &c__1, &k, &c__1, &ierr);

                    // Form  C = T22 - lambda*I in WORK(2:N,2:N). 

                    i__2 = *n;
                    for (i__ = 2; i__ <= i__2; ++i__)
                    {
                        i__3 = i__ + i__ * work_dim1;
                        i__4 = i__ + i__ * work_dim1;
                        i__5 = work_dim1 + 1;

                        z__1.r = work[i__4].r - work[i__5].r;
                        z__1.i = work[i__4].i - work[i__5].i;

                        work[i__3].r = z__1.r;
                        work[i__3].i = z__1.i;
                    }

                    // Estimate a lower bound for the 1-norm of inv(C'). The 1st 
                    // and (N+1)th columns of WORK are used to store work vectors. 

                    sep[ks] = 0.0;
                    est = 0.0;
                    kase = 0;

                    normin = "N";

                L30:
                    i__2 = *n - 1;
                    zlacn2(&i__2, &work[(*n + 1) * work_dim1 + 1], &work[work_offset], &est, &kase, isave);

                    if (kase != 0)
                    {
                        if (kase == 1)
                        {
                            // Solve C'*x = scale*b 

                            i__2 = *n - 1;
                            zlatrs("Upper", "Conjugate transpose", "Nonunit", normin, &i__2, &work[(work_dim1 << 1) + 2],
                                ldwork, &work[work_offset], &scale, &rwork[1], &ierr);
                        }
                        else
                        {
                            // Solve C*x = scale*b 
                            i__2 = *n - 1;
                            zlatrs("Upper", "No transpose", "Nonunit", normin, &i__2, &work[(work_dim1 << 1) + 2],
                                ldwork, &work[work_offset], &scale, &rwork[1], &ierr);
                        }

                        normin = "Y";
                        if (scale != 1.0)
                        {
                            // Multiply by 1/SCALE if doing so will not cause 
                            // overflow. 
                            i__2 = *n - 1;
                            ix = izamax(&i__2, &work[work_offset], &c__1);
                            i__2 = ix + work_dim1;

                            xnorm = Math.Abs(work[i__2].r) + Math.Abs(d_imag(&work[ix + work_dim1]));

                            if (scale < xnorm * smlnum || scale == 0.0)
                            {
                                goto L40;
                            }
                            zdrscl(n, &scale, &work[work_offset], &c__1);
                        }
                        goto L30;
                    }

                    sep[ks] = 1.0 / Math.Max(est, smlnum);
                }

            L40:
                ++ks;
            L50:
                ;
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zung2r(int* m, int* n, int* k, complex16* a,
            int* lda, complex16* tau, complex16* work, int* info)
        {
            //  -- LAPACK routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. 
            //     November 2006 

            //  Purpose 
            //  ======= 

            //  ZUNG2R generates an m by n complex matrix Q with orthonormal columns, 
            //  which is defined as the first n columns of a product of k elementary 
            //  reflectors of order m 

            //        Q  =  H(1) H(2) . . . H(k) 

            //  as returned by ZGEQRF. 

            //  Arguments 
            //  ========= 

            //  M       (input) int 
            //          The number of rows of the matrix Q. M >= 0. 

            //  N       (input) int 
            //          The number of columns of the matrix Q. M >= N >= 0. 

            //  K       (input) int 
            //          The number of elementary reflectors whose product defines the 
            //          matrix Q. N >= K >= 0. 

            //  A       (input/output) COMPLEX*16 array, dimension (LDA,N) 
            //          On entry, the i-th column must contain the vector which 
            //          defines the elementary reflector H(i), for i = 1,2,...,k, as 
            //          returned by ZGEQRF in the first k columns of its array 
            //          argument A. 
            //          On exit, the m by n matrix Q. 

            //  LDA     (input) int 
            //          The first dimension of the array A. LDA >= max(1,M). 

            //  TAU     (input) COMPLEX*16 array, dimension (K) 
            //          TAU(i) must contain the scalar factor of the elementary 
            //          reflector H(i), as returned by ZGEQRF. 

            //  WORK    (workspace) COMPLEX*16 array, dimension (N) 

            //  INFO    (output) int 
            //          = 0: successful exit 
            //          < 0: if INFO = -i, the i-th argument has an illegal value 

            //  ===================================================================== 

            // System generated locals 
            int a_dim1, a_offset, i__1, i__2, i__3;
            complex16 z__1;

            // Table of constant values
            int c__1 = 1;

            // Local variables 
            int i, j, l;

            // Parameter adjustments 
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;
            --tau;
            --work;

            // Function Body 
            *info = 0;
            if (*m < 0)
            {
                *info = -1;
            }
            else if (*n < 0 || *n > *m)
            {
                *info = -2;
            }
            else if (*k < 0 || *k > *n)
            {
                *info = -3;
            }
            else if (*lda < Math.Max(1, *m))
            {
                *info = -5;
            }

            if (*info != 0)
            {
                i__1 = -(*info);
                xerbla("ZUNG2R", &i__1);
                return 0;
            }

            // Quick return if possible 

            if (*n <= 0)
            {
                return 0;
            }

            // Initialise columns k+1:n to columns of the unit matrix 

            i__1 = *n;
            for (j = *k + 1; j <= i__1; ++j)
            {
                i__2 = *m;

                for (l = 1; l <= i__2; ++l)
                {
                    i__3 = l + j * a_dim1;
                    a[i__3].r = 0.0;
                    a[i__3].i = 0.0;
                }

                i__2 = j + j * a_dim1;

                a[i__2].r = 1.0;
                a[i__2].i = 0.0;
            }

            for (i = *k; i >= 1; --i)
            {
                // Apply H(i) to A(i:m,i:n) from the left 

                if (i < *n)
                {
                    i__1 = i + i * a_dim1;

                    a[i__1].r = 1.0;
                    a[i__1].i = 0.0;
                    i__1 = *m - i + 1;
                    i__2 = *n - i;

                    zlarf("Left", &i__1, &i__2, &a[i + i * a_dim1], &c__1,
                        &tau[i], &a[i + (i + 1) * a_dim1], lda, &work[1]);
                }

                if (i < *m)
                {
                    i__1 = *m - i;
                    i__2 = i;
                    z__1.r = -tau[i__2].r;
                    z__1.i = -tau[i__2].i;

                    zscal(&i__1, &z__1, &a[i + 1 + i * a_dim1], &c__1);
                }

                i__1 = i + i * a_dim1;
                i__2 = i;

                z__1.r = 1.0 - tau[i__2].r;
                z__1.i = 0.0 - tau[i__2].i;

                a[i__1].r = z__1.r;
                a[i__1].i = z__1.i;

                // Set A(1:i-1,i) to zero 

                i__1 = i - 1;

                for (l = 1; l <= i__1; ++l)
                {
                    i__2 = l + i * a_dim1;

                    a[i__2].r = 0.0;
                    a[i__2].i = 0.0;
                }
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zungbr(string vect, int* m, int* n, int* k,
            complex16* a, int* lda, complex16* tau, complex16* work, int* lwork, int* info)
        {
            //  -- LAPACK routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     November 2006

            //  Purpose
            //  =======

            //  ZUNGBR generates one of the complex unitary matrices Q or P**H
            //  determined by ZGEBRD when reducing a complex matrix A to bidiagonal
            //  form: A = Q * B * P**H.  Q and P**H are defined as products of
            //  elementary reflectors H(i) or G(i) respectively.

            //  If VECT = 'Q', A is assumed to have been an M-by-K matrix, and Q
            //  is of order M:
            //  if m >= k, Q = H(1) H(2) . . . H(k) and ZUNGBR returns the first n
            //  columns of Q, where m >= n >= k;
            //  if m < k, Q = H(1) H(2) . . . H(m-1) and ZUNGBR returns Q as an
            //  M-by-M matrix.

            //  If VECT = 'P', A is assumed to have been a K-by-N matrix, and P**H
            //  is of order N:
            //  if k < n, P**H = G(k) . . . G(2) G(1) and ZUNGBR returns the first m
            //  rows of P**H, where n >= m >= k;
            //  if k >= n, P**H = G(n-1) . . . G(2) G(1) and ZUNGBR returns P**H as
            //  an N-by-N matrix.

            //  Arguments
            //  =========

            //  VECT    (input) CHARACTER*1
            //          Specifies whether the matrix Q or the matrix P**H is
            //          required, as defined in the transformation applied by ZGEBRD:
            //          = 'Q':  generate Q;
            //          = 'P':  generate P**H.

            //  M       (input) int
            //          The number of rows of the matrix Q or P**H to be returned.
            //          M >= 0.

            //  N       (input) int
            //          The number of columns of the matrix Q or P**H to be returned.
            //          N >= 0.
            //          If VECT = 'Q', M >= N >= min(M,K);
            //          if VECT = 'P', N >= M >= min(N,K).

            //  K       (input) int
            //          If VECT = 'Q', the number of columns in the original M-by-K
            //          matrix reduced by ZGEBRD.
            //          If VECT = 'P', the number of rows in the original K-by-N
            //          matrix reduced by ZGEBRD.
            //          K >= 0.

            //  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
            //          On entry, the vectors which define the elementary reflectors,
            //          as returned by ZGEBRD.
            //          On exit, the M-by-N matrix Q or P**H.

            //  LDA     (input) int
            //          The leading dimension of the array A. LDA >= M.

            //  TAU     (input) COMPLEX*16 array, dimension
            //                                (min(M,K)) if VECT = 'Q'
            //                                (min(N,K)) if VECT = 'P'
            //          TAU(i) must contain the scalar factor of the elementary
            //          reflector H(i) or G(i), which determines Q or P**H, as
            //          returned by ZGEBRD in its array argument TAUQ or TAUP.

            //  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))
            //          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

            //  LWORK   (input) int
            //          The dimension of the array WORK. LWORK >= max(1,min(M,N)).
            //          For optimum performance LWORK >= min(M,N)*NB, where NB
            //          is the optimal blocksize.

            //          If LWORK = -1, then a workspace query is assumed; the routine
            //          only calculates the optimal size of the WORK array, returns
            //          this value as the first entry of the WORK array, and no error
            //          message related to LWORK is issued by XERBLA.

            //  INFO    (output) int
            //          = 0:  successful exit
            //          < 0:  if INFO = -i, the i-th argument had an illegal value

            //  =====================================================================

            // System generated locals
            int a_dim1, a_offset, i__1, i__2, i__3;

            // Table of constant values
            int c__1 = 1;
            int c_n1 = -1;

            // Local variables
            int i__, j, nb, mn;
            int iinfo;
            bool wantq;
            int lwkopt = 0;
            bool lquery;

            // Parameter adjustments
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;
            --tau;
            --work;

            // Function Body
            *info = 0;
            wantq = lsame(vect, "Q");
            mn = Math.Min(*m, *n);
            lquery = *lwork == -1;

            if (!wantq && !lsame(vect, "P"))
            {
                *info = -1;
            }
            else if (*m < 0)
            {
                *info = -2;
            }
            else if (*n < 0 || wantq && (*n > *m || *n < Math.Min(*m, *k)) || !wantq && (
              *m > *n || *m < Math.Min(*n, *k)))
            {
                *info = -3;
            }
            else if (*k < 0)
            {
                *info = -4;
            }
            else if (*lda < Math.Max(1, *m))
            {
                *info = -6;
            }
            else if (*lwork < Math.Max(1, mn) && !lquery)
            {
                *info = -9;
            }

            if (*info == 0)
            {
                if (wantq)
                {
                    nb = ilaenv(&c__1, "ZUNGQR", " ", m, n, k, &c_n1);
                }
                else
                {
                    nb = ilaenv(&c__1, "ZUNGLQ", " ", m, n, k, &c_n1);
                }

                lwkopt = Math.Max(1, mn) * nb;
                work[1].r = (double)lwkopt;
                work[1].i = 0.0;
            }

            if (*info != 0)
            {
                i__1 = -(*info);
                xerbla("ZUNGBR", &i__1);
                return 0;
            }
            else if (lquery)
            {
                return 0;
            }

            // Quick return if possible

            if (*m == 0 || *n == 0)
            {
                work[1].r = 1.0;
                work[1].i = 0.0;
                return 0;
            }

            if (wantq)
            {
                // Form Q, determined by a call to ZGEBRD to reduce an m-by-k
                // matrix

                if (*m >= *k)
                {
                    // If m >= k, assume m >= n >= k

                    zungqr(m, n, k, &a[a_offset], lda, &tau[1], &work[1], lwork, &iinfo);
                }
                else
                {
                    // If m < k, assume m = n

                    // Shift the vectors which define the elementary reflectors one
                    // column to the right, and set the first row and column of Q
                    // to those of the unit matrix

                    for (j = *m; j >= 2; --j)
                    {
                        i__1 = j * a_dim1 + 1;
                        a[i__1].r = 0.0;
                        a[i__1].i = 0.0;
                        i__1 = *m;

                        for (i__ = j + 1; i__ <= i__1; ++i__)
                        {
                            i__2 = i__ + j * a_dim1;
                            i__3 = i__ + (j - 1) * a_dim1;

                            a[i__2].r = a[i__3].r;
                            a[i__2].i = a[i__3].i;
                        }
                    }

                    i__1 = a_dim1 + 1;
                    a[i__1].r = 1.0;
                    a[i__1].i = 0.0;
                    i__1 = *m;

                    for (i__ = 2; i__ <= i__1; ++i__)
                    {
                        i__2 = i__ + a_dim1;

                        a[i__2].r = 0.0;
                        a[i__2].i = 0.0;
                    }

                    if (*m > 1)
                    {
                        // Form Q(2:m,2:m)

                        i__1 = *m - 1;
                        i__2 = *m - 1;
                        i__3 = *m - 1;
                        zungqr(&i__1, &i__2, &i__3, &a[(a_dim1 << 1) + 2], lda, &tau[1], &work[1], lwork, &iinfo);
                    }
                }
            }
            else
            {
                // Form P', determined by a call to ZGEBRD to reduce a k-by-n
                // matrix

                if (*k < *n)
                {
                    // If k < n, assume k <= m <= n

                    zunglq(m, n, k, &a[a_offset], lda, &tau[1], &work[1], lwork, &iinfo);

                }
                else
                {
                    // If k >= n, assume m = n

                    // Shift the vectors which define the elementary reflectors one
                    // row downward, and set the first row and column of P' to
                    // those of the unit matrix

                    i__1 = a_dim1 + 1;
                    a[i__1].r = 1.0;
                    a[i__1].i = 0.0;
                    i__1 = *n;

                    for (i__ = 2; i__ <= i__1; ++i__)
                    {
                        i__2 = i__ + a_dim1;
                        a[i__2].r = 0.0;
                        a[i__2].i = 0.0;
                    }

                    i__1 = *n;
                    for (j = 2; j <= i__1; ++j)
                    {
                        for (i__ = j - 1; i__ >= 2; --i__)
                        {
                            i__2 = i__ + j * a_dim1;
                            i__3 = i__ - 1 + j * a_dim1;
                            a[i__2].r = a[i__3].r;
                            a[i__2].i = a[i__3].i;
                        }
                        i__2 = j * a_dim1 + 1;
                        a[i__2].r = 0.0;
                        a[i__2].i = 0.0;
                    }

                    if (*n > 1)
                    {
                        // Form P'(2:n,2:n)

                        i__1 = *n - 1;
                        i__2 = *n - 1;
                        i__3 = *n - 1;
                        zunglq(&i__1, &i__2, &i__3, &a[(a_dim1 << 1) + 2], lda, &tau[1], &work[1], lwork, &iinfo);
                    }
                }
            }

            work[1].r = (double)lwkopt;
            work[1].i = 0.0;

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zunghr(int* n, int* ilo, int* ihi,
            complex16* a, int* lda, complex16* tau, complex16*
            work, int* lwork, int* info)
        {
            //  -- LAPACK routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. 
            //     November 2006 

            //  Purpose 
            //  ======= 

            //  ZUNGHR generates a complex unitary matrix Q which is defined as the 
            //  product of IHI-ILO elementary reflectors of order N, as returned by 
            //  ZGEHRD: 

            //  Q = H(ilo) H(ilo+1) . . . H(ihi-1). 

            //  Arguments 
            //  ========= 

            //  N       (input) int 
            //          The order of the matrix Q. N >= 0. 

            //  ILO     (input) int 
            //  IHI     (input) int 
            //          ILO and IHI must have the same values as in the previous call 
            //          of ZGEHRD. Q is equal to the unit matrix except in the 
            //          submatrix Q(ilo+1:ihi,ilo+1:ihi). 
            //          1 <= ILO <= IHI <= N, if N > 0; ILO=1 and IHI=0, if N=0. 

            //  A       (input/output) COMPLEX*16 array, dimension (LDA,N) 
            //          On entry, the vectors which define the elementary reflectors, 
            //          as returned by ZGEHRD. 
            //          On exit, the N-by-N unitary matrix Q. 

            //  LDA     (input) int 
            //          The leading dimension of the array A. LDA >= max(1,N). 

            //  TAU     (input) COMPLEX*16 array, dimension (N-1) 
            //          TAU(i) must contain the scalar factor of the elementary 
            //          reflector H(i), as returned by ZGEHRD. 

            //  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK)) 
            //          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. 

            //  LWORK   (input) int 
            //          The dimension of the array WORK. LWORK >= IHI-ILO. 
            //          For optimum performance LWORK >= (IHI-ILO)*NB, where NB is 
            //          the optimal blocksize. 

            //          If LWORK = -1, then a workspace query is assumed; the routine 
            //          only calculates the optimal size of the WORK array, returns 
            //          this value as the first entry of the WORK array, and no error 
            //          message related to LWORK is issued by XERBLA. 

            //  INFO    (output) int 
            //          = 0:  successful exit 
            //          < 0:  if INFO = -i, the i-th argument had an illegal value 

            //  ===================================================================== 

            // System generated locals 
            int a_dim1, a_offset, i__1, i__2, i__3, i__4;

            // Table of constant values
            int c__1 = 1;
            int c_n1 = -1;

            // Local variables 
            int i, j, nb, nh, iinfo;
            int lwkopt = 0;
            bool lquery;

            // Parameter adjustments 
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;
            --tau;
            --work;

            // Function Body 
            *info = 0;
            nh = *ihi - *ilo;
            lquery = *lwork == -1;

            if (*n < 0)
            {
                *info = -1;
            }
            else if (*ilo < 1 || *ilo > Math.Max(1, *n))
            {
                *info = -2;
            }
            else if (*ihi < Math.Min(*ilo, *n) || *ihi > *n)
            {
                *info = -3;
            }
            else if (*lda < Math.Max(1, *n))
            {
                *info = -5;
            }
            else if (*lwork < Math.Max(1, nh) && !lquery)
            {
                *info = -8;
            }

            if (*info == 0)
            {
                nb = ilaenv(&c__1, "ZUNGQR", " ", &nh, &nh, &nh, &c_n1);
                lwkopt = Math.Max(1, nh) * nb;
                work[1].r = (double)lwkopt;
                work[1].i = 0.0;
            }

            if (*info != 0)
            {
                i__1 = -(*info);
                xerbla("ZUNGHR", &i__1);
                return 0;
            }
            else if (lquery)
            {
                return 0;
            }

            // Quick return if possible 

            if (*n == 0)
            {
                work[1].r = 1.0;
                work[1].i = 0.0;
                return 0;
            }

            // Shift the vectors which define the elementary reflectors one 
            // column to the right, and set the first ilo and the last n-ihi 
            // rows and columns to those of the unit matrix 

            i__1 = *ilo + 1;

            for (j = *ihi; j >= i__1; --j)
            {
                i__2 = j - 1;

                for (i = 1; i <= i__2; ++i)
                {
                    i__3 = i + j * a_dim1;
                    a[i__3].r = 0.0;
                    a[i__3].i = 0.0;
                }

                i__2 = *ihi;

                for (i = j + 1; i <= i__2; ++i)
                {
                    i__3 = i + j * a_dim1;
                    i__4 = i + (j - 1) * a_dim1;

                    a[i__3].r = a[i__4].r;
                    a[i__3].i = a[i__4].i;
                }

                i__2 = *n;

                for (i = *ihi + 1; i <= i__2; ++i)
                {
                    i__3 = i + j * a_dim1;

                    a[i__3].r = 0.0;
                    a[i__3].i = 0.0;
                }
            }

            i__1 = *ilo;

            for (j = 1; j <= i__1; ++j)
            {
                i__2 = *n;

                for (i = 1; i <= i__2; ++i)
                {
                    i__3 = i + j * a_dim1;

                    a[i__3].r = 0.0;
                    a[i__3].i = 0.0;
                }

                i__2 = j + j * a_dim1;

                a[i__2].r = 1.0;
                a[i__2].i = 0.0;
            }
            i__1 = *n;

            for (j = *ihi + 1; j <= i__1; ++j)
            {
                i__2 = *n;

                for (i = 1; i <= i__2; ++i)
                {
                    i__3 = i + j * a_dim1;

                    a[i__3].r = 0.0;
                    a[i__3].i = 0.0;
                }

                i__2 = j + j * a_dim1;

                a[i__2].r = 1.0;
                a[i__2].i = 0.0;
            }

            if (nh > 0)
            {
                // Generate Q(ilo+1:ihi,ilo+1:ihi) 
                zungqr(&nh, &nh, &nh, &a[*ilo + 1 + (*ilo + 1) * a_dim1], lda, &tau[*ilo], &work[1], lwork, &iinfo);
            }

            work[1].r = (double)lwkopt;
            work[1].i = 0.0;

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zungl2(int* m, int* n, int* k,
            complex16* a, int* lda, complex16* tau, complex16* work, int* info)
        {
            //  -- LAPACK routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     November 2006

            //  Purpose
            //  =======

            //  ZUNGL2 generates an m-by-n complex matrix Q with orthonormal rows,
            //  which is defined as the first m rows of a product of k elementary
            //  reflectors of order n

            //        Q  =  H(k)' . . . H(2)' H(1)'

            //  as returned by ZGELQF.

            //  Arguments
            //  =========

            //  M       (input) int
            //          The number of rows of the matrix Q. M >= 0.

            //  N       (input) int
            //          The number of columns of the matrix Q. N >= M.

            //  K       (input) int
            //          The number of elementary reflectors whose product defines the
            //          matrix Q. M >= K >= 0.

            //  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
            //          On entry, the i-th row must contain the vector which defines
            //          the elementary reflector H(i), for i = 1,2,...,k, as returned
            //          by ZGELQF in the first k rows of its array argument A.
            //          On exit, the m by n matrix Q.

            //  LDA     (input) int
            //          The first dimension of the array A. LDA >= max(1,M).

            //  TAU     (input) COMPLEX*16 array, dimension (K)
            //          TAU(i) must contain the scalar factor of the elementary
            //          reflector H(i), as returned by ZGELQF.

            //  WORK    (workspace) COMPLEX*16 array, dimension (M)

            //  INFO    (output) int
            //          = 0: successful exit
            //          < 0: if INFO = -i, the i-th argument has an illegal value

            //  =====================================================================

            // System generated locals
            int a_dim1, a_offset, i__1, i__2, i__3;
            complex16 z__1, z__2;

            // Local variables
            int i, j, l;

            // Parameter adjustments
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;
            --tau;
            --work;

            // Function Body
            *info = 0;
            if (*m < 0)
            {
                *info = -1;
            }
            else if (*n < *m)
            {
                *info = -2;
            }
            else if (*k < 0 || *k > *m)
            {
                *info = -3;
            }
            else if (*lda < Math.Max(1, *m))
            {
                *info = -5;
            }

            if (*info != 0)
            {
                i__1 = -(*info);
                xerbla("ZUNGL2", &i__1);
                return 0;
            }

            // Quick return if possible

            if (*m <= 0)
            {
                return 0;
            }

            if (*k < *m)
            {
                // Initialise rows k+1:m to rows of the unit matrix

                i__1 = *n;
                for (j = 1; j <= i__1; ++j)
                {
                    i__2 = *m;
                    for (l = *k + 1; l <= i__2; ++l)
                    {
                        i__3 = l + j * a_dim1;
                        a[i__3].r = 0.0;
                        a[i__3].i = 0.0;
                    }
                    if (j > *k && j <= *m)
                    {
                        i__2 = j + j * a_dim1;
                        a[i__2].r = 1.0;
                        a[i__2].i = 0.0;
                    }
                }
            }

            for (i = *k; i >= 1; --i)
            {
                // Apply H(i)' to A(i:m,i:n) from the right

                if (i < *n)
                {
                    i__1 = *n - i;
                    zlacgv(&i__1, &a[i + (i + 1) * a_dim1], lda);
                    if (i < *m)
                    {
                        i__1 = i + i * a_dim1;

                        a[i__1].r = 1.0;
                        a[i__1].i = 0.0;

                        i__1 = *m - i;
                        i__2 = *n - i + 1;
                        d_cnjg(&z__1, &tau[i]);
                        zlarf("Right", &i__1, &i__2, &a[i + i * a_dim1], lda,
                        &z__1, &a[i + 1 + i * a_dim1], lda, &work[1]);
                    }
                    i__1 = *n - i;
                    i__2 = i;

                    z__1.r = -tau[i__2].r;
                    z__1.i = -tau[i__2].i;

                    zscal(&i__1, &z__1, &a[i + (i + 1) * a_dim1], lda);
                    i__1 = *n - i;
                    zlacgv(&i__1, &a[i + (i + 1) * a_dim1], lda);
                }
                i__1 = i + i * a_dim1;
                d_cnjg(&z__2, &tau[i]);

                z__1.r = 1.0 - z__2.r;
                z__1.i = 0.0 - z__2.i;

                a[i__1].r = z__1.r;
                a[i__1].i = z__1.i;

                // Set A(i,1:i-1) to zero

                i__1 = i - 1;
                for (l = 1; l <= i__1; ++l)
                {
                    i__2 = i + l * a_dim1;
                    a[i__2].r = 0.0;
                    a[i__2].i = 0.0;
                }
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zunglq(int* m, int* n, int* k, complex16* a,
            int* lda, complex16* tau, complex16* work, int* lwork, int* info)
        {
            //  -- LAPACK routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     November 2006

            //  Purpose
            //  =======

            //  ZUNGLQ generates an M-by-N complex matrix Q with orthonormal rows,
            //  which is defined as the first M rows of a product of K elementary
            //  reflectors of order N

            //        Q  =  H(k)' . . . H(2)' H(1)'

            //  as returned by ZGELQF.

            //  Arguments
            //  =========

            //  M       (input) int
            //          The number of rows of the matrix Q. M >= 0.

            //  N       (input) int
            //          The number of columns of the matrix Q. N >= M.

            //  K       (input) int
            //          The number of elementary reflectors whose product defines the
            //          matrix Q. M >= K >= 0.

            //  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
            //          On entry, the i-th row must contain the vector which defines
            //          the elementary reflector H(i), for i = 1,2,...,k, as returned
            //          by ZGELQF in the first k rows of its array argument A.
            //          On exit, the M-by-N matrix Q.

            //  LDA     (input) int
            //          The first dimension of the array A. LDA >= max(1,M).

            //  TAU     (input) COMPLEX*16 array, dimension (K)
            //          TAU(i) must contain the scalar factor of the elementary
            //          reflector H(i), as returned by ZGELQF.

            //  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))
            //          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

            //  LWORK   (input) int
            //          The dimension of the array WORK. LWORK >= max(1,M).
            //          For optimum performance LWORK >= M*NB, where NB is
            //          the optimal blocksize.

            //          If LWORK = -1, then a workspace query is assumed; the routine
            //          only calculates the optimal size of the WORK array, returns
            //          this value as the first entry of the WORK array, and no error
            //          message related to LWORK is issued by XERBLA.

            //  INFO    (output) int
            //          = 0:  successful exit;
            //          < 0:  if INFO = -i, the i-th argument has an illegal value

            //  =====================================================================

            // System generated locals
            int a_dim1, a_offset, i__1, i__2, i__3, i__4;

            // Table of constant values
            int c__1 = 1;
            int c_n1 = -1;
            int c__3 = 3;
            int c__2 = 2;

            // Local variables
            int i, j, l, ib, nb, ki = 0, kk, nx, iws, nbmin, iinfo;
            int ldwork;
            bool lquery;
            int lwkopt;

            // Parameter adjustments
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;
            --tau;
            --work;

            // Function Body
            *info = 0;
            nb = ilaenv(&c__1, "ZUNGLQ", " ", m, n, k, &c_n1);
            lwkopt = Math.Max(1, *m) * nb;
            work[1].r = (double)lwkopt;
            work[1].i = 0.0;
            lquery = *lwork == -1;

            if (*m < 0)
            {
                *info = -1;
            }
            else if (*n < *m)
            {
                *info = -2;
            }
            else if (*k < 0 || *k > *m)
            {
                *info = -3;
            }
            else if (*lda < Math.Max(1, *m))
            {
                *info = -5;
            }
            else if (*lwork < Math.Max(1, *m) && !lquery)
            {
                *info = -8;
            }

            if (*info != 0)
            {
                i__1 = -(*info);
                xerbla("ZUNGLQ", &i__1);
                return 0;
            }
            else if (lquery)
            {
                return 0;
            }

            // Quick return if possible

            if (*m <= 0)
            {
                work[1].r = 1.0;
                work[1].i = 0.0;
                return 0;
            }

            nbmin = 2;
            nx = 0;
            iws = *m;
            if (nb > 1 && nb < *k)
            {
                // Determine when to cross over from blocked to unblocked code.

                // Computing MAX
                i__1 = 0;
                i__2 = ilaenv(&c__3, "ZUNGLQ", " ", m, n, k, &c_n1);
                nx = Math.Max(i__1, i__2);
                if (nx < *k)
                {
                    // Determine if workspace is large enough for blocked code.

                    ldwork = *m;
                    iws = ldwork * nb;
                    if (*lwork < iws)
                    {
                        // Not enough workspace to use optimal NB:  reduce NB and
                        // determine the minimum value of NB.

                        nb = *lwork / ldwork;
                        // Computing MAX
                        i__1 = 2;
                        i__2 = ilaenv(&c__2, "ZUNGLQ", " ", m, n, k, &c_n1);
                        nbmin = Math.Max(i__1, i__2);
                    }
                }
            }

            if (nb >= nbmin && nb < *k && nx < *k)
            {
                // Use blocked code after the last block.
                // The first kk rows are handled by the block method.

                ki = (*k - nx - 1) / nb * nb;
                // Computing MIN
                i__1 = *k;
                i__2 = ki + nb;
                kk = Math.Min(i__1, i__2);

                // Set A(kk+1:m,1:kk) to zero.

                i__1 = kk;
                for (j = 1; j <= i__1; ++j)
                {
                    i__2 = *m;
                    for (i = kk + 1; i <= i__2; ++i)
                    {
                        i__3 = i + j * a_dim1;
                        a[i__3].r = 0.0;
                        a[i__3].i = 0.0;
                    }
                }
            }
            else
            {
                kk = 0;
            }

            // Use unblocked code for the last or only block.

            if (kk < *m)
            {
                i__1 = *m - kk;
                i__2 = *n - kk;
                i__3 = *k - kk;
                zungl2(&i__1, &i__2, &i__3, &a[kk + 1 + (kk + 1) * a_dim1], lda, &tau[kk + 1], &work[1], &iinfo);
            }

            if (kk > 0)
            {
                // Use blocked code

                i__1 = -nb;
                for (i = ki + 1; i__1 < 0 ? i >= 1 : i <= 1; i += i__1)
                {
                    // Computing MIN
                    i__2 = nb;
                    i__3 = *k - i + 1;
                    ib = Math.Min(i__2, i__3);
                    if (i + ib <= *m)
                    {
                        // Form the triangular factor of the block reflector
                        // H = H(i) H(i+1) . . . H(i+ib-1)

                        i__2 = *n - i + 1;
                        zlarft("Forward", "Rowwise", &i__2, &ib, &a[i + i * a_dim1], lda, &tau[i], &work[1], &ldwork);

                        // Apply H' to A(i+ib:m,i:n) from the right

                        i__2 = *m - i - ib + 1;
                        i__3 = *n - i + 1;
                        zlarfb("Right", "Conjugate transpose", "Forward", "Rowwise",
                            &i__2, &i__3, &ib, &a[i + i * a_dim1], lda, &work[1], &ldwork,
                            &a[i + ib + i * a_dim1], lda, &work[ib + 1], &ldwork);
                    }

                    // Apply H' to columns i:n of current block

                    i__2 = *n - i + 1;
                    zungl2(&ib, &i__2, &ib, &a[i + i * a_dim1], lda, &tau[i], &work[1], &iinfo);

                    // Set columns 1:i-1 of current block to zero

                    i__2 = i - 1;
                    for (j = 1; j <= i__2; ++j)
                    {
                        i__3 = i + ib - 1;
                        for (l = i; l <= i__3; ++l)
                        {
                            i__4 = l + j * a_dim1;
                            a[i__4].r = 0.0;
                            a[i__4].i = 0.0;
                        }
                    }
                }
            }

            work[1].r = (double)iws;
            work[1].i = 0.0;

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zungqr(int* m, int* n, int* k, complex16* a,
            int* lda, complex16* tau, complex16* work, int* lwork, int* info)
        {
            //  -- LAPACK routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. 
            //     November 2006 

            //  Purpose 
            //  ======= 

            //  ZUNGQR generates an M-by-N complex matrix Q with orthonormal columns, 
            //  which is defined as the first N columns of a product of K elementary 
            //  reflectors of order M 

            //        Q  =  H(1) H(2) . . . H(k) 

            //  as returned by ZGEQRF. 

            //  Arguments 
            //  ========= 

            //  M       (input) int 
            //          The number of rows of the matrix Q. M >= 0. 

            //  N       (input) int 
            //          The number of columns of the matrix Q. M >= N >= 0. 

            //  K       (input) int 
            //          The number of elementary reflectors whose product defines the 
            //          matrix Q. N >= K >= 0. 

            //  A       (input/output) COMPLEX*16 array, dimension (LDA,N) 
            //          On entry, the i-th column must contain the vector which 
            //          defines the elementary reflector H(i), for i = 1,2,...,k, as 
            //          returned by ZGEQRF in the first k columns of its array 
            //          argument A. 
            //          On exit, the M-by-N matrix Q. 

            //  LDA     (input) int 
            //          The first dimension of the array A. LDA >= max(1,M). 

            //  TAU     (input) COMPLEX*16 array, dimension (K) 
            //          TAU(i) must contain the scalar factor of the elementary 
            //          reflector H(i), as returned by ZGEQRF. 

            //  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK)) 
            //          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. 

            //  LWORK   (input) int 
            //          The dimension of the array WORK. LWORK >= max(1,N). 
            //          For optimum performance LWORK >= N*NB, where NB is the 
            //          optimal blocksize. 

            //          If LWORK = -1, then a workspace query is assumed; the routine 
            //          only calculates the optimal size of the WORK array, returns 
            //          this value as the first entry of the WORK array, and no error 
            //          message related to LWORK is issued by XERBLA. 

            //  INFO    (output) int 
            //          = 0:  successful exit 
            //          < 0:  if INFO = -i, the i-th argument has an illegal value 

            //  ===================================================================== 

            // System generated locals 
            int a_dim1, a_offset, i__1, i__2, i__3, i__4;

            // Table of constant values
            int c__1 = 1;
            int c_n1 = -1;
            int c__3 = 3;
            int c__2 = 2;

            // Local variables 
            int i, j, l, ib, nb, ki = 0, kk, nx, iws, nbmin, iinfo;

            int ldwork;
            int lwkopt;
            bool lquery;

            // Parameter adjustments 
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;
            --tau;
            --work;

            // Function Body 
            *info = 0;
            nb = ilaenv(&c__1, "ZUNGQR", " ", m, n, k, &c_n1);
            lwkopt = Math.Max(1, *n) * nb;

            work[1].r = (double)lwkopt;
            work[1].i = 0.0;

            lquery = *lwork == -1;

            if (*m < 0)
            {
                *info = -1;
            }
            else if (*n < 0 || *n > *m)
            {
                *info = -2;
            }
            else if (*k < 0 || *k > *n)
            {
                *info = -3;
            }
            else if (*lda < Math.Max(1, *m))
            {
                *info = -5;
            }
            else if (*lwork < Math.Max(1, *n) && !lquery)
            {
                *info = -8;
            }

            if (*info != 0)
            {
                i__1 = -(*info);
                xerbla("ZUNGQR", &i__1);
                return 0;
            }
            else if (lquery)
            {
                return 0;
            }

            // Quick return if possible 

            if (*n <= 0)
            {
                work[1].r = 1.0;
                work[1].i = 0.0;
                return 0;
            }

            nbmin = 2;
            nx = 0;
            iws = *n;
            if (nb > 1 && nb < *k)
            {
                // Determine when to cross over from blocked to unblocked code. 

                // Computing MAX 
                i__1 = 0;
                i__2 = ilaenv(&c__3, "ZUNGQR", " ", m, n, k, &c_n1);
                nx = Math.Max(i__1, i__2);

                if (nx < *k)
                {
                    // Determine if workspace is large enough for blocked code. 

                    ldwork = *n;
                    iws = ldwork * nb;

                    if (*lwork < iws)
                    {
                        // Not enough workspace to use optimal NB:  reduce NB and 
                        // determine the minimum value of NB. 

                        nb = *lwork / ldwork;
                        // Computing MAX 
                        i__1 = 2;
                        i__2 = ilaenv(&c__2, "ZUNGQR", " ", m, n, k, &c_n1);
                        nbmin = Math.Max(i__1, i__2);
                    }
                }
            }

            if (nb >= nbmin && nb < *k && nx < *k)
            {
                // Use blocked code after the last block. 
                // The first kk columns are handled by the block method. 

                ki = (*k - nx - 1) / nb * nb;
                // Computing MIN 
                i__1 = *k;
                i__2 = ki + nb;
                kk = Math.Min(i__1, i__2);

                // Set A(1:kk,kk+1:n) to zero. 

                i__1 = *n;
                for (j = kk + 1; j <= i__1; ++j)
                {
                    i__2 = kk;
                    for (i = 1; i <= i__2; ++i)
                    {
                        i__3 = i + j * a_dim1;
                        a[i__3].r = 0.0;
                        a[i__3].i = 0.0;
                    }
                }
            }
            else
            {
                kk = 0;
            }

            // Use unblocked code for the last or only block. 

            if (kk < *n)
            {
                i__1 = *m - kk;
                i__2 = *n - kk;
                i__3 = *k - kk;

                zung2r(&i__1, &i__2, &i__3, &a[kk + 1 + (kk + 1) * a_dim1], lda, &tau[kk + 1], &work[1], &iinfo);
            }

            if (kk > 0)
            {
                // Use blocked code 

                i__1 = -nb;
                for (i = ki + 1; i__1 < 0 ? i >= 1 : i <= 1; i += i__1)
                {
                    // Computing MIN 
                    i__2 = nb;
                    i__3 = *k - i + 1;
                    ib = Math.Min(i__2, i__3);

                    if (i + ib <= *n)
                    {
                        // Form the triangular factor of the block reflector 
                        // H = H(i) H(i+1) . . . H(i+ib-1) 

                        i__2 = *m - i + 1;
                        zlarft("Forward", "Columnwise", &i__2, &ib, &a[i + i * a_dim1], lda, &tau[i], &work[1], &ldwork);

                        // Apply H to A(i:m,i+ib:n) from the left 

                        i__2 = *m - i + 1;
                        i__3 = *n - i - ib + 1;

                        zlarfb("Left", "No transpose", "Forward", "Columnwise", &
                            i__2, &i__3, &ib, &a[i + i * a_dim1], lda, &work[1],
                            &ldwork, &a[i + (i + ib) * a_dim1], lda, &work[ib + 1], &ldwork);
                    }

                    // Apply H to rows i:m of current block 

                    i__2 = *m - i + 1;
                    zung2r(&i__2, &ib, &ib, &a[i + i * a_dim1], lda, &tau[i], &work[1], &iinfo);

                    // Set rows 1:i-1 of current block to zero 

                    i__2 = i + ib - 1;
                    for (j = i; j <= i__2; ++j)
                    {
                        i__3 = i - 1;
                        for (l = 1; l <= i__3; ++l)
                        {
                            i__4 = l + j * a_dim1;
                            a[i__4].r = 0.0;
                            a[i__4].i = 0.0;
                        }
                    }
                }
            }

            work[1].r = (double)iws;
            work[1].i = 0.0;

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zunm2r(string side, string trans, int* m, int* n,
            int* k, complex16* a, int* lda, complex16* tau,
            complex16* c, int* ldc, complex16* work, int* info)
        {
            //  -- LAPACK routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. 
            //     November 2006 

            //  Purpose 
            //  ======= 

            //  ZUNM2R overwrites the general complex m-by-n matrix C with 

            //        Q * C  if SIDE = 'L' and TRANS = 'N', or 

            //        Q'* C  if SIDE = 'L' and TRANS = 'C', or 

            //        C * Q  if SIDE = 'R' and TRANS = 'N', or 

            //        C * Q' if SIDE = 'R' and TRANS = 'C', 

            //  where Q is a complex unitary matrix defined as the product of k 
            //  elementary reflectors 

            //        Q = H(1) H(2) . . . H(k) 

            //  as returned by ZGEQRF. Q is of order m if SIDE = 'L' and of order n 
            //  if SIDE = 'R'. 

            //  Arguments 
            //  ========= 

            //  SIDE    (input) CHARACTER*1 
            //          = 'L': apply Q or Q' from the Left 
            //          = 'R': apply Q or Q' from the Right 

            //  TRANS   (input) CHARACTER*1 
            //          = 'N': apply Q  (No transpose) 
            //          = 'C': apply Q' (Conjugate transpose) 

            //  M       (input) int 
            //          The number of rows of the matrix C. M >= 0. 

            //  N       (input) int 
            //          The number of columns of the matrix C. N >= 0. 

            //  K       (input) int 
            //          The number of elementary reflectors whose product defines 
            //          the matrix Q. 
            //          If SIDE = 'L', M >= K >= 0; 
            //          if SIDE = 'R', N >= K >= 0. 

            //  A       (input) COMPLEX*16 array, dimension (LDA,K) 
            //          The i-th column must contain the vector which defines the 
            //          elementary reflector H(i), for i = 1,2,...,k, as returned by 
            //          ZGEQRF in the first k columns of its array argument A. 
            //          A is modified by the routine but restored on exit. 

            //  LDA     (input) int 
            //          The leading dimension of the array A. 
            //          If SIDE = 'L', LDA >= max(1,M); 
            //          if SIDE = 'R', LDA >= max(1,N). 

            //  TAU     (input) COMPLEX*16 array, dimension (K) 
            //          TAU(i) must contain the scalar factor of the elementary 
            //          reflector H(i), as returned by ZGEQRF. 

            //  C       (input/output) COMPLEX*16 array, dimension (LDC,N) 
            //          On entry, the m-by-n matrix C. 
            //          On exit, C is overwritten by Q*C or Q'*C or C*Q' or C*Q. 

            //  LDC     (input) int 
            //          The leading dimension of the array C. LDC >= max(1,M). 

            //  WORK    (workspace) COMPLEX*16 array, dimension 
            //                                   (N) if SIDE = 'L', 
            //                                   (M) if SIDE = 'R' 

            //  INFO    (output) int 
            //          = 0: successful exit 
            //          < 0: if INFO = -i, the i-th argument had an illegal value 

            //  ===================================================================== 

            // System generated locals 
            int a_dim1, a_offset, c_dim1, c_offset, i__1, i__2, i__3;
            complex16 z__1;

            // Table of constant values
            int c__1 = 1;

            // Local variables 
            int i, i1, i2, i3, ic = 0, jc = 0, mi, ni, nq;
            complex16 aii;
            bool left;
            complex16 taui;
            bool notran;

            // Parameter adjustments 
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;
            --tau;
            c_dim1 = *ldc;
            c_offset = 1 + c_dim1;
            c -= c_offset;
            --work;

            // Function Body 
            *info = 0;
            left = lsame(side, "L");
            notran = lsame(trans, "N");

            // NQ is the order of Q 

            if (left)
            {
                nq = *m;
            }
            else
            {
                nq = *n;
            }

            if (!left && !lsame(side, "R"))
            {
                *info = -1;
            }
            else if (!notran && !lsame(trans, "C"))
            {
                *info = -2;
            }
            else if (*m < 0)
            {
                *info = -3;
            }
            else if (*n < 0)
            {
                *info = -4;
            }
            else if (*k < 0 || *k > nq)
            {
                *info = -5;
            }
            else if (*lda < Math.Max(1, nq))
            {
                *info = -7;
            }
            else if (*ldc < Math.Max(1, *m))
            {
                *info = -10;
            }

            if (*info != 0)
            {
                i__1 = -(*info);
                xerbla("ZUNM2R", &i__1);
                return 0;
            }

            // Quick return if possible 

            if (*m == 0 || *n == 0 || *k == 0)
            {
                return 0;
            }

            if (left && !notran || !left && notran)
            {
                i1 = 1;
                i2 = *k;
                i3 = 1;
            }
            else
            {
                i1 = *k;
                i2 = 1;
                i3 = -1;
            }

            if (left)
            {
                ni = *n;
                jc = 1;
            }
            else
            {
                mi = *m;
                ic = 1;
            }

            i__1 = i2;
            i__2 = i3;

            for (i = i1; i__2 < 0 ? i >= i__1 : i <= i__1; i += i__2)
            {
                if (left)
                {
                    // H(i) or H(i)' is applied to C(i:m,1:n) 
                    mi = *m - i + 1;
                    ic = i;
                }
                else
                {
                    // H(i) or H(i)' is applied to C(1:m,i:n) 
                    ni = *n - i + 1;
                    jc = i;
                }

                // Apply H(i) or H(i)' 

                if (notran)
                {
                    i__3 = i;
                    taui.r = tau[i__3].r;
                    taui.i = tau[i__3].i;
                }
                else
                {
                    d_cnjg(&z__1, &tau[i]);
                    taui.r = z__1.r;
                    taui.i = z__1.i;
                }

                i__3 = i + i * a_dim1;

                aii.r = a[i__3].r;
                aii.i = a[i__3].i;

                i__3 = i + i * a_dim1;

                a[i__3].r = 1.0;
                a[i__3].i = 0.0;

                zlarf(side, &mi, &ni, &a[i + i * a_dim1], &c__1, &taui, &c[ic + jc * c_dim1], ldc, &work[1]);

                i__3 = i + i * a_dim1;

                a[i__3].r = aii.r;
                a[i__3].i = aii.i;
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zunmbr(string vect, string side, string trans, int* m,
            int* n, int* k, complex16* a, int* lda, complex16* tau,
            complex16* c, int* ldc, complex16* work, int* lwork, int* info)
        {
            //  -- LAPACK routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     November 2006

            //  Purpose
            //  =======

            //  If VECT = 'Q', ZUNMBR overwrites the general complex M-by-N matrix C
            //  with
            //                  SIDE = 'L'     SIDE = 'R'
            //  TRANS = 'N':      Q * C          C * Q
            //  TRANS = 'C':      Q**H * C       C * Q**H

            //  If VECT = 'P', ZUNMBR overwrites the general complex M-by-N matrix C
            //  with
            //                  SIDE = 'L'     SIDE = 'R'
            //  TRANS = 'N':      P * C          C * P
            //  TRANS = 'C':      P**H * C       C * P**H

            //  Here Q and P**H are the unitary matrices determined by ZGEBRD when
            //  reducing a complex matrix A to bidiagonal form: A = Q * B * P**H. Q
            //  and P**H are defined as products of elementary reflectors H(i) and
            //  G(i) respectively.

            //  Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the
            //  order of the unitary matrix Q or P**H that is applied.

            //  If VECT = 'Q', A is assumed to have been an NQ-by-K matrix:
            //  if nq >= k, Q = H(1) H(2) . . . H(k);
            //  if nq < k, Q = H(1) H(2) . . . H(nq-1).

            //  If VECT = 'P', A is assumed to have been a K-by-NQ matrix:
            //  if k < nq, P = G(1) G(2) . . . G(k);
            //  if k >= nq, P = G(1) G(2) . . . G(nq-1).

            //  Arguments
            //  =========

            //  VECT    (input) CHARACTER*1
            //          = 'Q': apply Q or Q**H;
            //          = 'P': apply P or P**H.

            //  SIDE    (input) CHARACTER*1
            //          = 'L': apply Q, Q**H, P or P**H from the Left;
            //          = 'R': apply Q, Q**H, P or P**H from the Right.

            //  TRANS   (input) CHARACTER*1
            //          = 'N':  No transpose, apply Q or P;
            //          = 'C':  Conjugate transpose, apply Q**H or P**H.

            //  M       (input) int
            //          The number of rows of the matrix C. M >= 0.

            //  N       (input) int
            //          The number of columns of the matrix C. N >= 0.

            //  K       (input) int
            //          If VECT = 'Q', the number of columns in the original
            //          matrix reduced by ZGEBRD.
            //          If VECT = 'P', the number of rows in the original
            //          matrix reduced by ZGEBRD.
            //          K >= 0.

            //  A       (input) COMPLEX*16 array, dimension
            //                                (LDA,min(nq,K)) if VECT = 'Q'
            //                                (LDA,nq)        if VECT = 'P'
            //          The vectors which define the elementary reflectors H(i) and
            //          G(i), whose products determine the matrices Q and P, as
            //          returned by ZGEBRD.

            //  LDA     (input) int
            //          The leading dimension of the array A.
            //          If VECT = 'Q', LDA >= max(1,nq);
            //          if VECT = 'P', LDA >= max(1,min(nq,K)).

            //  TAU     (input) COMPLEX*16 array, dimension (min(nq,K))
            //          TAU(i) must contain the scalar factor of the elementary
            //          reflector H(i) or G(i) which determines Q or P, as returned
            //          by ZGEBRD in the array argument TAUQ or TAUP.

            //  C       (input/output) COMPLEX*16 array, dimension (LDC,N)
            //          On entry, the M-by-N matrix C.
            //          On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q
            //          or P*C or P**H*C or C*P or C*P**H.

            //  LDC     (input) int
            //          The leading dimension of the array C. LDC >= max(1,M).

            //  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))
            //          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

            //  LWORK   (input) int
            //          The dimension of the array WORK.
            //          If SIDE = 'L', LWORK >= max(1,N);
            //          if SIDE = 'R', LWORK >= max(1,M);
            //          if N = 0 or M = 0, LWORK >= 1.
            //          For optimum performance LWORK >= max(1,N*NB) if SIDE = 'L',
            //          and LWORK >= max(1,M*NB) if SIDE = 'R', where NB is the
            //          optimal blocksize. (NB = 0 if M = 0 or N = 0.)

            //          If LWORK = -1, then a workspace query is assumed; the routine
            //          only calculates the optimal size of the WORK array, returns
            //          this value as the first entry of the WORK array, and no error
            //          message related to LWORK is issued by XERBLA.

            //  INFO    (output) int
            //          = 0:  successful exit
            //          < 0:  if INFO = -i, the i-th argument had an illegal value

            //  =====================================================================

            // System generated locals
            int a_dim1, a_offset, c_dim1, c_offset, i__1, i__2;

            // Table of constant values
            int c__1 = 1;
            int c_n1 = -1;

            // Local variables
            int i1, i2, nb, mi, ni, nq, nw;
            bool left;
            int iinfo;
            bool notran, applyq;
            string transt;
            int lwkopt = 0;
            bool lquery;

            // Parameter adjustments
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;
            --tau;
            c_dim1 = *ldc;
            c_offset = 1 + c_dim1;
            c -= c_offset;
            --work;

            // Function Body
            *info = 0;
            applyq = lsame(vect, "Q");
            left = lsame(side, "L");
            notran = lsame(trans, "N");
            lquery = *lwork == -1;

            // NQ is the order of Q or P and NW is the minimum dimension of WORK

            if (left)
            {
                nq = *m;
                nw = *n;
            }
            else
            {
                nq = *n;
                nw = *m;
            }

            if (*m == 0 || *n == 0)
            {
                nw = 0;
            }

            if (!applyq && !lsame(vect, "P"))
            {
                *info = -1;
            }
            else if (!left && !lsame(side, "R"))
            {
                *info = -2;
            }
            else if (!notran && !lsame(trans, "C"))
            {
                *info = -3;
            }
            else if (*m < 0)
            {
                *info = -4;
            }
            else if (*n < 0)
            {
                *info = -5;
            }
            else if (*k < 0)
            {
                *info = -6;
            }
            else // if(complicated condition)
            {
                // Computing MAX
                i__1 = 1;
                i__2 = Math.Min(nq, *k);
                if (applyq && *lda < Math.Max(1, nq) || !applyq && *lda < Math.Max(i__1, i__2))
                {
                    *info = -8;
                }
                else if (*ldc < Math.Max(1, *m))
                {
                    *info = -11;
                }
                else if (*lwork < Math.Max(1, nw) && !lquery)
                {
                    *info = -13;
                }
            }

            if (*info == 0)
            {
                if (nw > 0)
                {
                    if (applyq)
                    {
                        if (left)
                        {
                            i__1 = *m - 1;
                            i__2 = *m - 1;
                            nb = ilaenv(&c__1, "ZUNMQR", side + trans, &i__1, n, &i__2, &c_n1);
                        }
                        else
                        {
                            i__1 = *n - 1;
                            i__2 = *n - 1;
                            nb = ilaenv(&c__1, "ZUNMQR", side + trans, m, &i__1, &i__2, &c_n1);
                        }
                    }
                    else
                    {
                        if (left)
                        {
                            i__1 = *m - 1;
                            i__2 = *m - 1;
                            nb = ilaenv(&c__1, "ZUNMLQ", side + trans, &i__1, n, &i__2, &c_n1);
                        }
                        else
                        {
                            i__1 = *n - 1;
                            i__2 = *n - 1;
                            nb = ilaenv(&c__1, "ZUNMLQ", side + trans, m, &i__1, &i__2, &c_n1);
                        }
                    }

                    // Computing MAX
                    i__1 = 1;
                    i__2 = nw * nb;
                    lwkopt = Math.Max(i__1, i__2);
                }
                else
                {
                    lwkopt = 1;
                }

                work[1].r = (double)lwkopt;
                work[1].i = 0.0;
            }

            if (*info != 0)
            {
                i__1 = -(*info);
                xerbla("ZUNMBR", &i__1);
                return 0;
            }
            else if (lquery)
            {
                return 0;
            }

            // Quick return if possible

            if (*m == 0 || *n == 0)
            {
                return 0;
            }

            if (applyq)
            {
                // Apply Q

                if (nq >= *k)
                {
                    // Q was determined by a call to ZGEBRD with nq >= k

                    zunmqr(side, trans, m, n, k, &a[a_offset], lda, &tau[1],
                        &c[c_offset], ldc, &work[1], lwork, &iinfo);
                }
                else if (nq > 1)
                {
                    // Q was determined by a call to ZGEBRD with nq < k

                    if (left)
                    {
                        mi = *m - 1;
                        ni = *n;
                        i1 = 2;
                        i2 = 1;
                    }
                    else
                    {
                        mi = *m;
                        ni = *n - 1;
                        i1 = 1;
                        i2 = 2;
                    }
                    i__1 = nq - 1;
                    zunmqr(side, trans, &mi, &ni, &i__1, &a[a_dim1 + 2], lda, &tau[1],
                        &c[i1 + i2 * c_dim1], ldc, &work[1], lwork, &iinfo);
                }
            }
            else
            {
                // Apply P

                if (notran)
                {
                    transt = "C";
                }
                else
                {
                    transt = "N";
                }
                if (nq > *k)
                {
                    // P was determined by a call to ZGEBRD with nq > k

                    zunmlq(side, transt, m, n, k, &a[a_offset], lda, &tau[1],
                        &c[c_offset], ldc, &work[1], lwork, &iinfo);
                }
                else if (nq > 1)
                {
                    // P was determined by a call to ZGEBRD with nq <= k

                    if (left)
                    {
                        mi = *m - 1;
                        ni = *n;
                        i1 = 2;
                        i2 = 1;
                    }
                    else
                    {
                        mi = *m;
                        ni = *n - 1;
                        i1 = 1;
                        i2 = 2;
                    }
                    i__1 = nq - 1;
                    zunmlq(side, transt, &mi, &ni, &i__1, &a[(a_dim1 << 1) + 1], lda,
                         &tau[1], &c[i1 + i2 * c_dim1], ldc, &work[1], lwork, &iinfo);
                }
            }

            work[1].r = (double)lwkopt;
            work[1].i = 0.0;

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zunmhr(string side, string trans, int* m, int* n,
            int* ilo, int* ihi, complex16* a, int* lda,
            complex16* tau, complex16* c, int* ldc, complex16*
            work, int* lwork, int* info)
        {
            //  -- LAPACK routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. 
            //     November 2006 

            //  Purpose 
            //  ======= 

            //  ZUNMHR overwrites the general complex M-by-N matrix C with 

            //                  SIDE = 'L'     SIDE = 'R' 
            //  TRANS = 'N':      Q * C          C * Q 
            //  TRANS = 'C':      Q**H * C       C * Q**H 

            //  where Q is a complex unitary matrix of order nq, with nq = m if 
            //  SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of 
            //  IHI-ILO elementary reflectors, as returned by ZGEHRD: 

            //  Q = H(ilo) H(ilo+1) . . . H(ihi-1). 

            //  Arguments 
            //  ========= 

            //  SIDE    (input) CHARACTER*1 
            //          = 'L': apply Q or Q**H from the Left; 
            //          = 'R': apply Q or Q**H from the Right. 

            //  TRANS   (input) CHARACTER*1 
            //          = 'N': apply Q  (No transpose) 
            //          = 'C': apply Q**H (Conjugate transpose) 

            //  M       (input) int 
            //          The number of rows of the matrix C. M >= 0. 

            //  N       (input) int 
            //          The number of columns of the matrix C. N >= 0. 

            //  ILO     (input) int 
            //  IHI     (input) int 
            //          ILO and IHI must have the same values as in the previous call 
            //          of ZGEHRD. Q is equal to the unit matrix except in the 
            //          submatrix Q(ilo+1:ihi,ilo+1:ihi). 
            //          If SIDE = 'L', then 1 <= ILO <= IHI <= M, if M > 0, and 
            //          ILO = 1 and IHI = 0, if M = 0; 
            //          if SIDE = 'R', then 1 <= ILO <= IHI <= N, if N > 0, and 
            //          ILO = 1 and IHI = 0, if N = 0. 

            //  A       (input) COMPLEX*16 array, dimension 
            //                               (LDA,M) if SIDE = 'L' 
            //                               (LDA,N) if SIDE = 'R' 
            //          The vectors which define the elementary reflectors, as 
            //          returned by ZGEHRD. 

            //  LDA     (input) int 
            //          The leading dimension of the array A. 
            //          LDA >= max(1,M) if SIDE = 'L'; LDA >= max(1,N) if SIDE = 'R'. 

            //  TAU     (input) COMPLEX*16 array, dimension 
            //                               (M-1) if SIDE = 'L' 
            //                               (N-1) if SIDE = 'R' 
            //          TAU(i) must contain the scalar factor of the elementary 
            //          reflector H(i), as returned by ZGEHRD. 

            //  C       (input/output) COMPLEX*16 array, dimension (LDC,N) 
            //          On entry, the M-by-N matrix C. 
            //          On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q. 

            //  LDC     (input) int 
            //          The leading dimension of the array C. LDC >= max(1,M). 

            //  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK)) 
            //          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. 

            //  LWORK   (input) int 
            //          The dimension of the array WORK. 
            //          If SIDE = 'L', LWORK >= max(1,N); 
            //          if SIDE = 'R', LWORK >= max(1,M). 
            //          For optimum performance LWORK >= N*NB if SIDE = 'L', and 
            //          LWORK >= M*NB if SIDE = 'R', where NB is the optimal 
            //          blocksize. 

            //          If LWORK = -1, then a workspace query is assumed; the routine 
            //          only calculates the optimal size of the WORK array, returns 
            //          this value as the first entry of the WORK array, and no error 
            //          message related to LWORK is issued by XERBLA. 

            //  INFO    (output) int 
            //          = 0:  successful exit 
            //          < 0:  if INFO = -i, the i-th argument had an illegal value 

            //  ===================================================================== 

            // System generated locals 
            int a_dim1, a_offset, c_dim1, c_offset, i__2;

            // Table of constant values
            int c__1 = 1;
            int c_n1 = -1;

            // Local variables 
            int i1, i2, nb, mi, nh, ni, nq, nw;
            bool left;
            int iinfo;
            int lwkopt = 0;
            bool lquery;

            // Parameter adjustments 
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;
            --tau;
            c_dim1 = *ldc;
            c_offset = 1 + c_dim1;
            c -= c_offset;
            --work;

            // Function Body 
            *info = 0;
            nh = *ihi - *ilo;
            left = lsame(side, "L");
            lquery = *lwork == -1;

            // NQ is the order of Q and NW is the minimum dimension of WORK 

            if (left)
            {
                nq = *m;
                nw = *n;
            }
            else
            {
                nq = *n;
                nw = *m;
            }

            if (!left && !lsame(side, "R"))
            {
                *info = -1;
            }
            else if (!lsame(trans, "N") && !lsame(trans, "C"))
            {
                *info = -2;
            }
            else if (*m < 0)
            {
                *info = -3;
            }
            else if (*n < 0)
            {
                *info = -4;
            }
            else if (*ilo < 1 || *ilo > Math.Max(1, nq))
            {
                *info = -5;
            }
            else if (*ihi < Math.Min(*ilo, nq) || *ihi > nq)
            {
                *info = -6;
            }
            else if (*lda < Math.Max(1, nq))
            {
                *info = -8;
            }
            else if (*ldc < Math.Max(1, *m))
            {
                *info = -11;
            }
            else if (*lwork < Math.Max(1, nw) && !lquery)
            {
                *info = -13;
            }

            if (*info == 0)
            {
                if (left)
                    nb = ilaenv(&c__1, "ZUNMQR", side + trans, &nh, n, &nh, &c_n1);
                else
                    nb = ilaenv(&c__1, "ZUNMQR", side + trans, m, &nh, &nh, &c_n1);

                lwkopt = Math.Max(1, nw) * nb;

                work[1].r = (double)lwkopt;
                work[1].i = 0.0;
            }

            if (*info != 0)
            {
                i__2 = -(*info);
                xerbla("ZUNMHR", &i__2);
                return 0;
            }
            else if (lquery)
            {
                return 0;
            }

            // Quick return if possible 

            if (*m == 0 || *n == 0 || nh == 0)
            {
                work[1].r = 1.0;
                work[1].i = 0.0;
                return 0;
            }

            if (left)
            {
                mi = nh;
                ni = *n;
                i1 = *ilo + 1;
                i2 = 1;
            }
            else
            {
                mi = *m;
                ni = nh;
                i1 = 1;
                i2 = *ilo + 1;
            }

            zunmqr(side, trans, &mi, &ni, &nh, &a[*ilo + 1 + *ilo * a_dim1], lda, &
                tau[*ilo], &c[i1 + i2 * c_dim1], ldc, &work[1], lwork, &iinfo);

            work[1].r = (double)lwkopt;
            work[1].i = 0.0;

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zunml2(string side, string trans, int* m, int* n, int* k,
            complex16* a, int* lda, complex16* tau, complex16* c, int* ldc, complex16* work, int* info)
        {
            //  -- LAPACK routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     November 2006

            //  Purpose
            //  =======

            //  ZUNML2 overwrites the general complex m-by-n matrix C with

            //        Q * C  if SIDE = 'L' and TRANS = 'N', or

            //        Q'* C  if SIDE = 'L' and TRANS = 'C', or

            //        C * Q  if SIDE = 'R' and TRANS = 'N', or

            //        C * Q' if SIDE = 'R' and TRANS = 'C',

            //  where Q is a complex unitary matrix defined as the product of k
            //  elementary reflectors

            //        Q = H(k)' . . . H(2)' H(1)'

            //  as returned by ZGELQF. Q is of order m if SIDE = 'L' and of order n
            //  if SIDE = 'R'.

            //  Arguments
            //  =========

            //  SIDE    (input) CHARACTER*1
            //          = 'L': apply Q or Q' from the Left
            //          = 'R': apply Q or Q' from the Right

            //  TRANS   (input) CHARACTER*1
            //          = 'N': apply Q  (No transpose)
            //          = 'C': apply Q' (Conjugate transpose)

            //  M       (input) int
            //          The number of rows of the matrix C. M >= 0.

            //  N       (input) int
            //          The number of columns of the matrix C. N >= 0.

            //  K       (input) int
            //          The number of elementary reflectors whose product defines
            //          the matrix Q.
            //          If SIDE = 'L', M >= K >= 0;
            //          if SIDE = 'R', N >= K >= 0.

            //  A       (input) COMPLEX*16 array, dimension
            //                               (LDA,M) if SIDE = 'L',
            //                               (LDA,N) if SIDE = 'R'
            //          The i-th row must contain the vector which defines the
            //          elementary reflector H(i), for i = 1,2,...,k, as returned by
            //          ZGELQF in the first k rows of its array argument A.
            //          A is modified by the routine but restored on exit.

            //  LDA     (input) int
            //          The leading dimension of the array A. LDA >= max(1,K).

            //  TAU     (input) COMPLEX*16 array, dimension (K)
            //          TAU(i) must contain the scalar factor of the elementary
            //          reflector H(i), as returned by ZGELQF.

            //  C       (input/output) COMPLEX*16 array, dimension (LDC,N)
            //          On entry, the m-by-n matrix C.
            //          On exit, C is overwritten by Q*C or Q'*C or C*Q' or C*Q.

            //  LDC     (input) int
            //          The leading dimension of the array C. LDC >= max(1,M).

            //  WORK    (workspace) COMPLEX*16 array, dimension
            //                                   (N) if SIDE = 'L',
            //                                   (M) if SIDE = 'R'

            //  INFO    (output) int
            //          = 0: successful exit
            //          < 0: if INFO = -i, the i-th argument had an illegal value

            //  =====================================================================

            // System generated locals
            int a_dim1, a_offset, c_dim1, c_offset, i__1, i__2, i__3;
            complex16 z__1;

            // Local variables
            int i, i1, i2, i3, ic = 0, jc = 0, mi, ni, nq;
            complex16 aii;
            bool left;
            complex16 taui;
            bool notran;

            // Parameter adjustments
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;
            --tau;
            c_dim1 = *ldc;
            c_offset = 1 + c_dim1;
            c -= c_offset;
            --work;

            // Function Body
            *info = 0;
            left = lsame(side, "L");
            notran = lsame(trans, "N");

            // NQ is the order of Q

            if (left)
            {
                nq = *m;
            }
            else
            {
                nq = *n;
            }
            if (!left && !lsame(side, "R"))
            {
                *info = -1;
            }
            else if (!notran && !lsame(trans, "C"))
            {
                *info = -2;
            }
            else if (*m < 0)
            {
                *info = -3;
            }
            else if (*n < 0)
            {
                *info = -4;
            }
            else if (*k < 0 || *k > nq)
            {
                *info = -5;
            }
            else if (*lda < Math.Max(1, *k))
            {
                *info = -7;
            }
            else if (*ldc < Math.Max(1, *m))
            {
                *info = -10;
            }

            if (*info != 0)
            {
                i__1 = -(*info);
                xerbla("ZUNML2", &i__1);
                return 0;
            }

            // Quick return if possible

            if (*m == 0 || *n == 0 || *k == 0)
            {
                return 0;
            }

            if (left && notran || !left && !notran)
            {
                i1 = 1;
                i2 = *k;
                i3 = 1;
            }
            else
            {
                i1 = *k;
                i2 = 1;
                i3 = -1;
            }

            if (left)
            {
                ni = *n;
                jc = 1;
            }
            else
            {
                mi = *m;
                ic = 1;
            }

            i__1 = i2;
            i__2 = i3;
            for (i = i1; i__2 < 0 ? i >= i__1 : i <= i__1; i += i__2)
            {
                if (left)
                {
                    // H(i) or H(i)' is applied to C(i:m,1:n)

                    mi = *m - i + 1;
                    ic = i;
                }
                else
                {
                    // H(i) or H(i)' is applied to C(1:m,i:n)

                    ni = *n - i + 1;
                    jc = i;
                }

                // Apply H(i) or H(i)'

                if (notran)
                {
                    d_cnjg(&z__1, &tau[i]);
                    taui.r = z__1.r;
                    taui.i = z__1.i;
                }
                else
                {
                    i__3 = i;
                    taui.r = tau[i__3].r;
                    taui.i = tau[i__3].i;
                }
                if (i < nq)
                {
                    i__3 = nq - i;
                    zlacgv(&i__3, &a[i + (i + 1) * a_dim1], lda);
                }

                i__3 = i + i * a_dim1;
                aii.r = a[i__3].r;
                aii.i = a[i__3].i;
                i__3 = i + i * a_dim1;

                a[i__3].r = 1.0;
                a[i__3].i = 0.0;

                zlarf(side, &mi, &ni, &a[i + i * a_dim1], lda, &taui, &c[ic + jc * c_dim1], ldc, &work[1]);
                i__3 = i + i * a_dim1;

                a[i__3].r = aii.r;
                a[i__3].i = aii.i;

                if (i < nq)
                {
                    i__3 = nq - i;
                    zlacgv(&i__3, &a[i + (i + 1) * a_dim1], lda);
                }
            }

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zunmlq(string side, string trans, int* m, int* n, int* k, complex16* a,
            int* lda, complex16* tau, complex16* c, int* ldc, complex16* work, int* lwork, int* info)
        {
            //  -- LAPACK routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     November 2006

            //  Purpose
            //  =======

            //  ZUNMLQ overwrites the general complex M-by-N matrix C with

            //                  SIDE = 'L'     SIDE = 'R'
            //  TRANS = 'N':      Q * C          C * Q
            //  TRANS = 'C':      Q**H * C       C * Q**H

            //  where Q is a complex unitary matrix defined as the product of k
            //  elementary reflectors

            //        Q = H(k)' . . . H(2)' H(1)'

            //  as returned by ZGELQF. Q is of order M if SIDE = 'L' and of order N
            //  if SIDE = 'R'.

            //  Arguments
            //  =========

            //  SIDE    (input) CHARACTER*1
            //          = 'L': apply Q or Q**H from the Left;
            //          = 'R': apply Q or Q**H from the Right.

            //  TRANS   (input) CHARACTER*1
            //          = 'N':  No transpose, apply Q;
            //          = 'C':  Conjugate transpose, apply Q**H.

            //  M       (input) int
            //          The number of rows of the matrix C. M >= 0.

            //  N       (input) int
            //          The number of columns of the matrix C. N >= 0.

            //  K       (input) int
            //          The number of elementary reflectors whose product defines
            //          the matrix Q.
            //          If SIDE = 'L', M >= K >= 0;
            //          if SIDE = 'R', N >= K >= 0.

            //  A       (input) COMPLEX*16 array, dimension
            //                               (LDA,M) if SIDE = 'L',
            //                               (LDA,N) if SIDE = 'R'
            //          The i-th row must contain the vector which defines the
            //          elementary reflector H(i), for i = 1,2,...,k, as returned by
            //          ZGELQF in the first k rows of its array argument A.
            //          A is modified by the routine but restored on exit.

            //  LDA     (input) int
            //          The leading dimension of the array A. LDA >= max(1,K).

            //  TAU     (input) COMPLEX*16 array, dimension (K)
            //          TAU(i) must contain the scalar factor of the elementary
            //          reflector H(i), as returned by ZGELQF.

            //  C       (input/output) COMPLEX*16 array, dimension (LDC,N)
            //          On entry, the M-by-N matrix C.
            //          On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.

            //  LDC     (input) int
            //          The leading dimension of the array C. LDC >= max(1,M).

            //  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))
            //          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

            //  LWORK   (input) int
            //          The dimension of the array WORK.
            //          If SIDE = 'L', LWORK >= max(1,N);
            //          if SIDE = 'R', LWORK >= max(1,M).
            //          For optimum performance LWORK >= N*NB if SIDE 'L', and
            //          LWORK >= M*NB if SIDE = 'R', where NB is the optimal
            //          blocksize.

            //          If LWORK = -1, then a workspace query is assumed; the routine
            //          only calculates the optimal size of the WORK array, returns
            //          this value as the first entry of the WORK array, and no error
            //          message related to LWORK is issued by XERBLA.

            //  INFO    (output) int
            //          = 0:  successful exit
            //          < 0:  if INFO = -i, the i-th argument had an illegal value

            //  =====================================================================

            // System generated locals
            int a_dim1, a_offset, c_dim1, c_offset, i__1, i__2, i__4, i__5;

            // Table of constant values
            int c__1 = 1;
            int c_n1 = -1;
            int c__2 = 2;
            int c__65 = 65;

            // Local variables
            int i;
            complex16[] t = new complex16[4160]; // was [65][64]
            int i1, i2, i3, ib, ic = 0, jc = 0, nb = 0, mi, ni, nq, nw, iws;
            bool left;
            int nbmin, iinfo;
            bool notran;
            int ldwork;
            string transt;
            int lwkopt = 0;
            bool lquery;

            // Parameter adjustments
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;
            --tau;
            c_dim1 = *ldc;
            c_offset = 1 + c_dim1;
            c -= c_offset;
            --work;

            // Function Body
            *info = 0;
            left = lsame(side, "L");
            notran = lsame(trans, "N");
            lquery = *lwork == -1;

            // NQ is the order of Q and NW is the minimum dimension of WORK

            if (left)
            {
                nq = *m;
                nw = *n;
            }
            else
            {
                nq = *n;
                nw = *m;
            }

            if (!left && !lsame(side, "R"))
            {
                *info = -1;
            }
            else if (!notran && !lsame(trans, "C"))
            {
                *info = -2;
            }
            else if (*m < 0)
            {
                *info = -3;
            }
            else if (*n < 0)
            {
                *info = -4;
            }
            else if (*k < 0 || *k > nq)
            {
                *info = -5;
            }
            else if (*lda < Math.Max(1, *k))
            {
                *info = -7;
            }
            else if (*ldc < Math.Max(1, *m))
            {
                *info = -10;
            }
            else if (*lwork < Math.Max(1, nw) && !lquery)
            {
                *info = -12;
            }

            if (*info == 0)
            {
                // Determine the block size.  NB may be at most NBMAX, where NBMAX
                // is used to define the local array T.

                i__1 = 64;
                i__2 = ilaenv(&c__1, "ZUNMLQ", side + trans, m, n, k, &c_n1);
                nb = Math.Min(i__1, i__2);
                lwkopt = Math.Max(1, nw) * nb;
                work[1].r = (double)lwkopt;
                work[1].i = 0.0;
            }

            if (*info != 0)
            {
                i__1 = -(*info);
                xerbla("ZUNMLQ", &i__1);
                return 0;
            }
            else if (lquery)
            {
                return 0;
            }

            // Quick return if possible

            if (*m == 0 || *n == 0 || *k == 0)
            {
                work[1].r = 1.0;
                work[1].i = 0.0;
                return 0;
            }

            nbmin = 2;
            ldwork = nw;
            if (nb > 1 && nb < *k)
            {
                iws = nw * nb;
                if (*lwork < iws)
                {
                    nb = *lwork / ldwork;

                    i__1 = 2;
                    i__2 = ilaenv(&c__2, "ZUNMLQ", side + trans, m, n, k, &c_n1);
                    nbmin = Math.Max(i__1, i__2);
                }
            }
            else
            {
                iws = nw;
            }

            if (nb < nbmin || nb >= *k)
            {
                // Use unblocked code

                zunml2(side, trans, m, n, k, &a[a_offset], lda, &tau[1], &c[c_offset], ldc, &work[1], &iinfo);
            }
            else
            {
                // Use blocked code

                if (left && notran || !left && !notran)
                {
                    i1 = 1;
                    i2 = *k;
                    i3 = nb;
                }
                else
                {
                    i1 = (*k - 1) / nb * nb + 1;
                    i2 = 1;
                    i3 = -nb;
                }

                if (left)
                {
                    ni = *n;
                    jc = 1;
                }
                else
                {
                    mi = *m;
                    ic = 1;
                }

                if (notran)
                {
                    transt = "C";
                }
                else
                {
                    transt = "N";
                }

                i__1 = i2;
                i__2 = i3;
                for (i = i1; i__2 < 0 ? i >= i__1 : i <= i__1; i += i__2)
                {
                    i__4 = nb;
                    i__5 = *k - i + 1;
                    ib = Math.Min(i__4, i__5);

                    // Form the triangular factor of the block reflector
                    // H = H(i) H(i+1) . . . H(i+ib-1)

                    i__4 = nq - i + 1;
                    zlarft("Forward", "Rowwise", &i__4, &ib, &a[i + i * a_dim1], lda, &tau[i], t, &c__65);
                    if (left)
                    {
                        // H or H' is applied to C(i:m,1:n)

                        mi = *m - i + 1;
                        ic = i;
                    }
                    else
                    {
                        // H or H' is applied to C(1:m,i:n)

                        ni = *n - i + 1;
                        jc = i;
                    }

                    // Apply H or H'

                    zlarfb(side, transt, "Forward", "Rowwise", &mi, &ni, &ib, &a[i + i * a_dim1],
                        lda, t, &c__65, &c[ic + jc * c_dim1], ldc, &work[1], &ldwork);
                }
            }

            work[1].r = (double)lwkopt;
            work[1].i = 0.0;

            return 0;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int zunmqr(string side, string trans, int* m, int* n,
            int* k, complex16* a, int* lda, complex16* tau,
            complex16* c, int* ldc, complex16* work, int* lwork, int* info)
        {
            //  -- LAPACK routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. 
            //     November 2006 

            //  Purpose 
            //  ======= 

            //  ZUNMQR overwrites the general complex M-by-N matrix C with 

            //                  SIDE = 'L'     SIDE = 'R' 
            //  TRANS = 'N':      Q * C          C * Q 
            //  TRANS = 'C':      Q**H * C       C * Q**H 

            //  where Q is a complex unitary matrix defined as the product of k 
            //  elementary reflectors 

            //        Q = H(1) H(2) . . . H(k) 

            //  as returned by ZGEQRF. Q is of order M if SIDE = 'L' and of order N 
            //  if SIDE = 'R'. 

            //  Arguments 
            //  ========= 

            //  SIDE    (input) CHARACTER*1 
            //          = 'L': apply Q or Q**H from the Left; 
            //          = 'R': apply Q or Q**H from the Right. 

            //  TRANS   (input) CHARACTER*1 
            //          = 'N':  No transpose, apply Q; 
            //          = 'C':  Conjugate transpose, apply Q**H. 

            //  M       (input) int 
            //          The number of rows of the matrix C. M >= 0. 

            //  N       (input) int 
            //          The number of columns of the matrix C. N >= 0. 

            //  K       (input) int 
            //          The number of elementary reflectors whose product defines 
            //          the matrix Q. 
            //          If SIDE = 'L', M >= K >= 0; 
            //          if SIDE = 'R', N >= K >= 0. 

            //  A       (input) COMPLEX*16 array, dimension (LDA,K) 
            //          The i-th column must contain the vector which defines the 
            //          elementary reflector H(i), for i = 1,2,...,k, as returned by 
            //          ZGEQRF in the first k columns of its array argument A. 
            //          A is modified by the routine but restored on exit. 

            //  LDA     (input) int 
            //          The leading dimension of the array A. 
            //          If SIDE = 'L', LDA >= max(1,M); 
            //          if SIDE = 'R', LDA >= max(1,N). 

            //  TAU     (input) COMPLEX*16 array, dimension (K) 
            //          TAU(i) must contain the scalar factor of the elementary 
            //          reflector H(i), as returned by ZGEQRF. 

            //  C       (input/output) COMPLEX*16 array, dimension (LDC,N) 
            //          On entry, the M-by-N matrix C. 
            //          On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q. 

            //  LDC     (input) int 
            //          The leading dimension of the array C. LDC >= max(1,M). 

            //  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK)) 
            //          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. 

            //  LWORK   (input) int 
            //          The dimension of the array WORK. 
            //          If SIDE = 'L', LWORK >= max(1,N); 
            //          if SIDE = 'R', LWORK >= max(1,M). 
            //          For optimum performance LWORK >= N*NB if SIDE = 'L', and 
            //          LWORK >= M*NB if SIDE = 'R', where NB is the optimal 
            //          blocksize. 

            //          If LWORK = -1, then a workspace query is assumed; the routine 
            //          only calculates the optimal size of the WORK array, returns 
            //          this value as the first entry of the WORK array, and no error 
            //          message related to LWORK is issued by XERBLA. 

            //  INFO    (output) int 
            //          = 0:  successful exit 
            //          < 0:  if INFO = -i, the i-th argument had an illegal value 

            //  ===================================================================== 

            // System generated locals 
            int a_dim1, a_offset, c_dim1, c_offset, i__1, i__2, i__4, i__5;

            // Table of constant values
            int c__1 = 1;
            int c_n1 = -1;
            int c__2 = 2;
            int c__65 = 65;

            // Local variables 
            int i;
            complex16[] t = new complex16[4160];	// was [65][64] 
            int i1, i2, i3, ib, ic = 0, jc = 0, nb = 0, mi, ni, nq, nw, iws;
            bool left;
            int nbmin, iinfo;
            bool notran;
            int ldwork;
            int lwkopt = 0;
            bool lquery;

            // Parameter adjustments 
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;
            --tau;
            c_dim1 = *ldc;
            c_offset = 1 + c_dim1;
            c -= c_offset;
            --work;

            // Function Body 
            *info = 0;
            left = lsame(side, "L");
            notran = lsame(trans, "N");
            lquery = *lwork == -1;

            // NQ is the order of Q and NW is the minimum dimension of WORK 

            if (left)
            {
                nq = *m;
                nw = *n;
            }
            else
            {
                nq = *n;
                nw = *m;
            }

            if (!left && !lsame(side, "R"))
            {
                *info = -1;
            }
            else if (!notran && !lsame(trans, "C"))
            {
                *info = -2;
            }
            else if (*m < 0)
            {
                *info = -3;
            }
            else if (*n < 0)
            {
                *info = -4;
            }
            else if (*k < 0 || *k > nq)
            {
                *info = -5;
            }
            else if (*lda < Math.Max(1, nq))
            {
                *info = -7;
            }
            else if (*ldc < Math.Max(1, *m))
            {
                *info = -10;
            }
            else if (*lwork < Math.Max(1, nw) && !lquery)
            {
                *info = -12;
            }

            if (*info == 0)
            {
                // Determine the block size.  NB may be at most NBMAX, where NBMAX 
                // is used to define the local array T. 

                i__1 = 64;
                i__2 = ilaenv(&c__1, "ZUNMQR", side + trans, m, n, k, &c_n1);

                nb = Math.Min(i__1, i__2);
                lwkopt = Math.Max(1, nw) * nb;

                work[1].r = (double)lwkopt;
                work[1].i = 0.0;
            }

            if (*info != 0)
            {
                i__1 = -(*info);
                xerbla("ZUNMQR", &i__1);
                return 0;
            }
            else if (lquery)
            {
                return 0;
            }

            // Quick return if possible 

            if (*m == 0 || *n == 0 || *k == 0)
            {
                work[1].r = 1.0;
                work[1].i = 0.0;
                return 0;
            }

            nbmin = 2;
            ldwork = nw;
            if (nb > 1 && nb < *k)
            {
                iws = nw * nb;
                if (*lwork < iws)
                {
                    nb = *lwork / ldwork;

                    i__1 = 2;
                    i__2 = ilaenv(&c__2, "ZUNMQR", side + trans, m, n, k, &c_n1);
                    nbmin = Math.Max(i__1, i__2);
                }
            }
            else
            {
                iws = nw;
            }

            if (nb < nbmin || nb >= *k)
            {
                // Use unblocked code 
                zunm2r(side, trans, m, n, k, &a[a_offset], lda, &tau[1], &c[c_offset], ldc, &work[1], &iinfo);
            }
            else
            {
                // Use blocked code 

                if (left && !notran || !left && notran)
                {
                    i1 = 1;
                    i2 = *k;
                    i3 = nb;
                }
                else
                {
                    i1 = (*k - 1) / nb * nb + 1;
                    i2 = 1;
                    i3 = -nb;
                }

                if (left)
                {
                    ni = *n;
                    jc = 1;
                }
                else
                {
                    mi = *m;
                    ic = 1;
                }

                i__1 = i2;
                i__2 = i3;

                for (i = i1; i__2 < 0 ? i >= i__1 : i <= i__1; i += i__2)
                {
                    // Computing MIN 
                    i__4 = nb;
                    i__5 = *k - i + 1;
                    ib = Math.Min(i__4, i__5);

                    // Form the triangular factor of the block reflector 
                    // H = H(i) H(i+1) . . . H(i+ib-1) 

                    i__4 = nq - i + 1;
                    zlarft("Forward", "Columnwise", &i__4, &ib, &a[i + i * a_dim1], lda, &tau[i], t, &c__65);

                    if (left)
                    {
                        // H or H' is applied to C(i:m,1:n) 

                        mi = *m - i + 1;
                        ic = i;
                    }
                    else
                    {
                        // H or H' is applied to C(1:m,i:n) 

                        ni = *n - i + 1;
                        jc = i;
                    }

                    // Apply H or H' 

                    zlarfb(side, trans, "Forward", "Columnwise", &mi, &ni, &ib,
                        &a[i + i * a_dim1], lda, t, &c__65,
                        &c[ic + jc * c_dim1], ldc, &work[1], &ldwork);
                }
            }

            work[1].r = (double)lwkopt;
            work[1].i = 0.0;

            return 0;
        }

        #endregion

        #region Auxilary

        [SuppressUnmanagedCodeSecurity]
        public static int ilazlc(int* m, int* n, complex16* a, int* lda)
        {
            //  -- LAPACK auxiliary routine (version 3.2.1)                        -- 

            //  -- April 2009                                                      -- 

            //  -- LAPACK is a software package provided by Univ. of Tennessee,    -- 
            //  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- 

            //  Purpose 
            //  ======= 

            //  ILAZLC scans A for its last non-zero column. 

            //  Arguments 
            //  ========= 

            //  M       (input) int 
            //          The number of rows of the matrix A. 

            //  N       (input) int 
            //          The number of columns of the matrix A. 

            //  A       (input) COMPLEX*16 array, dimension (LDA,N) 
            //          The m by n matrix A. 

            //  LDA     (input) int 
            //          The leading dimension of the array A. LDA >= max(1,M). 

            //  ===================================================================== 

            // System generated locals 
            int a_dim1, a_offset, ret_val, i__1, i__2;

            // Local variables 
            int i;

            // Quick test for the common case where one corner is non-zero. 
            // Parameter adjustments 
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;

            // Function Body 
            if (*n == 0)
            {
                ret_val = *n;
            }
            else // if(complicated condition)
            {
                i__1 = *n * a_dim1 + 1;
                i__2 = *m + *n * a_dim1;

                if (a[i__1].r != 0.0 || a[i__1].i != 0.0 || (a[i__2].r != 0.0 || a[i__2].i != 0.0))
                {
                    ret_val = *n;
                }
                else
                {
                    // Now scan each column from the end, returning with the first non-zero. 
                    for (ret_val = *n; ret_val >= 1; --ret_val)
                    {
                        i__1 = *m;
                        for (i = 1; i <= i__1; ++i)
                        {
                            i__2 = i + ret_val * a_dim1;
                            if (a[i__2].r != 0.0 || a[i__2].i != 0.0)
                            {
                                return ret_val;
                            }
                        }
                    }
                }
            }

            return ret_val;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int ilazlr(int* m, int* n, complex16* a, int* lda)
        {
            //  -- LAPACK auxiliary routine (version 3.2.1)                        -- 

            //  -- April 2009                                                      -- 

            //  -- LAPACK is a software package provided by Univ. of Tennessee,    -- 
            //  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--  

            //  Purpose 
            //  ======= 

            //  ILAZLR scans A for its last non-zero row. 

            //  Arguments 
            //  ========= 

            //  M       (input) int 
            //          The number of rows of the matrix A. 

            //  N       (input) int 
            //          The number of columns of the matrix A. 

            //  A       (input) COMPLEX*16 array, dimension (LDA,N) 
            //          The m by n matrix A. 

            //  LDA     (input) int 
            //          The leading dimension of the array A. LDA >= max(1,M). 

            //  ===================================================================== 

            // System generated locals 
            int a_dim1, a_offset, ret_val, i__1, i__2;

            // Local variables 
            int i, j;

            // Quick test for the common case where one corner is non-zero. 
            // Parameter adjustments 
            a_dim1 = *lda;
            a_offset = 1 + a_dim1;
            a -= a_offset;

            // Function Body 
            if (*m == 0)
            {
                ret_val = *m;
            }
            else // if(complicated condition) 
            {
                i__1 = *m + a_dim1;
                i__2 = *m + *n * a_dim1;

                if (a[i__1].r != 0.0 || a[i__1].i != 0.0 || (a[i__2].r != 0.0 || a[i__2].i != 0.0))
                {
                    ret_val = *m;
                }
                else
                {
                    // Scan up each column tracking the last zero row seen. 
                    ret_val = 0;
                    i__1 = *n;
                    for (j = 1; j <= i__1; ++j)
                    {
                        for (i = *m; i >= 1; --i)
                        {
                            i__2 = i + j * a_dim1;
                            if (a[i__2].r != 0.0 || a[i__2].i != 0.0)
                            {
                                break;
                            }
                        }
                        ret_val = Math.Max(ret_val, i);
                    }
                }
            }

            return ret_val;
        }

        #endregion

        #endregion

        #region util

        public static double dlamch(string cmach)
        {
            //  -- LAPACK auxiliary routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     November 2006
            //
            //  Purpose
            //  =======
            //
            //  DLAMCH determines double precision machine parameters.
            //
            //  Arguments
            //  =========
            //
            //  CMACH   (input) CHARACTER*1
            //          Specifies the value to be returned by DLAMCH:
            //          = 'E' or 'e',   DLAMCH := eps
            //          = 'S' or 's ,   DLAMCH := sfmin
            //          = 'B' or 'b',   DLAMCH := base
            //          = 'P' or 'p',   DLAMCH := eps*base
            //          = 'N' or 'n',   DLAMCH := t
            //          = 'R' or 'r',   DLAMCH := rnd
            //          = 'M' or 'm',   DLAMCH := emin
            //          = 'U' or 'u',   DLAMCH := rmin
            //          = 'L' or 'l',   DLAMCH := emax
            //          = 'O' or 'o',   DLAMCH := rmax
            //
            //          where
            //
            //          eps   = relative machine precision
            //          sfmin = safe minimum, such that 1/sfmin does not overflow
            //          base  = base of the machine
            //          prec  = eps * base
            //          t     = number of (base) digits in the mantissa
            //          rnd   = 1.0 when rounding occurs in addition, 0.0 otherwise
            //          emin  = minimum exponent before (gradual) underflow
            //          rmin  = underflow threshold - base**(emin-1)
            //          emax  = largest exponent before overflow
            //          rmax  = overflow threshold  - (base**emax)*(1-eps)
            //
            // =====================================================================

            switch (Char.ToUpper(cmach[0]))
            {
                case 'E': return 1.1102230246251565E-016;
                case 'S': return 2.2250738585072014E-308;
                case 'B': return 2;
                case 'P': return 2.2204460492503131E-016;
                case 'N': return 53;
                case 'R': return 1;
                case 'M': return -1021;
                case 'U': return 2.2250738585072014E-308;
                case 'L': return 1024;
                case 'O': return 1.7976931348623157E+308;

                default:
                    throw new ArgumentException();
            }
        }

        [SuppressUnmanagedCodeSecurity]
        public static double dlamc3(double* a, double* b)
        {
            //  -- LAPACK auxiliary routine (version 3.2) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     November 2006

            //  Purpose
            //  =======

            //  DLAMC3  is intended to force  A  and  B  to be stored prior to doing
            //  the addition of  A  and  B ,  for use in situations where optimizers
            //  might hold one of these in a register.

            //  Arguments
            //  =========

            //  A       (input) DOUBLE PRECISION
            //  B       (input) DOUBLE PRECISION
            //          The values A and B.

            // =====================================================================

            return *a + *b;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int ieeeck(int* ispec, float* zero, float* one)
        {
            //  -- LAPACK auxiliary routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. 
            //     November 2006 

            //  Purpose 
            //  ======= 

            //  IEEECK is called from the ILAENV to verify that Infinity and 
            //  possibly NaN arithmetic is safe (i.e. will not trap). 

            //  Arguments 
            //  ========= 

            //  ISPEC   (input) int 
            //          Specifies whether to test just for inifinity arithmetic 
            //          or whether to test for infinity and NaN arithmetic. 
            //          = 0: Verify infinity arithmetic only. 
            //          = 1: Verify infinity and NaN arithmetic. 

            //  ZERO    (input) float 
            //          Must contain the value 0.0 
            //          This is passed to prevent the compiler from optimizing 
            //          away this code. 

            //  ONE     (input) float 
            //          Must contain the value 1.0 
            //          This is passed to prevent the compiler from optimizing 
            //          away this code. 

            //  RETURN VALUE:  int 
            //          = 0:  Arithmetic failed to produce the correct answers 
            //          = 1:  Arithmetic produced the correct answers 

            // System generated locals
            int ret_val;

            // Local variables
            float nan1, nan2, nan3, nan4, nan5, nan6, neginf, posinf, negzro, newzro;

            ret_val = 1;

            posinf = *one / *zero;
            if (posinf <= *one)
            {
                ret_val = 0;
                return ret_val;
            }

            neginf = -(*one) / *zero;
            if (neginf >= *zero)
            {
                ret_val = 0;
                return ret_val;
            }

            negzro = *one / (neginf + *one);
            if (negzro != *zero)
            {
                ret_val = 0;
                return ret_val;
            }

            neginf = *one / negzro;
            if (neginf >= *zero)
            {
                ret_val = 0;
                return ret_val;
            }

            newzro = negzro + *zero;
            if (newzro != *zero)
            {
                ret_val = 0;
                return ret_val;
            }

            posinf = *one / newzro;
            if (posinf <= *one)
            {
                ret_val = 0;
                return ret_val;
            }

            neginf *= posinf;
            if (neginf >= *zero)
            {
                ret_val = 0;
                return ret_val;
            }

            posinf *= posinf;
            if (posinf <= *one)
            {
                ret_val = 0;
                return ret_val;
            }

            // Return if we were only asked to check infinity arithmetic

            if (*ispec == 0)
            {
                return ret_val;
            }

            nan1 = posinf + neginf;
            nan2 = posinf / neginf;
            nan3 = posinf / posinf;
            nan4 = posinf * *zero;
            nan5 = neginf * negzro;
            nan6 = nan5 * 0.0f;

            if (!float.IsNaN(nan1))
            {
                ret_val = 0;
                return ret_val;
            }

            if (!float.IsNaN(nan2))
            {
                ret_val = 0;
                return ret_val;
            }

            if (!float.IsNaN(nan3))
            {
                ret_val = 0;
                return ret_val;
            }

            if (!float.IsNaN(nan4))
            {
                ret_val = 0;
                return ret_val;
            }

            if (!float.IsNaN(nan5))
            {
                ret_val = 0;
                return ret_val;
            }

            if (!float.IsNaN(nan6))
            {
                ret_val = 0;
                return ret_val;
            }

            return ret_val;
        }

        [SuppressUnmanagedCodeSecurity]
        private static int ilaenv(int* ispec, string name, string opts, int* n1, int* n2, int* n3, int* n4)
        {
            //  -- LAPACK auxiliary routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. 
            //     January 2007 

            //  Purpose 
            //  ======= 

            //  ILAENV is called from the LAPACK routines to choose problem-dependent 
            //  parameters for the local environment.  See ISPEC for a description of 
            //  the parameters. 

            //  ILAENV returns an int 
            //  if ILAENV >= 0: ILAENV returns the value of the parameter specified by ISPEC 
            //  if ILAENV < 0:  if ILAENV = -k, the k-th argument had an illegal value. 

            //  This version provides a set of parameters which should give good, 
            //  but not optimal, performance on many of the currently available 
            //  computers.  Users are encouraged to modify this subroutine to set 
            //  the tuning parameters for their particular machine using the option 
            //  and problem size information in the arguments. 

            //  This routine will not function correctly if it is converted to all 
            //  lower case.  Converting it to all upper case is allowed. 

            //  Arguments 
            //  ========= 

            //  ISPEC   (input) int 
            //          Specifies the parameter to be returned as the value of 
            //          ILAENV. 
            //          = 1: the optimal blocksize; if this value is 1, an unblocked 
            //               algorithm will give the best performance. 
            //          = 2: the minimum block size for which the block routine 
            //               should be used; if the usable block size is less than 
            //               this value, an unblocked routine should be used. 
            //          = 3: the crossover point (in a block routine, for N less 
            //               than this value, an unblocked routine should be used) 
            //          = 4: the number of shifts, used in the nonsymmetric 
            //               eigenvalue routines (DEPRECATED) 
            //          = 5: the minimum column dimension for blocking to be used; 
            //               rectangular blocks must have dimension at least k by m, 
            //               where k is given by ILAENV(2,...) and m by ILAENV(5,...) 
            //          = 6: the crossover point for the SVD (when reducing an m by n 
            //               matrix to bidiagonal form, if max(m,n)/min(m,n) exceeds 
            //               this value, a QR factorization is used first to reduce 
            //               the matrix to a triangular form.) 
            //          = 7: the number of processors 
            //          = 8: the crossover point for the multishift QR method 
            //               for nonsymmetric eigenvalue problems (DEPRECATED) 
            //          = 9: maximum size of the subproblems at the bottom of the 
            //               computation tree in the divide-and-conquer algorithm 
            //               (used by xGELSD and xGESDD) 
            //          =10: ieee NaN arithmetic can be trusted not to trap 
            //          =11: infinity arithmetic can be trusted not to trap 
            //          12 <= ISPEC <= 16: 
            //               xHSEQR or one of its subroutines, 
            //               see IPARMQ for detailed explanation 

            //  NAME    (input) CHARACTER*(*) 
            //          The name of the calling subroutine, in either upper case or 
            //          lower case. 

            //  OPTS    (input) CHARACTER*(*) 
            //          The character options to the subroutine NAME, concatenated 
            //          into a single character string.  For example, UPLO = 'U', 
            //          TRANS = 'T', and DIAG = 'N' for a triangular routine would 
            //          be specified as OPTS = 'UTN'. 

            //  N1      (input) int 
            //  N2      (input) int 
            //  N3      (input) int 
            //  N4      (input) int 
            //          Problem dimensions for the subroutine NAME; these may not all 
            //          be required. 

            //  Further Details 
            //  =============== 

            //  The following conventions have been used when calling ILAENV from the 
            //  LAPACK routines: 
            //  1)  OPTS is a concatenation of all of the character options to 
            //      subroutine NAME, in the same order that they appear in the 
            //      argument list for NAME, even if they are not used in determining 
            //      the value of the parameter specified by ISPEC. 
            //  2)  The problem dimensions N1, N2, N3, N4 are specified in the order 
            //      that they appear in the argument list for NAME.  N1 is used 
            //      first, N2 second, and so on, and unused problem dimensions are 
            //      passed a value of -1. 
            //  3)  The parameter value returned by ILAENV is checked for validity in 
            //      the calling subroutine.  For example, ILAENV is used to retrieve 
            //      the optimal blocksize for STRTRI as follows: 

            //      NB = ILAENV( 1, 'STRTRI', UPLO // DIAG, N, -1, -1, -1 ) 
            //      IF( NB.LE.1 ) NB = MAX( 1, N ) 

            //  ===================================================================== 

            // System generated locals 
            int ret_val;

            // Table of constant values
            int c__1 = 1;
            float c_b163 = 0.0f;
            float c_b164 = 1.0f;
            int c__0 = 0;

            // Local variables
            string c1, c2, c3, c4;
            int nb, nx;
            bool cname;
            int nbmin;
            bool sname;
            string subnam;


            switch (*ispec)
            {
                case 1: goto L10;
                case 2: goto L10;
                case 3: goto L10;
                case 4: goto L80;
                case 5: goto L90;
                case 6: goto L100;
                case 7: goto L110;
                case 8: goto L120;
                case 9: goto L130;
                case 10: goto L140;
                case 11: goto L150;
                case 12: goto L160;
                case 13: goto L160;
                case 14: goto L160;
                case 15: goto L160;
                case 16: goto L160;
            }

            // Invalid value for ISPEC 

            ret_val = -1;
            return ret_val;

        L10:

            // Convert NAME to upper case if the first character is lower case. 
            subnam = name.ToUpper();

            ret_val = 1;

            c1 = subnam[0].ToString();
            sname = (c1 == "S" || c1 == "D");
            cname = (c1 == "C" || c1 == "Z");

            if (!(cname || sname))
            {
                return ret_val;
            }

            c2 = subnam.Substring(1, 2);
            c3 = subnam.Substring(3, 3);
            c4 = c3.Substring(1, 2);

            switch (*ispec)
            {
                case 1: goto L50;
                case 2: goto L60;
                case 3: goto L70;
            }

        L50:

            // ISPEC = 1:  block size 

            // In these examples, separate code is provided for setting NB for 
            // float and complex.  We assume that NB will take the same value in 
            // single or double precision. 

            nb = 1;

            if (c2 == "GE")
            {
                if (c3 == "TRF")
                {
                    if (sname)
                        nb = 64;
                    else
                        nb = 64;
                }
                else if (c3 == "QRF" || c3 == "RQF" || c3 == "LQF" || c3 == "QLF")
                {
                    if (sname)
                        nb = 32;
                    else
                        nb = 32;
                }
                else if (c3 == "HRD")
                {
                    if (sname)
                        nb = 32;
                    else
                        nb = 32;
                }
                else if (c3 == "BRD")
                {
                    if (sname)
                        nb = 32;
                    else
                        nb = 32;
                }
                else if (c3 == "TRI")
                {
                    if (sname)
                        nb = 64;
                    else
                        nb = 64;
                }
            }
            else if (c2 == "PO")
            {
                if (c3 == "TRF")
                {
                    if (sname)
                        nb = 64;
                    else
                        nb = 64;
                }
            }
            else if (c2 == "SY")
            {
                if (c3 == "TRF")
                {
                    if (sname)
                        nb = 64;
                    else
                        nb = 64;
                }
                else if (sname && c3 == "TRD")
                {
                    nb = 32;
                }
                else if (sname && c3 == "GST")
                {
                    nb = 64;
                }
            }
            else if (cname && c2 == "HE")
            {
                if (c3 == "TRF")
                {
                    nb = 64;
                }
                else if (c3 == "TRD")
                {
                    nb = 32;
                }
                else if (c3 == "GST")
                {
                    nb = 64;
                }
            }
            else if (sname && c2 == "OR")
            {
                if (c3[0] == 'G')
                {
                    if (c4 == "QR" || c4 == "RQ" || c4 == "LQ" || c4 == "QL" || c4 == "HR" || c4 == "TR" || c4 == "BR")
                    {
                        nb = 32;
                    }
                }
                else if (c3[0] == 'M')
                {
                    if (c4 == "QR" || c4 == "RQ" || c4 == "LQ" || c4 == "QL" || c4 == "HR" || c4 == "TR" || c4 == "BR")
                    {
                        nb = 32;
                    }
                }
            }
            else if (cname && c2 == "UN")
            {
                if (c3[0] == 'G')
                {
                    if (c4 == "QR" || c4 == "RQ" || c4 == "LQ" || c4 == "QL" || c4 == "HR" || c4 == "TR" || c4 == "BR")
                    {
                        nb = 32;
                    }
                }
                else if (c3[0] == 'M')
                {
                    if (c4 == "QR" || c4 == "RQ" || c4 == "LQ" || c4 == "QL" || c4 == "HR" || c4 == "TR" || c4 == "BR")
                    {
                        nb = 32;
                    }
                }
            }
            else if (c2 == "GB")
            {
                if (c3 == "TRF")
                {
                    if (sname)
                    {
                        if (*n4 <= 64)
                            nb = 1;
                        else
                            nb = 32;
                    }
                    else
                    {
                        if (*n4 <= 64)
                            nb = 1;
                        else
                            nb = 32;
                    }
                }
            }
            else if (c2 == "PB")
            {
                if (c3 == "TRF")
                {
                    if (sname)
                    {
                        if (*n2 <= 64)
                            nb = 1;
                        else
                            nb = 32;
                    }
                    else
                    {
                        if (*n2 <= 64)
                            nb = 1;
                        else
                            nb = 32;
                    }
                }
            }
            else if (c2 == "TR")
            {
                if (c3 == "TRI")
                {
                    if (sname)
                        nb = 64;
                    else
                        nb = 64;
                }
            }
            else if (c2 == "LA")
            {
                if (c3 == "UUM")
                {
                    if (sname)
                        nb = 64;
                    else
                        nb = 64;
                }
            }
            else if (sname && c2 == "ST")
            {
                if (c3 == "EBZ")
                {
                    nb = 1;
                }
            }
            ret_val = nb;
            return ret_val;

        L60:

            // ISPEC = 2:  minimum block size 

            nbmin = 2;
            if (c2 == "GE")
            {
                if (c3 == "QRF" || c3 == "RQF" || c3 == "LQF" || c3 == "QLF")
                {
                    if (sname)
                    {
                        nbmin = 2;
                    }
                    else
                    {
                        nbmin = 2;
                    }
                }
                else if (c3 == "HRD")
                {
                    if (sname)
                    {
                        nbmin = 2;
                    }
                    else
                    {
                        nbmin = 2;
                    }
                }
                else if (c3 == "BRD")
                {
                    if (sname)
                    {
                        nbmin = 2;
                    }
                    else
                    {
                        nbmin = 2;
                    }
                }
                else if (c3 == "TRI")
                {
                    if (sname)
                    {
                        nbmin = 2;
                    }
                    else
                    {
                        nbmin = 2;
                    }
                }
            }
            else if (c2 == "SY")
            {
                if (c3 == "TRF")
                {
                    if (sname)
                    {
                        nbmin = 8;
                    }
                    else
                    {
                        nbmin = 8;
                    }
                }
                else if (sname && c3 == "TRD")
                {
                    nbmin = 2;
                }
            }
            else if (cname && c2 == "HE")
            {
                if (c3 == "TRD")
                {
                    nbmin = 2;
                }
            }
            else if (sname && c2 == "OR")
            {
                if (c3[0] == 'G')
                {
                    if (c4 == "QR" || c4 == "RQ" || c4 == "LQ" || c4 == "QL" || c4 == "HR" || c4 == "TR" || c4 == "BR")
                    {
                        nbmin = 2;
                    }
                }
                else if (c3[0] == 'M')
                {
                    if (c4 == "QR" || c4 == "RQ" || c4 == "LQ" ||
                    c4 == "QL" || c4 == "HR" || c4 == "TR" || c4 == "BR")
                    {
                        nbmin = 2;
                    }
                }
            }
            else if (cname && c2 == "UN")
            {
                if (c3[0] == 'G')
                {
                    if (c4 == "QR" || c4 == "RQ" || c4 == "LQ" || c4 == "QL" || c4 == "HR" || c4 == "TR" || c4 == "BR")
                    {
                        nbmin = 2;
                    }
                }
                else if (c3[0] == 'M')
                {
                    if (c4 == "QR" || c4 == "RQ" || c4 == "LQ" || c4 == "QL" || c4 == "HR" || c4 == "TR" || c4 == "BR")
                    {
                        nbmin = 2;
                    }
                }
            }

            ret_val = nbmin;
            return ret_val;

        L70:

            // ISPEC = 3:  crossover point 

            nx = 0;
            if (c2 == "GE")
            {
                if (c3 == "QRF" || c3 == "RQF" || c3 == "LQF" || c3 == "QLF")
                {
                    if (sname)
                    {
                        nx = 128;
                    }
                    else
                    {
                        nx = 128;
                    }
                }
                else if (c3 == "HRD")
                {
                    if (sname)
                    {
                        nx = 128;
                    }
                    else
                    {
                        nx = 128;
                    }
                }
                else if (c3 == "BRD")
                {
                    if (sname)
                    {
                        nx = 128;
                    }
                    else
                    {
                        nx = 128;
                    }
                }
            }
            else if (c2 == "SY")
            {
                if (sname && c3 == "TRD")
                {
                    nx = 32;
                }
            }
            else if (cname && c2 == "HE")
            {
                if (c3 == "TRD")
                {
                    nx = 32;
                }
            }
            else if (sname && c2 == "OR")
            {
                if (c3[0] == 'G')
                {
                    if (c4 == "QR" || c4 == "RQ" || c4 == "LQ" || c4 == "QL" || c4 == "HR" || c4 == "TR" || c4 == "BR")
                    {
                        nx = 128;
                    }
                }
            }
            else if (cname && c2 == "UN")
            {
                if (c3[0] == 'G')
                {
                    if (c4 == "QR" || c4 == "RQ" || c4 == "LQ" || c4 == "QL" || c4 == "HR" || c4 == "TR" || c4 == "BR")
                    {
                        nx = 128;
                    }
                }
            }

            ret_val = nx;
            return ret_val;

        L80:

            // ISPEC = 4:  number of shifts (used by xHSEQR) 

            ret_val = 6;
            return ret_val;

        L90:

            // ISPEC = 5:  minimum column dimension (not used) 

            ret_val = 2;
            return ret_val;

        L100:

            // ISPEC = 6:  crossover point for SVD (used by xGELSS and xGESVD) 

            ret_val = (int)((float)Math.Min(*n1, *n2) * 1.6f);
            return ret_val;

        L110:

            // ISPEC = 7:  number of processors (not used) 

            ret_val = 1;
            return ret_val;

        L120:

            // ISPEC = 8:  crossover point for multishift (used by xHSEQR) 

            ret_val = 50;
            return ret_val;

        L130:

            // ISPEC = 9:  maximum size of the subproblems at the bottom of the 
            // computation tree in the divide-and-conquer algorithm 
            // (used by xGELSD and xGESDD) 

            ret_val = 25;
            return ret_val;

        L140:

            // ISPEC = 10: ieee NaN arithmetic can be trusted not to trap 

            // ILAENV = 0 
            ret_val = 1;
            if (ret_val == 1)
            {
                ret_val = ieeeck(&c__1, &c_b163, &c_b164);
            }
            return ret_val;

        L150:

            // ISPEC = 11: infinity arithmetic can be trusted not to trap 

            // ILAENV = 0 
            ret_val = 1;
            if (ret_val == 1)
            {
                ret_val = ieeeck(&c__0, &c_b163, &c_b164);
            }

            return ret_val;

        L160:

            // 12 <= ISPEC <= 16: xHSEQR or one of its subroutines. 

            ret_val = iparmq(ispec, name, opts, n1, n2, n3, n4);

            return ret_val;
        }

        [SuppressUnmanagedCodeSecurity]
        public static int iparmq(int* ispec, string name, string opts, int* n, int* ilo, int* ihi, int* lwork)
        {
            //  -- LAPACK auxiliary routine (version 3.2) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. 
            //     November 2006 

            //  Purpose 
            //  ======= 

            //       This program sets problem and machine dependent parameters 
            //       useful for xHSEQR and its subroutines. It is called whenever 
            //       ILAENV is called with 12 <= ISPEC <= 16 

            //  Arguments 
            //  ========= 

            //       ISPEC  (input) int scalar 
            //              ISPEC specifies which tunable parameter IPARMQ should 
            //              return. 

            //              ISPEC=12: (INMIN)  Matrices of order nmin or less 
            //                        are sent directly to xLAHQR, the implicit 
            //                        double shift QR algorithm.  NMIN must be 
            //                        at least 11. 

            //              ISPEC=13: (INWIN)  Size of the deflation window. 
            //                        This is best set greater than or equal to 
            //                        the number of simultaneous shifts NS. 
            //                        Larger matrices benefit from larger deflation 
            //                        windows. 

            //              ISPEC=14: (INIBL) Determines when to stop nibbling and 
            //                        invest in an (expensive) multi-shift QR sweep. 
            //                        If the aggressive early deflation subroutine 
            //                        finds LD converged eigenvalues from an order 
            //                        NW deflation window and LD.GT.(NW*NIBBLE)/100, 
            //                        then the next QR sweep is skipped and early 
            //                        deflation is applied immediately to the 
            //                        remaining active diagonal block.  Setting 
            //                        IPARMQ(ISPEC=14) = 0 causes TTQRE to skip a 
            //                        multi-shift QR sweep whenever early deflation 
            //                        finds a converged eigenvalue.  Setting 
            //                        IPARMQ(ISPEC=14) greater than or equal to 100 
            //                        prevents TTQRE from skipping a multi-shift 
            //                        QR sweep. 

            //              ISPEC=15: (NSHFTS) The number of simultaneous shifts in 
            //                        a multi-shift QR iteration. 

            //              ISPEC=16: (IACC22) IPARMQ is set to 0, 1 or 2 with the 
            //                        following meanings. 
            //                        0:  During the multi-shift QR sweep, 
            //                            xLAQR5 does not accumulate reflections and 
            //                            does not use matrix-matrix multiply to 
            //                            update the far-from-diagonal matrix 
            //                            entries. 
            //                        1:  During the multi-shift QR sweep, 
            //                            xLAQR5 and/or xLAQRaccumulates reflections and uses 
            //                            matrix-matrix multiply to update the 
            //                            far-from-diagonal matrix entries. 
            //                        2:  During the multi-shift QR sweep. 
            //                            xLAQR5 accumulates reflections and takes 
            //                            advantage of 2-by-2 block structure during 
            //                            matrix-matrix multiplies. 
            //                        (If xTRMM is slower than xGEMM, then 
            //                        IPARMQ(ISPEC=16)=1 may be more efficient than 
            //                        IPARMQ(ISPEC=16)=2 despite the greater level of 
            //                        arithmetic work implied by the latter choice.) 

            //       NAME    (input) character string 
            //               Name of the calling subroutine 

            //       OPTS    (input) character string 
            //               This is a concatenation of the string arguments to 
            //               TTQRE. 

            //       N       (input) int scalar 
            //               N is the order of the Hessenberg matrix H. 

            //       ILO     (input) int 
            //       IHI     (input) int 
            //               It is assumed that H is already upper triangular 
            //               in rows and columns 1:ILO-1 and IHI+1:N. 

            //       LWORK   (input) int scalar 
            //               The amount of workspace available. 

            //  Further Details 
            //  =============== 

            //       Little is known about how best to choose these parameters. 
            //       It is possible to use different values of the parameters 
            //       for each of CHSEQR, DHSEQR, SHSEQR and ZHSEQR. 

            //       It is probably best to choose different parameters for 
            //       different matrices and different parameters at different 
            //       times during the iteration, but this has not been 
            //       implemented --- yet. 


            //       The best choices of most of the parameters depend 
            //       in an ill-understood way on the relative execution 
            //       rate of xLAQR3 and xLAQR5 and on the nature of each 
            //       particular eigenvalue problem.  Experiment may be the 
            //       only practical way to determine which choices are most 
            //       effective. 

            //       Following is a list of default values supplied by IPARMQ. 
            //       These defaults may be adjusted in order to attain better 
            //       performance in any particular computational environment. 

            //       IPARMQ(ISPEC=12) The xLAHQR vs xLAQR0 crossover point. 
            //                        Default: 75. (Must be at least 11.) 

            //       IPARMQ(ISPEC=13) Recommended deflation window size. 
            //                        This depends on ILO, IHI and NS, the 
            //                        number of simultaneous shifts returned 
            //                        by IPARMQ(ISPEC=15).  The default for 
            //                        (IHI-ILO+1).LE.500 is NS.  The default 
            //                        for (IHI-ILO+1).GT.500 is 3*NS/2. 

            //       IPARMQ(ISPEC=14) Nibble crossover point.  Default: 14. 

            //       IPARMQ(ISPEC=15) Number of simultaneous shifts, NS. 
            //                        a multi-shift QR iteration. 

            //                        If IHI-ILO+1 is ... 

            //                        greater than      ...but less    ... the 
            //                        or equal to ...      than        default is 

            //                                0               30       NS =   2+ 
            //                               30               60       NS =   4+ 
            //                               60              150       NS =  10 
            //                              150              590       NS =  ** 
            //                              590             3000       NS =  64 
            //                             3000             6000       NS = 128 
            //                             6000             infinity   NS = 256 

            //                    (+)  By default matrices of this order are 
            //                         passed to the implicit double shift routine 
            //                         xLAHQR.  See IPARMQ(ISPEC=12) above.   These 
            //                         values of NS are used only in case of a rare 
            //                         xLAHQR failure. 

            //                    (**) The asterisks (**) indicate an ad-hoc 
            //                         function increasing from 10 to 64. 

            //       IPARMQ(ISPEC=16) Select structured matrix multiply. 
            //                        (See ISPEC=16 above for details.) 
            //                        Default: 3. 

            //     ================================================================ 

            // System generated locals 
            int ret_val, i__1, i__2;
            float r__1;

            // Local variables 
            int nh = 0, ns = 0;

            if (*ispec == 15 || *ispec == 13 || *ispec == 16)
            {
                // ==== Set the number simultaneous shifts ==== 

                nh = *ihi - *ilo + 1;
                ns = 2;
                if (nh >= 30)
                {
                    ns = 4;
                }
                if (nh >= 60)
                {
                    ns = 10;
                }
                if (nh >= 150)
                {
                    // Computing MAX 
                    r__1 = (float)(Math.Log((float)nh) / Math.Log(2.0f));
                    i__1 = 10;
                    i__2 = nh / i_nint(&r__1);
                    ns = Math.Max(i__1, i__2);
                }
                if (nh >= 590)
                {
                    ns = 64;
                }
                if (nh >= 3000)
                {
                    ns = 128;
                }
                if (nh >= 6000)
                {
                    ns = 256;
                }
                // Computing MAX 
                i__1 = 2;
                i__2 = ns - ns % 2;
                ns = Math.Max(i__1, i__2);
            }

            if (*ispec == 12)
            {
                // ===== Matrices of order smaller than NMIN get sent 
                // .     to xLAHQR, the classic double shift algorithm. 
                // .     This must be at least 11. ==== 

                ret_val = 75;

            }
            else if (*ispec == 14)
            {
                // ==== INIBL: skip a multi-shift qr iteration and 
                // .    whenever aggressive early deflation finds 
                // .    at least (NIBBLE*(window size)/100) deflations. ==== 

                ret_val = 14;

            }
            else if (*ispec == 15)
            {
                // ==== NSHFTS: The number of simultaneous shifts ===== 
                ret_val = ns;

            }
            else if (*ispec == 13)
            {
                //  ==== NW: deflation window size.  ==== 

                if (nh <= 500)
                {
                    ret_val = ns;
                }
                else
                {
                    ret_val = ns * 3 / 2;
                }
            }
            else if (*ispec == 16)
            {
                // ==== IACC22: Whether to accumulate reflections 
                // .     before updating the far-from-diagonal elements 
                // .     and whether to use 2-by-2 block structure while 
                // .     doing it.  A small amount of work could be saved 
                // .     by making this choice dependent also upon the 
                // .     NH=IHI-ILO+1. 

                ret_val = 0;
                if (ns >= 14)
                {
                    ret_val = 1;
                }
                if (ns >= 14)
                {
                    ret_val = 2;
                }

            }
            else
            {
                // ===== invalid value of ispec ===== 
                ret_val = -1;
            }

            return ret_val;
        }

        [SuppressUnmanagedCodeSecurity]
        public static bool lsame(string ca, string cb)
        {
            //  -- LAPACK auxiliary routine (version 3.1) -- 
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. 
            //     November 2006 

            //  Purpose 
            //  ======= 

            //  LSAME returns .TRUE. if CA is the same letter as CB regardless of 
            //  case. 

            //  Arguments 
            //  ========= 

            //  CA      (input) CHARACTER*1 

            //  CB      (input) CHARACTER*1 
            //          CA and CB specify the single characters to be compared. 

            // ===================================================================== 

            // Test if the characters are equal

            return Char.ToUpper(ca[0]) == Char.ToUpper(cb[0]);
        }

        [SuppressUnmanagedCodeSecurity]
        public static int xerbla(string srname, int* info)
        {
            //  -- LAPACK auxiliary routine (preliminary version) --
            //     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
            //     November 2006

            //  Purpose
            //  =======

            //  XERBLA  is an error handler for the LAPACK routines.
            //  It is called by an LAPACK routine if an input parameter has an
            //  invalid value.  A message is printed and execution stops.

            //  Installers may consider modifying the STOP statement in order to
            //  call system-specific exception-handling facilities.

            //  Arguments
            //  =========

            //  SRNAME  (input) CHARACTER*(*)
            //          The name of the routine which called XERBLA.

            //  INFO    (input) INTEGER
            //          The position of the invalid parameter in the parameter list
            //          of the calling routine. 

            // =====================================================================

            Debug.WriteLine(String.Format("On entry to {0}, parameter number {1} had an illegal value.", srname, *info));
            //throw new ArgumentException(String.Format("On entry to {0}, parameter number {1} had an illegal value.", srname, *info));

            return 0;
        }

        #endregion
    }
}
